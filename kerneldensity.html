<html><head>
        <!-- Generated by Ddoc from ../../../.dub/packages/dstats-1.0.3/dstats/source/dstats/kerneldensity.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>dstats.kerneldensity</title>
        </head><body>
        <h1>dstats.kerneldensity</h1>
This module contains a small but growing library for performing kernel
 density estimation.
<br><br>
<b>Author:</b><br>
David Simcha<br><br>

<dl><dt><big><a name="KernelDensity1D"></a>class <u>KernelDensity1D</u>;
</big></dt>
<dd>Estimates densities in the 1-dimensional case.  The 1-D case is special
 enough to be treated as a special case, since it's very common and enables
 some significant optimizations that are otherwise not feasible.
<br><br>
Under the hood, this works by binning the data into a large number of bins
 (currently 1,000), convolving it with the kernel function to smooth it, and
 then using linear interpolation to evaluate the density estimates.  This
 will produce results that are different from the textbook definition of
 kernel density estimation, but to an extent that's negligible in most cases.
 It also means that constructing this object is relatively expensive, but
 evaluating a density estimate can be done in O(1) time complexity afterwords.<br><br>

<dl><dt><big><a name="KernelDensity1D.fromCallable"></a>KernelDensity1D <u>fromCallable</u>(C, R)(scope C <i>kernel</i>, R <i>range</i>, double <i>edgeBuffer</i> = (double).nan) if (isForwardRange!R &amp;&amp; is(typeof(<i>kernel</i>(2.00000)) : double));
</big></dt>
<dd>Construct a <i>kernel</i> density estimation object from a callable object.
 R must be a <i>range</i> of numeric types.  C must be a <i>kernel</i> function,
 delegate, or class or struct with overloaded opCall.  The <i>kernel</i>
 function is assumed to be symmetric about zero, to take its maximum
 value at zero and to be unimodal.
<br><br>
<i>edgeBuffer</i> determines how much space below and above the smallest and
 largest observed value will be allocated when doing the binning.
 Values less than reduce!min(<i>range</i>) - <i>edgeBuffer</i> or greater than
 reduce!max(<i>range</i>) + <i>edgeBuffer</i> will be assigned a density of zero.
 If this value is left at its default, it will be set to a value at which
 the <i>kernel</i> is somewhere between 1e-3 and 1e-4 times its value at zero.
<br><br>

 The bandwidth of the <i>kernel</i> is indirectly selected by parametrizing the
 <i>kernel</i> function.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>auto</font> randNums = randArray!rNorm(1_000, 0, 1);
<font color=blue>auto</font> <i>kernel</i> = parametrize!normalPDF(0, 0.01);
<font color=blue>auto</font> density = KernelDensity1D(<i>kernel</i>, randNums);
writeln(normalPDF(1, 0, 1), <font color=red>"  "</font>, density(1)).  <font color=green>// Should be about the same.
</font></pre>
<br><br>

</dd>
<dt><big><a name="KernelDensity1D.fromAlias"></a>KernelDensity1D <u>fromAlias</u>(alias kernel, R)(R <i>range</i>, double <i>edgeBuffer</i> = (double).nan) if (isForwardRange!R &amp;&amp; is(typeof(kernel(2.00000)) : double));
</big></dt>
<dd>Construct a kernel density estimator from an alias.<br><br>

</dd>
<dt><big><a name="KernelDensity1D.fromDefaultKernel"></a>KernelDensity1D <u>fromDefaultKernel</u>(R)(R <i>range</i>, double <i>edgeBuffer</i> = (double).nan) if (isForwardRange!R &amp;&amp; is(ElementType!R : double));
</big></dt>
<dd>Construct a kernel density estimator using the default kernel, which is
 a Gaussian kernel with the Scott bandwidth.<br><br>

</dd>
<dt><big><a name="KernelDensity1D.opCall"></a>const double <u>opCall</u>(double <i>x</i>);
</big></dt>
<dd>Compute the probability density at a given point.<br><br>

</dd>
<dt><big><a name="KernelDensity1D.cdf"></a>const double <u>cdf</u>(double <i>x</i>);
</big></dt>
<dd>Compute the cumulative density, i.e. the integral from -infinity to <i>x</i>.<br><br>

</dd>
<dt><big><a name="KernelDensity1D.cdfr"></a>const double <u>cdfr</u>(double <i>x</i>);
</big></dt>
<dd>Compute the cumulative density from the rhs, i.e. the integral from
 <i>x</i> to infinity.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="scottBandwidth"></a>double <u>scottBandwidth</u>(R)(R <i>data</i>) if (isForwardRange!R &amp;&amp; is(ElementType!R : double));
</big></dt>
<dd>Uses Scott's Rule to select the bandwidth of the Gaussian kernel density
 estimator.  This is 1.06 * min(stdev(<i>data</i>), interquartileRange(<i>data</i>) / 1.34)
 N ^^ -0.2.  R must be a forward range of numeric types.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>immutable</font> bandwidth = <u>scottBandwidth</u>(<i>data</i>);
<font color=blue>auto</font> kernel = parametrize!normalPDF(0, bandwidth);
<font color=blue>auto</font> kde = KernelDensity1D(<i>data</i>, kernel);
</pre>

<br><br>
<b>References:</b><br>
Scott, D. W. (1992) Multivariate Density Estimation: Theory, Practice,
 and Visualization. Wiley.<br><br>

</dd>
<dt><big><a name="KernelDensity"></a>class <u>KernelDensity</u>;
</big></dt>
<dd>Construct an N-dimensional kernel density estimator.  This is done using
 the textbook definition of kernel density estimation, since the binning
 and convolving method used in the 1-D case would rapidly become
 unfeasible w.r.t. memory usage as dimensionality increased.
<br><br>
Eventually, a 2-D estimator might be added as another special case, but
 beyond 2-D, bin-and-convolute clearly isn't feasible.
<br><br>

 This class can be used for 1-D estimation instead of KernelDensity1D, and
 will work properly.  This is useful if:
<br><br>

 1.  You can't accept even the slightest deviation from the results that the
     textbook definition of kernel density estimation would produce.
<br><br>

 2.  You are only going to evaluate at a few points and want to avoid the
     up-front cost of the convolution used in the 1-D case.
<br><br>

 3.  You're using some weird kernel that doesn't meet the assumptions
     required for KernelDensity1D.<br><br>

<dl><dt><big><a name="KernelDensity.nDimensions"></a>const @property uint <u>nDimensions</u>();
</big></dt>
<dd>Returns the number of dimensions in the estimator.<br><br>

</dd>
<dt><big><a name="KernelDensity.fromCallable"></a>KernelDensity <u>fromCallable</u>(C, R...)(C <i>kernel</i>, R <i>ranges</i>) if (allSatisfy!(isInputRange, R));
</big></dt>
<dd>Construct a <i>kernel</i> density estimator from a <i>kernel</i> provided as a callable
 object (such as a function pointer, delegate, or class with overloaded
 opCall).  R must be either a range of <i>ranges</i>, multiple <i>ranges</i> passed in
 as variadic arguments, or a single range for the 1D case.  Each range
 represents the values of one variable in the joint distribution.
 <i>kernel</i> must accept either an array of doubles or the same number of
 arguments as the number of dimensions, and must return a floating point
 number.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=green>// Create an estimate of the density of the joint distribution of
</font><font color=green>// hours sleep and programming skill.
</font><font color=blue>auto</font> programmingSkill = [8,6,7,5,3,0,9];
<font color=blue>auto</font> hoursSleep = [3,6,2,4,3,5,8];

<font color=green>// Make a 2D Gaussian kernel function with bandwidth 0.5 in both
</font><font color=green>// dimensions and covariance zero.
</font><font color=blue>static</font> <font color=blue>double</font> myKernel(<font color=blue>double</font> x1, <font color=blue>double</font> x2) {
   <font color=blue>return</font> normalPDF(x1, 0, 0.5) * normalPDF(x2, 0, 0.5);
}

<font color=blue>auto</font> estimator = KernelDensity.<u>fromCallable</u>
    (&amp;myKernel, programmingSkill, hoursSleep);

<font color=green>// Estimate the density at programming skill 1, 2 hours sleep.
</font><font color=blue>auto</font> density = estimator(1, 2);
</pre>
<br><br>

</dd>
<dt><big><a name="KernelDensity.opCall"></a>const double <u>opCall</u>(double[] <i>x</i>...);
</big></dt>
<dd>Estimate the density at the point given by <i>x</i>.  The variables in X are
 provided in the same order as the ranges were provided for estimation.<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
