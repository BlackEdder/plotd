<html><head>
        <!-- Generated by Ddoc from ../../../.dub/packages/cairod-0.0.1-alpha.3_1.10.2/cairod/src/cairo/cairo.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>cairo.cairo</title>
        </head><body>
        <h1>cairo.cairo</h1>
This module contains wrappers for most of <u>cairo</u>'s fuctionality.
 Additional wrappers for subsets of <u>cairo</u> are available in the
 <u>cairo</u>.* modules.
<br><br>
<b>Note:</b><br>
Most cairoD functions could throw an OutOfMemoryError. This is therefore not
 explicitly stated in the functions' api documenation.

<br><br>
<b>See Also:</b><br>
<a href="http://cairographics.org/documentation/">http://cairographics.org/documentation/</a>

<br><br>
<b>License:</b><br>
<table>   <tr><td>cairoD wrapper/bindings</td>
     <td><a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a></td></tr>
   <tr><td><a href="http://cgit.freedesktop.org/cairo/tree/COPYING">cairo</a></td>
     <td><a href="http://cgit.freedesktop.org/cairo/tree/COPYING-LGPL-2.1">LGPL 2.1</a> /
     <a href="http://cgit.freedesktop.org/cairo/plain/COPYING-MPL-1.1">MPL 1.1</a></td></tr>
 </table>
<br><br>
<b>Authors:</b><br>
<table>   <tr><td>Johannes Pfau</td> <td>cairoD</td></tr>
   <tr><td>Andrej Mitrovic</td> <td>cairoD</td></tr>
   <tr><td><a href="http://cairographics.org">cairo team</a></td> <td>cairo</td></tr>
 </table><br><br>

<dl><dt><big><a name="throwError"></a>void <u>throwError</u>(cairo_status_t <i>status</i>, string <i>file</i> = __FILE__, int <i>line</i> = __LINE__);
</big></dt>
<dd>Mainly used internally by cairoD.
 If <i>status</i> is CAIRO_STATUS_NO_MEMORY a OutOfMemoryError is thrown.
 If <i>status</i> is  CAIRO_STATUS_SUCCESS nothing happens.
 For all other statuses, this functions throws
 a  with the <i>status</i> value.<br><br>

</dd>
<dt><big><a name="CairoException"></a>class <u>CairoException</u>: <u>object.Exception</u>;
</big></dt>
<dd>Exception thrown by cairoD if an error occurs.<br><br>

<dl><dt><big><a name="CairoException.status"></a>cairo_status_t <u>status</u>;
</big></dt>
<dd>Cairo's error <u>status</u>.
 Gives further information about the error.<br><br>

</dd>
<dt><big><a name="CairoException.this"></a>this(cairo_status_t <i>stat</i>, string <i>file</i> = __FILE__, int <i>line</i> = __LINE__);
</big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><big><a name="Content"></a>alias <u>Content</u> = cairo.c.cairo.cairo_content_t;
<br><a name="AntiAlias"></a>alias <u>AntiAlias</u> = cairo.c.cairo.cairo_antialias_t;
<br><a name="SubpixelOrder"></a>alias <u>SubpixelOrder</u> = cairo.c.cairo.cairo_subpixel_order_t;
<br><a name="HintStyle"></a>alias <u>HintStyle</u> = cairo.c.cairo.cairo_hint_style_t;
<br><a name="HintMetrics"></a>alias <u>HintMetrics</u> = cairo.c.cairo.cairo_hint_metrics_t;
<br><a name="SurfaceType"></a>alias <u>SurfaceType</u> = cairo.c.cairo.cairo_surface_type_t;
<br><a name="Format"></a>alias <u>Format</u> = cairo.c.cairo.cairo_format_t;
<br><a name="Extend"></a>alias <u>Extend</u> = cairo.c.cairo.cairo_extend_t;
<br><a name="Filter"></a>alias <u>Filter</u> = cairo.c.cairo.cairo_filter_t;
<br><a name="PatternType"></a>alias <u>PatternType</u> = cairo.c.cairo.cairo_pattern_type_t;
<br><a name="FillRule"></a>alias <u>FillRule</u> = cairo.c.cairo.cairo_fill_rule_t;
<br><a name="LineCap"></a>alias <u>LineCap</u> = cairo.c.cairo.cairo_line_cap_t;
<br><a name="LineJoin"></a>alias <u>LineJoin</u> = cairo.c.cairo.cairo_line_join_t;
<br><a name="Operator"></a>alias <u>Operator</u> = cairo.c.cairo.cairo_operator_t;
<br><a name="PathElementType"></a>alias <u>PathElementType</u> = cairo.c.cairo.cairo_path_data_type_t;
<br><a name="FontExtents"></a>alias <u>FontExtents</u> = cairo.c.cairo.cairo_font_extents_t;
<br><a name="TextExtents"></a>alias <u>TextExtents</u> = cairo.c.cairo.cairo_text_extents_t;
<br><a name="Glyph"></a>alias <u>Glyph</u> = cairo.c.cairo.cairo_glyph_t;
<br><a name="TextCluster"></a>alias <u>TextCluster</u> = cairo.c.cairo.cairo_text_cluster_t;
<br><a name="TextClusterFlags"></a>alias <u>TextClusterFlags</u> = cairo.c.cairo.cairo_text_cluster_flags_t;
<br><a name="FontSlant"></a>alias <u>FontSlant</u> = cairo.c.cairo.cairo_font_slant_t;
<br><a name="FontWeight"></a>alias <u>FontWeight</u> = cairo.c.cairo.cairo_font_weight_t;
<br><a name="DeviceType"></a>alias <u>DeviceType</u> = cairo.c.cairo.cairo_device_type_t;
<br><a name="FontType"></a>alias <u>FontType</u> = cairo.c.cairo.cairo_font_type_t;
<br><a name="RegionOverlap"></a>alias <u>RegionOverlap</u> = cairo.c.cairo.cairo_region_overlap_t;
</big></dt>
<dd>Aliases for simple cairo enums and structs.
 Theses aliases provide D-like names when
 using the cairoD API.<br><br>

</dd>
<dt><big><a name="Point"></a>struct <u>Point</u>(T) if (isOneOf!(T, int, double));
</big></dt>
<dd>A simple struct to store the coordinates of a point as
 doubles or integers.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> p = <u>Point</u>!<font color=blue>double</font>(10, 10);  <font color=green>//Type Point!double
</font><font color=blue>auto</font> p2 = point(10.0, 10.0);    <font color=green>//Type Point!double
</font><font color=blue>auto</font> p3 = <u>Point</u>!<font color=blue>int</font>(10, 10);    <font color=green>//Type Point!int
</font><font color=blue>auto</font> p4 = point(10, 10);        <font color=green>//Type Point!int
</font><font color=blue>assert</font>(p == p2);
<font color=blue>assert</font>(p3 == p4);
</pre>
<br><br>
<dl><dt><big><a name="Point.this"></a>this(T <i>x</i>, T <i>y</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Point.x"></a>T <u>x</u>;
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Point.y"></a>T <u>y</u>;
</big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><big><a name="point"></a>auto <u>point</u>(T)(T <i>x</i>, T <i>y</i>) if (is(T == int) || is(T == double));
</big></dt>
<dd>Convenience function to create a  or .<br><br>

</dd>
<dt><big><a name="Rectangle"></a>struct <u>Rectangle</u>(T) if (isOneOf!(T, int, double));
</big></dt>
<dd>A simple struct representing a rectangle with  or  values<br><br>

<dl><dt><big><a name="Rectangle.this"></a>this(Point!T <i>point</i>, T <i>width</i>, T <i>height</i>);
<br>this(T <i>x</i>, T <i>y</i>, T <i>width</i>, T <i>height</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Rectangle.point"></a>Point!T <u>point</u>;
</big></dt>
<dd>TOP-LEFT <u>point</u> of the rectangle<br><br>

</dd>
<dt><big><a name="Rectangle.width"></a>T <u>width</u>;
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Rectangle.height"></a>T <u>height</u>;
</big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><big><a name="rectangle"></a>auto <u>rectangle</u>(T)(T <i>x</i>, T <i>y</i>, T <i>width</i>, T <i>height</i>) if (isOneOf!(T, int, double));
<br>auto <u>rectangle</u>(T)(Point!T <i>point</i>, T <i>width</i>, T <i>height</i>) if (isOneOf!(T, int, double));
</big></dt>
<dd>Convenience function to create a  or .<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> a = <u>rectangle</u>(1, 1, 4, 4);
Rectangle!<font color=blue>int</font> rectInt = a;
<font color=blue>auto</font> b = <u>rectangle</u>(0.99, 0.99, 3.99, 3.99);
Rectangle!<font color=blue>double</font> rectDouble = b;
</pre>
<br><br>
</dd>
<dt><big><a name="Size"></a>struct <u>Size</u>(T) if (is(T == int) || is(T == double));
</big></dt>
<dd>A simple struct representing a size with only  or  values<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> a = <u>Size</u>!<font color=blue>int</font>(10, 10);
<font color=blue>auto</font> a2 = size(10, 10);
<font color=blue>auto</font> b = <u>Size</u>!<font color=blue>double</font>(5, 5);
<font color=blue>auto</font> b2 = size(5.0, 5.0);
<font color=blue>assert</font>(a == a2);
<font color=blue>assert</font>(b == b2);
</pre>
<br><br>
<dl><dt><big><a name="Size.this"></a>this(T <i>width</i>, T <i>height</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Size.width"></a>T <u>width</u>;
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Size.height"></a>T <u>height</u>;
</big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><big><a name="size"></a>auto <u>size</u>(T)(T <i>width</i>, T <i>height</i>) if (isOneOf!(T, int, double));
</big></dt>
<dd>Convenience function to create a  or .<br><br>

</dd>
<dt><big><a name="Box"></a>struct <u>Box</u>;
</big></dt>
<dd>A simple struct representing a box.
 Used for Extents.<br><br>

<dl><dt><big><a name="Box.this"></a>this(Point!double <i>point1</i>, Point!double <i>point2</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Box.this.2"></a>this(double <i>x1</i>, double <i>y1</i>, double <i>x2</i>, double <i>y2</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Box.point1"></a>Point!double <u>point1</u>;
</big></dt>
<dd>Top-left point<br><br>

</dd>
<dt><big><a name="Box.point2"></a>Point!double <u>point2</u>;
</big></dt>
<dd>Bottom-right point<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Resolution"></a>struct <u>Resolution</u>;
</big></dt>
<dd>A simple struct representing a resolution<br><br>

<dl><dt><big><a name="Resolution.this"></a>this(double <i>resX</i>, double <i>resY</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Resolution.x"></a>double <u>x</u>;
</big></dt>
<dd>In pixels per inch<br><br>

</dd>
<dt><big><a name="Resolution.y"></a>double <u>y</u>;
</big></dt>
<dd>In pixels per inch<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="RGBA"></a>struct <u>RGBA</u>;
</big></dt>
<dd>Struct representing a <u>RGBA</u> color<br><br>

<dl><dt><big><a name="RGBA.this"></a>this(double <i>red</i>, double <i>green</i>, double <i>blue</i>, double <i>alpha</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="RGBA.red"></a>double <u>red</u>;
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="RGBA.green"></a>double <u>green</u>;
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="RGBA.blue"></a>double <u>blue</u>;
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="RGBA.alpha"></a>double <u>alpha</u>;
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="RGBA.opCast"></a>RGB <u>opCast</u>(RGB)();
</big></dt>
<dd>convert RGBA struct to RGB struct. Alpha is discarded<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="RGB"></a>struct <u>RGB</u>;
</big></dt>
<dd>Struct representing a <u>RGB</u> color<br><br>

<dl><dt><big><a name="RGB.this"></a>this(double <i>red</i>, double <i>green</i>, double <i>blue</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="RGB.red"></a>double <u>red</u>;
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="RGB.green"></a>double <u>green</u>;
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="RGB.blue"></a>double <u>blue</u>;
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="RGB.opCast"></a>RGBA <u>opCast</u>(RGBA)();
</big></dt>
<dd>convert RGBA struct to RGB struct. Alpha is set to '1.0'<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Path"></a>struct <u>Path</u>;
</big></dt>
<dd>Reference counted wrapper around .
 This struct can only be obtained from cairoD. It cannot be created
 manually.<br><br>

<dl><dt><big><a name="Path.this"></a>this(cairo_path_t* <i>path</i>);
</big></dt>
<dd>Create a Path from a existing .
 Path is a reference-counted type. It will call 
 when there are no more references to the <i>path</i>.
<br><br>
This means you should not destroy the  manually
 and you should not use  anymore after you created a Path
 with this constructor.

<br><br>
<b>Warning:</b><br>
<font color=red>Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</font><br><br>

</dd>
<dt><big><a name="Path.nativePointer"></a>@property cairo_path_t* <u>nativePointer</u>();
</big></dt>
<dd>The underlying  handle<br><br>

</dd>
<dt><big><a name="Path.debugging"></a>@property bool <u>debugging</u>();
<br>@property void <u>debugging</u>(bool <i>value</i>);
</big></dt>
<dd>Enable / disable memory management <u>debugging</u> for this Path
 instance. Only available if both cairoD and the cairoD user
 code were compiled with "debug=RefCounted"
<br><br>
Output is written to stdout, see
 <a href="https://github.com/jpf91/cairoD/wiki/Memory-Management#debugging">https://github.com/jpf91/cairoD/wiki/Memory-Management#debugging</a>
 for more information<br><br>

</dd>
<dt><big><a name="Path.opSlice"></a>PathRange <u>opSlice</u>();
</big></dt>
<dd>Get a  for this path to iterate the paths
 elements.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>import</font> std.math, std.stdio, std.array;
<font color=green>//Let's create a context first and draw some lines
</font><font color=blue>auto</font> surf = <font color=blue>new</font> ImageSurface(Format.CAIRO_FORMAT_ARGB32, 100, 100);
<font color=blue>auto</font> ctx = Context(surf);
ctx.moveTo(0.0, 0.0);
ctx.lineTo(10.0, 10.0);
surf.writeToPNG(<font color=red>"test2.png"</font>);

<font color=blue>auto</font> path = ctx.copyPath();
<font color=blue>foreach</font>(element; path[])
{
    <font color=blue>switch</font>(element.type)
    {
        <font color=blue>case</font> PathElementType.CAIRO_PATH_MOVE_TO:
            <font color=blue>auto</font> destination = element[0];
            writefln(<font color=red>"Move to %s:%s"</font>, destination.x, destination.y);
            <font color=blue>break</font>;
        <font color=blue>default</font>:
    }
}
</pre>
<br><br>
</dd>
</dl>
</dd>
<dt><big><a name="PathRange"></a>struct <u>PathRange</u>;
</big></dt>
<dd>ForwardRange to iterate a cairo path.
 This range keeps a reference to its  object,
 so it can be passed around without thinking about memory management.<br><br>

<dl><dt><big><a name="PathRange.this"></a>this(Path <i>path</i>);
</big></dt>
<dd>Constructor to get a PathRange for a  object.
 You should usually use 's opSlice method insted, see
 the  documentation for an example.<br><br>

</dd>
<dt><big><a name="PathRange.save"></a>@property PathRange <u>save</u>();
<br><a name="PathRange.empty"></a>@property bool <u>empty</u>();
<br><a name="PathRange.popFront"></a>void <u>popFront</u>();
<br><a name="PathRange.front"></a>@property PathElement <u>front</u>();
</big></dt>
<dd>ForwardRange implementation<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="PathElement"></a>struct <u>PathElement</u>;
</big></dt>
<dd>An element of a cairo  and the objects iterated by a
 .<br><br>

<dl><dt><big><a name="PathElement.type"></a>const @property PathElementType <u>type</u>();
</big></dt>
<dd>The <u>type</u> of this element.<br><br>

</dd>
<dt><big><a name="PathElement.getPoint"></a>const Point!double <u>getPoint</u>(int <i>index</i>);
</big></dt>
<dd> Get a point from this element.
 Index is zero-based. The number of available points
 depends on the elements :
<pre class="d_code">    CAIRO_PATH_MOVE_TO:     1 point
    CAIRO_PATH_LINE_TO:     1 point
    CAIRO_PATH_CURVE_TO:    3 points
    CAIRO_PATH_CLOSE_PATH:  0 points
</pre>
<br><br>

</dd>
<dt><big><a name="PathElement.opIndex"></a>alias <u>opIndex</u> = getPoint;
</big></dt>
<dd>Convenience operator overload.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Matrix"></a>struct <u>Matrix</u>;
</big></dt>
<dd> Wrapper for cairo's .
 A  holds an affine transformation, such as a scale,
 rotation, shear, or a combination of those. The transformation of
 a point (x, y) is given by:
<pre class="d_code">    x_new = xx * x + xy * y + x0;
    y_new = yx * x + yy * y + y0;
</pre>
<br><br>

<dl><dt><big><a name="Matrix.nativeMatrix"></a>cairo_matrix_t <u>nativeMatrix</u>;
</big></dt>
<dd>Cairo's  struct<br><br>

</dd>
<dt><big><a name="Matrix.this"></a>this(double <i>xx</i>, double <i>yx</i>, double <i>xy</i>, double <i>yy</i>, double <i>x0</i>, double <i>y0</i>);
</big></dt>
<dd> Sets matrix to be the affine transformation given by <i>xx</i>, <i>yx</i>, <i>xy</i>, <i>yy</i>, <i>x0</i>, <i>y0</i>.
 The transformation is given by:
<pre class="d_code"> x_new = <i>xx</i> * x + <i>xy</i> * y + <i>x0</i>;
 y_new = <i>yx</i> * x + <i>yy</i> * y + <i>y0</i>;
</pre>
<br><br>
<b>Params:</b><br>
<table><tr><td>double <i>xx</i></td>
<td><i>xx</i> component of the affine transformation</td></tr>
<tr><td>double <i>yx</i></td>
<td><i>yx</i> component of the affine transformation</td></tr>
<tr><td>double <i>xy</i></td>
<td><i>xy</i> component of the affine transformation</td></tr>
<tr><td>double <i>yy</i></td>
<td><i>yy</i> component of the affine transformation</td></tr>
<tr><td>double <i>x0</i></td>
<td>X translation component of the affine transformation</td></tr>
<tr><td>double <i>y0</i></td>
<td>Y translation component of the affine transformation</td></tr>
</table><br>

</dd>
<dt><big><a name="Matrix.initIdentity"></a>void <u>initIdentity</u>();
</big></dt>
<dd>Modifies matrix to be an identity transformation.<br><br>

</dd>
<dt><big><a name="Matrix.initTranslate"></a>void <u>initTranslate</u>(double <i>tx</i>, double <i>ty</i>);
</big></dt>
<dd>Initializes matrix to a transformation that translates by <i>tx</i>
 and <i>ty</i> in the X and Y dimensions, respectively.
<br><br>
<b>Params:</b><br>
<table><tr><td>double <i>tx</i></td>
<td>amount to translate in the X direction</td></tr>
<tr><td>double <i>ty</i></td>
<td>amount to translate in the Y direction</td></tr>
</table><br>

</dd>
<dt><big><a name="Matrix.initScale"></a>void <u>initScale</u>(double <i>sx</i>, double <i>sy</i>);
<br>void <u>initScale</u>(Point!double <i>point</i>);
</big></dt>
<dd>nitializes matrix to a transformation that scales by <i>sx</i> and <i>sy</i>
 in the X and Y dimensions, respectively.
<br><br>
<b>Params:</b><br>
<table><tr><td>double <i>sx</i></td>
<td>scale factor in the X direction</td></tr>
<tr><td>double <i>sy</i></td>
<td>scale factor in the Y direction</td></tr>
</table><br>

</dd>
<dt><big><a name="Matrix.initRotate"></a>void <u>initRotate</u>(double <i>radians</i>);
</big></dt>
<dd>Initialized matrix to a transformation that rotates by <i>radians</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>double <i>radians</i></td>
<td>angle of rotation, in <i>radians</i>. The direction of
     rotation is defined such that positive angles rotate in
     the direction from the positive X axis toward the positive
     Y axis. With the default axis orientation of cairo,
     positive angles rotate in a clockwise direction</td></tr>
</table><br>

</dd>
<dt><big><a name="Matrix.translate"></a>void <u>translate</u>(double <i>tx</i>, double <i>ty</i>);
</big></dt>
<dd>Applies a translation by <i>tx</i>, <i>ty</i> to the transformation in matrix.
 The effect of the new transformation is to first <u>translate</u> the
 coordinates by <i>tx</i> and <i>ty</i>, then apply the original transformation
 to the coordinates.
<br><br>
<b>Params:</b><br>
<table><tr><td>double <i>tx</i></td>
<td>amount to <u>translate</u> in the X direction</td></tr>
<tr><td>double <i>ty</i></td>
<td>amount to <u>translate</u> in the Y direction</td></tr>
</table><br>

</dd>
<dt><big><a name="Matrix.scale"></a>void <u>scale</u>(double <i>sx</i>, double <i>sy</i>);
<br>void <u>scale</u>(Point!double <i>point</i>);
</big></dt>
<dd>Applies scaling by <i>sx</i>, <i>sy</i> to the transformation in matrix.
 The effect of the new transformation is to first <u>scale</u> the
 coordinates by <i>sx</i> and <i>sy</i>, then apply the original transformation
 to the coordinates.
<br><br>
<b>Params:</b><br>
<table><tr><td>double <i>sx</i></td>
<td><u>scale</u> factor in the X direction</td></tr>
<tr><td>double <i>sy</i></td>
<td><u>scale</u> factor in the Y direction</td></tr>
</table><br>

</dd>
<dt><big><a name="Matrix.rotate"></a>void <u>rotate</u>(double <i>radians</i>);
</big></dt>
<dd>Applies rotation by <i>radians</i> to the transformation in matrix.
 The effect of the new transformation is to first <u>rotate</u> the
 coordinates by <i>radians</i>, then apply the original transformation
 to the coordinates.
<br><br>
<b>Params:</b><br>
<table><tr><td>double <i>radians</i></td>
<td>angle of rotation, in <i>radians</i>. The direction of
 rotation is defined such that positive angles <u>rotate</u> in the
 direction from the positive X axis toward the positive Y axis.
 With the default axis orientation of cairo, positive angles
 <u>rotate</u> in a clockwise direction.</td></tr>
</table><br>

</dd>
<dt><big><a name="Matrix.invert"></a>void <u>invert</u>();
</big></dt>
<dd>Changes matrix to be the inverse of its original value.
 Not all transformation matrices have inverses; if the matrix
 collapses points together (it is degenerate), then it has no
 inverse and this function will fail.
<br><br>
<b>Throws:</b><br>
If matrix has an inverse, modifies matrix to be the inverse matrix.
 Otherwise, throws a cairo exception
 with CAIRO_STATUS_INVALID_MATRIX type.<br><br>

</dd>
<dt><big><a name="Matrix.opBinary"></a>Matrix <u>opBinary</u>(string op)(Matrix <i>rhs</i>) if (op == "*");
</big></dt>
<dd>Multiplies the affine transformations in a and b together and
 returns the result. The effect of the resulting transformation
 is to first apply the transformation in a to the coordinates
 and then apply the transformation in b to the coordinates.
<br><br>
It is allowable for result to be identical to either a or b.<br><br>

</dd>
<dt><big><a name="Matrix.transformDistance"></a>Point!double <u>transformDistance</u>(Point!double <i>dist</i>);
</big></dt>
<dd> Transforms the distance vector (dx,dy) by matrix. This is similar
 to  except that the translation
 components of the transformation are ignored. The calculation
 of the returned vector is as follows:
<pre class="d_code">dx2 = dx1 * a + dy1 * c;
dy2 = dx1 * b + dy1 * d;
</pre>
<br><br>

</dd>
<dt><big><a name="Matrix.transformPoint"></a>Point!double <u>transformPoint</u>(Point!double <i>point</i>);
</big></dt>
<dd>Transforms the <i>point</i> (x, y) by matrix.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Pattern"></a>class <u>Pattern</u>;
</big></dt>
<dd>A  represents a source when drawing onto a
 . There are different subtypes of ,
 for different types of sources; for example,
  creates a pattern for a solid
 opaque color.
<br><br>
Other than various  subclasses,
 some of the pattern types can be implicitly created
 using various  functions;
 for example .
<br><br>

 The C type of a pattern can be queried with ,
 although D polymorphism features also work.
<br><br>

 Memory management of  can be done with the 
 method, see <a href="https://github.com/jpf91/cairoD/wiki/Memory-Management#3-RC-class">https://github.com/jpf91/cairoD/wiki/Memory-Management#3-RC-class</a>

<br><br>
<b>Note:</b><br>
This class uses the  mixin, so all it's members
 are also available in  classes, although they do not show
 up in the documentation because of a limitation in ddoc.<br><br>

<dl><dt><big><a name="Pattern._count"></a>@property uint <u>_count</u>();
</big></dt>
<dd>Reference count. For use in child classes<br><br>

</dd>
<dt><big><a name="Pattern._reference"></a>void <u>_reference</u>();
</big></dt>
<dd>Increase reference count. For use in child classes<br><br>

</dd>
<dt><big><a name="Pattern._dereference"></a>void <u>_dereference</u>();
</big></dt>
<dd>Decrease reference count. For use in child classes<br><br>

</dd>
<dt><big><a name="Pattern.nativePointer"></a>T <u>nativePointer</u>;
</big></dt>
<dd>The underlying  handle<br><br>

</dd>
<dt><big><a name="Pattern.debugging"></a>bool <u>debugging</u>;
</big></dt>
<dd>Enable / disable memory management <u>debugging</u> for this
 instance. Only available if both cairoD and the cairoD user
 code were compiled with "debug=RefCounted"
<br><br>
Output is written to stdout, see
 <a href="https://github.com/jpf91/cairoD/wiki/Memory-Management#debugging">https://github.com/jpf91/cairoD/wiki/Memory-Management#debugging</a>
 for more information<br><br>

</dd>
<dt><big><a name="Pattern.dispose"></a>void <u>dispose</u>();
</big></dt>
<dd>Explicitly drecrease the reference count.
<br><br>
See <a href="https://github.com/jpf91/cairoD/wiki/Memory-Management#3-RC-class">https://github.com/jpf91/cairoD/wiki/Memory-Management#3-RC-class</a>
 for more information.<br><br>

</dd>
<dt><big><a name="Pattern.checkError"></a>protected final void <u>checkError</u>();
</big></dt>
<dd>Method for use in subclasses.
 Calls  and throws
 an exception if the status isn't CAIRO_STATUS_SUCCESS<br><br>

</dd>
<dt><big><a name="Pattern.this"></a>this(cairo_pattern_t* <i>ptr</i>);
</big></dt>
<dd>Create a  from a existing .
 Pattern is a garbage collected class. It will call 
 when it gets collected by the GC or when  is called.
<br><br>
<b>Warning:</b><br>
's reference count is not increased by this function!
 Adjust reference count before calling it if necessary
<br><br>

 <font color=red>Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</font><br><br>

</dd>
<dt><big><a name="Pattern.createFromNative"></a>static Pattern <u>createFromNative</u>(cairo_pattern_t* <i>ptr</i>, bool <i>adjRefCount</i> = true);
</big></dt>
<dd>The <u>createFromNative</u> method for the Pattern classes.
 See <a href="https://github.com/jpf91/cairoD/wiki/Memory-Management#createFromNative">https://github.com/jpf91/cairoD/wiki/Memory-Management#createFromNative</a>
 for more information.
<br><br>
<b>Warning:</b><br>
<font color=red>Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</font><br><br>

</dd>
<dt><big><a name="Pattern.setExtend"></a>void <u>setExtend</u>(Extend <i>ext</i>);
</big></dt>
<dd>Sets the mode to be used for drawing outside the area of a pattern.
 See  for details on the semantics of each extend strategy.
 The default extend mode is CAIRO_EXTEND_NONE for surface patterns
 and CAIRO_EXTEND_PAD for gradient patterns.<br><br>

</dd>
<dt><big><a name="Pattern.getExtend"></a>Extend <u>getExtend</u>();
</big></dt>
<dd>Gets the current extend mode for a pattern. See 
 for details on the semantics of each extend strategy.<br><br>

</dd>
<dt><big><a name="Pattern.setFilter"></a>void <u>setFilter</u>(Filter <i>fil</i>);
</big></dt>
<dd>Sets the filter to be used for resizing when using this pattern.
 See  for details on each filter.
<br><br>
<b>Note:</b><br>
 You might want to control filtering even when you do not have
 an explicit cairo_pattern_t object, (for example when using
 ). In these cases, it is convenient
 to use  to get access to the pattern
 that cairo creates implicitly.
 For example:
<pre class="d_code">context.setSourceSurface(image, x, y);
context.getSource().<u>setFilter</u>(Filter.CAIRO_FILTER_NEAREST);
</pre>
<br><br>

</dd>
<dt><big><a name="Pattern.getFilter"></a>Filter <u>getFilter</u>();
</big></dt>
<dd>Gets the current filter for a pattern. See  for details on each filter.<br><br>

</dd>
<dt><big><a name="Pattern.filter"></a>void <u>filter</u>(Filter <i>fil</i>);
<br>Filter <u>filter</u>();
</big></dt>
<dd>Convenience property<br><br>

</dd>
<dt><big><a name="Pattern.setMatrix"></a>void <u>setMatrix</u>(Matrix <i>mat</i>);
</big></dt>
<dd>Sets the pattern's transformation matrix to matrix.
 This matrix is a transformation from user space to pattern space.
<br><br>
When a pattern is first created it always has the identity matrix
 for its transformation matrix, which means that pattern space
 is initially identical to user space.
<br><br>
<b>Important:</b><br>
 Please note that the direction of this transformation
 matrix is from user space to pattern space. This means that if
 you imagine the flow from a pattern to user space (and on to
 device space), then coordinates in that flow will be transformed
 by the inverse of the pattern matrix.
<br><br>

 For example, if you want to make a pattern appear twice as large
 as it does by default the correct code to use is:
<pre class="d_code">Matrix matrix;
matrix.initScale(0.5, 0.5);
pattern.<u>setMatrix</u>(matrix);
</pre>
 Meanwhile, using values of 2.0 rather than 0.5 in the code above
 would cause the pattern to appear at half of its default size.
<br><br>

 Also, please note the discussion of the user-space locking semantics
 of .<br><br>

</dd>
<dt><big><a name="Pattern.getMatrix"></a>Matrix <u>getMatrix</u>();
</big></dt>
<dd>Returns the pattern's transformation matrix.<br><br>

</dd>
<dt><big><a name="Pattern.matrix"></a>@property void <u>matrix</u>(Matrix <i>mat</i>);
<br>@property Matrix <u>matrix</u>();
</big></dt>
<dd>Convenience property<br><br>

</dd>
<dt><big><a name="Pattern.getType"></a>PatternType <u>getType</u>();
</big></dt>
<dd>This function returns the C type of a pattern. See 
 for available types.<br><br>

</dd>
<dt><big><a name="Pattern.type"></a>@property PatternType <u>type</u>();
</big></dt>
<dd>Convenience property<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="SolidPattern"></a>class <u>SolidPattern</u>: <u>cairo.cairo.Pattern</u>;
</big></dt>
<dd>A solid pattern.
<br><br>
Use the  and  methods to create an
 instance.<br><br>

<dl><dt><big><a name="SolidPattern.this"></a>this(cairo_pattern_t* <i>ptr</i>);
</big></dt>
<dd>Create a  from a existing .
 SolidPattern is a garbage collected class. It will call 
 when it gets collected by the GC or when  is called.
<br><br>
<b>Warning:</b><br>
's reference count is not increased by this function!
 Adjust reference count before calling it if necessary
<br><br>

 <font color=red>Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</font><br><br>

</dd>
<dt><big><a name="SolidPattern.fromRGB"></a>static SolidPattern <u>fromRGB</u>(double <i>red</i>, double <i>green</i>, double <i>blue</i>);
<br>static SolidPattern <u>fromRGB</u>(RGB <i>rgb</i>);
</big></dt>
<dd>Creates a new  corresponding to an opaque color.
 The color components are floating point numbers in the range 0
 to 1. If the values passed in are outside that range, they will
 be clamped.<br><br>

</dd>
<dt><big><a name="SolidPattern.fromRGBA"></a>static SolidPattern <u>fromRGBA</u>(double <i>red</i>, double <i>green</i>, double <i>blue</i>, double <i>alpha</i>);
<br>static SolidPattern <u>fromRGBA</u>(RGBA <i>rgba</i>);
</big></dt>
<dd>Creates a new  corresponding to a translucent color.
 The color components are floating point numbers in the range 0 to 1.
 If the values passed in are outside that range, they will be clamped.<br><br>

</dd>
<dt><big><a name="SolidPattern.getRGBA"></a>RGBA <u>getRGBA</u>();
</big></dt>
<dd>Gets the solid color for a solid color pattern.<br><br>

</dd>
<dt><big><a name="SolidPattern.rgba"></a>@property RGBA <u>rgba</u>();
</big></dt>
<dd>Convenience property (todo: dubious due to lowercase requirement)<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="SurfacePattern"></a>class <u>SurfacePattern</u>: <u>cairo.cairo.Pattern</u>;
</big></dt>
<dd>A surface pattern.
<br><br>
Use the  constructor to create an
 instance.<br><br>

<dl><dt><big><a name="SurfacePattern.this"></a>this(cairo_pattern_t* <i>ptr</i>);
</big></dt>
<dd>Create a  from a existing .
 SurfacePattern is a garbage collected class. It will call 
 when it gets collected by the GC or when  is called.
<br><br>
<b>Warning:</b><br>
's reference count is not increased by this function!
 Adjust reference count before calling it if necessary
<br><br>

 <font color=red>Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</font><br><br>

</dd>
<dt><big><a name="SurfacePattern.this.2"></a>this(Surface <i>surface</i>);
</big></dt>
<dd>Create a new  for the given <i>surface</i>.<br><br>

</dd>
<dt><big><a name="SurfacePattern.getSurface"></a>Surface <u>getSurface</u>();
</big></dt>
<dd>Gets the  of a SurfacePattern.<br><br>

</dd>
<dt><big><a name="SurfacePattern.surface"></a>@property Surface <u>surface</u>();
</big></dt>
<dd>Convenience property<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Gradient"></a>class <u>Gradient</u>: <u>cairo.cairo.Pattern</u>;
</big></dt>
<dd>Base class for  and .
<br><br>
It's not possible to create instances of this class.<br><br>

<dl><dt><big><a name="Gradient.this"></a>this(cairo_pattern_t* <i>ptr</i>);
</big></dt>
<dd>Create a  from a existing .
 Gradient is a garbage collected class. It will call 
 when it gets collected by the GC or when  is called.
<br><br>
<b>Warning:</b><br>
's reference count is not increased by this function!
 Adjust reference count before calling it if necessary
<br><br>

 <font color=red>Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</font><br><br>

</dd>
<dt><big><a name="Gradient.addColorStopRGB"></a>void <u>addColorStopRGB</u>(double <i>offset</i>, RGB <i>color</i>);
<br>void <u>addColorStopRGB</u>(double <i>offset</i>, double <i>red</i>, double <i>green</i>, double <i>blue</i>);
</big></dt>
<dd>Adds an opaque <i>color</i> stop to a gradient pattern. The <i>offset</i>
 specifies the location along the gradient's control vector.
 For example, a 's control vector is from
 (x0,y0) to (x1,y1) while a 's control vector is
 from any point on the start circle to the corresponding point
 on the end circle.
<br><br>
The <i>color</i> is specified in the same way as in .
<br><br>

 If two (or more) stops are specified with identical <i>offset</i>
 values, they will be sorted according to the order in which the
 stops are added, (stops added earlier will compare less than
 stops added later). This can be useful for reliably making sharp
 <i>color</i> transitions instead of the typical blend.

<br><br>
<b>Params:</b><br>
<table><tr><td>double <i>offset</i></td>
<td>an <i>offset</i> in the range [0.0 .. 1.0]</td></tr>
</table><br>
<b>Note:</b><br>
If the pattern is not a gradient pattern, (eg. a linear
 or radial pattern), then the pattern will be put into an error
 status with a status of CAIRO_STATUS_PATTERN_TYPE_MISMATCH.<br><br>

</dd>
<dt><big><a name="Gradient.addColorStopRGBA"></a>void <u>addColorStopRGBA</u>(double <i>offset</i>, RGBA <i>color</i>);
<br>void <u>addColorStopRGBA</u>(double <i>offset</i>, double <i>red</i>, double <i>green</i>, double <i>blue</i>, double <i>alpha</i>);
</big></dt>
<dd>Adds a translucent <i>color</i> stop to a gradient pattern. The <i>offset</i>
 specifies the location along the gradient's control vector. For
 example, a linear gradient's control vector is from (x0,y0) to
 (x1,y1) while a radial gradient's control vector is from any point
 on the start circle to the corresponding point on the end circle.
<br><br>
The <i>color</i> is specified in the same way as in
 .
<br><br>

 If two (or more) stops are specified with identical <i>offset</i> values,
 they will be sorted according to the order in which the stops are added,
 (stops added earlier will compare less than stops added later).
 This can be useful for reliably making sharp <i>color</i> transitions
 instead of the typical blend.

<br><br>
<b>Params:</b><br>
<table><tr><td>double <i>offset</i></td>
<td>an <i>offset</i> in the range [0.0 .. 1.0]</td></tr>
</table><br>
<b>Note:</b><br>
If the pattern is not a gradient pattern, (eg. a linear
 or radial pattern), then the pattern will be put into an error
 status with a status of CAIRO_STATUS_PATTERN_TYPE_MISMATCH.<br><br>

</dd>
<dt><big><a name="Gradient.getColorStopCount"></a>int <u>getColorStopCount</u>();
</big></dt>
<dd>Gets the number of color stops specified in the given gradient pattern.<br><br>

</dd>
<dt><big><a name="Gradient.colorStopCount"></a>alias <u>colorStopCount</u> = getColorStopCount;
</big></dt>
<dd>Convenience alias<br><br>

</dd>
<dt><big><a name="Gradient.getColorStopRGBA"></a>void <u>getColorStopRGBA</u>(int <i>index</i>, out double <i>offset</i>, out RGBA <i>color</i>);
</big></dt>
<dd>Gets the <i>color</i> and <i>offset</i> information at the given <i>index</i> for a
 gradient pattern. Values of <i>index</i> are 0 to 1 less than the number
 returned by .
<br><br>
<b>Params:</b><br>
<table><tr><td>int <i>index</i></td>
<td><i>index</i> of the stop to return data for</td></tr>
<tr><td>double <i>offset</i></td>
<td>output: Returns the <i>offset</i> of the <i>color</i> stop</td></tr>
<tr><td>RGBA <i>color</i></td>
<td>output: Returns the <i>color</i> of the <i>color</i> stop</td></tr>
</table><br>
<b>TODO:</b><br>
Array/Range - like interface?<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="LinearGradient"></a>class <u>LinearGradient</u>: <u>cairo.cairo.Gradient</u>;
</big></dt>
<dd>A linear gradient.
<br><br>
Use the  constructor to create an
 instance.<br><br>

<dl><dt><big><a name="LinearGradient.this"></a>this(cairo_pattern_t* <i>ptr</i>);
</big></dt>
<dd>Create a  from a existing .
 LinearGradient is a garbage collected class. It will call 
 when it gets collected by the GC or when  is called.
<br><br>
<b>Warning:</b><br>
's reference count is not increased by this function!
 Adjust reference count before calling it if necessary
<br><br>

 <font color=red>Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</font><br><br>

</dd>
<dt><big><a name="LinearGradient.this.2"></a>this(Point!double <i>p1</i>, Point!double <i>p2</i>);
<br>this(double <i>x1</i>, double <i>y1</i>, double <i>x2</i>, double <i>y2</i>);
</big></dt>
<dd>Create a new linear gradient  along the line defined
 by <i>p1</i> and <i>p2</i>. Before using the gradient pattern, a number of
 color stops should be defined using 
 or  .
<br><br>
<b>Params:</b><br>
<table><tr><td>Point!double <i>p1</i></td>
<td>the start point</td></tr>
<tr><td>Point!double <i>p2</i></td>
<td>the end point</td></tr>
</table><br>
<b>Note:</b><br>
The coordinates here are in pattern space. For a new pattern,
 pattern space is identical to user space, but the relationship
 between the spaces can be changed with .<br><br>

</dd>
<dt><big><a name="LinearGradient.getLinearPoints"></a>Point!double[2] <u>getLinearPoints</u>();
</big></dt>
<dd>Gets the gradient endpoints for a linear gradient.
<br><br>
<b>Returns:</b><br>
Point[0] = the first point
<br><br>

 Point[1] = the second point<br><br>

</dd>
<dt><big><a name="LinearGradient.linearPoints"></a>alias <u>linearPoints</u> = getLinearPoints;
</big></dt>
<dd>Convenience alias<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="RadialGradient"></a>class <u>RadialGradient</u>: <u>cairo.cairo.Gradient</u>;
</big></dt>
<dd>A radial gradient.
<br><br>
Use the 
 constructor to create an instance.<br><br>

<dl><dt><big><a name="RadialGradient.this"></a>this(cairo_pattern_t* <i>ptr</i>);
</big></dt>
<dd>Create a  from a existing .
 RadialGradient is a garbage collected class. It will call 
 when it gets collected by the GC or when  is called.
<br><br>
<b>Warning:</b><br>
's reference count is not increased by this function!
 Adjust reference count before calling it if necessary
<br><br>

 <font color=red>Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</font><br><br>

</dd>
<dt><big><a name="RadialGradient.this.2"></a>this(Point!double <i>c0</i>, double <i>radius0</i>, Point!double <i>c1</i>, double <i>radius1</i>);
<br>this(double <i>c0x</i>, double <i>c0y</i>, double <i>radius0</i>, double <i>c1x</i>, double <i>c1y</i>, double <i>radius1</i>);
</big></dt>
<dd>Creates a new radial gradient  between the two
 circles defined by (<i>c0</i>, <i>radius0</i>) and (<i>c1</i>, <i>radius1</i>). Before
 using the gradient pattern, a number of color stops should
 be defined using  or
 .
<br><br>
<b>Params:</b><br>
<table><tr><td>Point!double <i>c0</i></td>
<td>center of the start circle</td></tr>
<tr><td>double <i>radius0</i></td>
<td>radius of the start circle</td></tr>
<tr><td>Point!double <i>c1</i></td>
<td>center of the end circle</td></tr>
<tr><td>double <i>radius1</i></td>
<td>radius of the end circle</td></tr>
</table><br>
<b>Note:</b><br>
The coordinates here are in pattern space. For a new pattern,
 pattern space is identical to user space, but the relationship
 between the spaces can be changed with .<br><br>

</dd>
<dt><big><a name="RadialGradient.getRadialCircles"></a>void <u>getRadialCircles</u>(out Point!double <i>c0</i>, out Point!double <i>c1</i>, out double <i>radius0</i>, out double <i>radius1</i>);
</big></dt>
<dd>Gets the gradient endpoint circles for a radial gradient,
 each specified as a center coordinate and a radius.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Device"></a>class <u>Device</u>;
</big></dt>
<dd>Devices are the abstraction Cairo employs for the rendering system used
 by a . You can get the device of a surface using
 .
<br><br>
Devices are created using custom functions specific to the rendering
 system you want to use. See the documentation for the surface types
 for those functions.
<br><br>

 An important function that devices fulfill is sharing access to the
 rendering system between Cairo and your application. If you want to access
 a device directly that you used to draw to with Cairo, you must first
 call  to ensure that Cairo finishes all operations
 on the device and resets it to a clean state.
<br><br>

 Cairo also provides the functions  and
  to synchronize access to the rendering system
 in a multithreaded environment. This is done internally, but can also
 be used by applications.

<br><br>
<b>Note:</b><br>
Please refer to the documentation of each backend for additional usage
 requirements, guarantees provided, and interactions with existing surface
 API of the device functions for surfaces of that type.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>void</font> my_device_modifying_function(<u>Device</u> device)
{
    <font color=green>// Ensure the device is properly reset
</font>    device.flush();
    <font color=blue>try</font>
    {
        <font color=green>// Try to acquire the device
</font>        device.acquire();
    }
    <font color=blue>catch</font>(CairoException e)
    {
        writeln(<font color=red>""</font>);
    }

    <font color=green>// Release the device when done.
</font>    <font color=blue>scope</font>(exit)
        device.release();

    <font color=green>// Do the custom operations on the device here.
</font>    <font color=green>// But do not call any Cairo functions that might acquire devices.
</font>
}
</pre>
<br><br>

<dl><dt><big><a name="Device._count"></a>@property uint <u>_count</u>();
</big></dt>
<dd>Reference count. For use in child classes<br><br>

</dd>
<dt><big><a name="Device._reference"></a>void <u>_reference</u>();
</big></dt>
<dd>Increase reference count. For use in child classes<br><br>

</dd>
<dt><big><a name="Device._dereference"></a>void <u>_dereference</u>();
</big></dt>
<dd>Decrease reference count. For use in child classes<br><br>

</dd>
<dt><big><a name="Device.nativePointer"></a>T <u>nativePointer</u>;
</big></dt>
<dd>The underlying  handle<br><br>

</dd>
<dt><big><a name="Device.debugging"></a>bool <u>debugging</u>;
</big></dt>
<dd>Enable / disable memory management <u>debugging</u> for this
 instance. Only available if both cairoD and the cairoD user
 code were compiled with "debug=RefCounted"
<br><br>
Output is written to stdout, see
 <a href="https://github.com/jpf91/cairoD/wiki/Memory-Management#debugging">https://github.com/jpf91/cairoD/wiki/Memory-Management#debugging</a>
 for more information<br><br>

</dd>
<dt><big><a name="Device.dispose"></a>void <u>dispose</u>();
</big></dt>
<dd>Explicitly drecrease the reference count.
<br><br>
See <a href="https://github.com/jpf91/cairoD/wiki/Memory-Management#3-RC-class">https://github.com/jpf91/cairoD/wiki/Memory-Management#3-RC-class</a>
 for more information.<br><br>

</dd>
<dt><big><a name="Device.checkError"></a>protected final void <u>checkError</u>();
</big></dt>
<dd>Method for use in subclasses.
 Calls  and throws
 an exception if the status isn't CAIRO_STATUS_SUCCESS<br><br>

</dd>
<dt><big><a name="Device.this"></a>this(cairo_device_t* <i>ptr</i>);
</big></dt>
<dd>Create a  from a existing .
 Device is a garbage collected class. It will call 
 when it gets collected by the GC or when  is called.
<br><br>
<b>Warning:</b><br>
's reference count is not increased by this function!
 Adjust reference count before calling it if necessary
<br><br>

 <font color=red>Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</font><br><br>

</dd>
<dt><big><a name="Device.finish"></a>void <u>finish</u>();
</big></dt>
<dd>This function finishes the device and drops all references to
 external resources. All surfaces, fonts and other objects created
 for this device will be finished, too. Further operations on
 the device will not affect the device but will instead trigger
 a CAIRO_STATUS_DEVICE_FINISHED exception.
<br><br>
When the reference count reaches zero, cairo will call 
 if it hasn't been called already, before freeing the resources
 associated with the device.
<br><br>

 This function may acquire devices.

<br><br>
<font color=red>BUGS:</font><br>
How does "All surfaces, fonts and other objects created
 for this device will be finished" interact with the cairoD?<br><br>

</dd>
<dt><big><a name="Device.flush"></a>void <u>flush</u>();
</big></dt>
<dd>Finish any pending operations for the device and also restore
 any temporary modifications cairo has made to the device's state.
 This function must be called before switching from using the
 device with Cairo to operating on it directly with native APIs.
 If the device doesn't support direct access, then this function does nothing.
<br><br>
This function may acquire devices.<br><br>

</dd>
<dt><big><a name="Device.getType"></a>DeviceType <u>getType</u>();
</big></dt>
<dd>This function returns the C type of a Device. See 
 for available types.<br><br>

</dd>
<dt><big><a name="Device.type"></a>alias <u>type</u> = getType;
</big></dt>
<dd>Convenience alias<br><br>

</dd>
<dt><big><a name="Device.acquire"></a>void <u>acquire</u>();
</big></dt>
<dd>Acquires the device for the current thread. This function will
 block until no other thread has acquired the device.
<br><br>
If no Exception is thrown, you successfully
 acquired the device. From now on your thread owns the device
 and no other thread will be able to <u>acquire</u> it until a matching
 call to . It is allowed to recursively
 <u>acquire</u> the device multiple times from the same thread.

<br><br>
<b>Note:</b><br>
You must never <u>acquire</u> two different devices at the same time
 unless this is explicitly allowed. Otherwise the possibility
 of deadlocks exist.
<br><br>

 As various Cairo functions can <u>acquire</u> devices when called,
 these functions may also cause deadlocks when you call them
 with an acquired device. So you must not have a device acquired
 when calling them. These functions are marked in the documentation.

<br><br>
<b>Throws:</b><br>
An exception if the device is in an error state and could not
 be acquired. After a successful call to <u>acquire</u>, a matching call
 to  is required.<br><br>

</dd>
<dt><big><a name="Device.release"></a>void <u>release</u>();
</big></dt>
<dd>Releases a device previously acquired using .
 See that function for details.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Surface"></a>class <u>Surface</u>;
</big></dt>
<dd><u>Surface</u> is the abstract type representing all different drawing targets
 that cairo can render to. The actual drawings are performed using a cairo context.
<br><br>
A cairo surface is created by using backend-specific classes,
 typically of the form .
<br><br>

 Most surface types allow accessing the surface without using Cairo
 functions. If you do this, keep in mind that it is mandatory that
 you call  before reading from or writing to the
 surface and that you must use  after modifying it.<br><br>

<dl><dt><big><a name="Surface._count"></a>@property uint <u>_count</u>();
</big></dt>
<dd>Reference count. For use in child classes<br><br>

</dd>
<dt><big><a name="Surface._reference"></a>void <u>_reference</u>();
</big></dt>
<dd>Increase reference count. For use in child classes<br><br>

</dd>
<dt><big><a name="Surface._dereference"></a>void <u>_dereference</u>();
</big></dt>
<dd>Decrease reference count. For use in child classes<br><br>

</dd>
<dt><big><a name="Surface.nativePointer"></a>T <u>nativePointer</u>;
</big></dt>
<dd>The underlying  handle<br><br>

</dd>
<dt><big><a name="Surface.debugging"></a>bool <u>debugging</u>;
</big></dt>
<dd>Enable / disable memory management <u>debugging</u> for this
 instance. Only available if both cairoD and the cairoD user
 code were compiled with "debug=RefCounted"
<br><br>
Output is written to stdout, see
 <a href="https://github.com/jpf91/cairoD/wiki/Memory-Management#debugging">https://github.com/jpf91/cairoD/wiki/Memory-Management#debugging</a>
 for more information<br><br>

</dd>
<dt><big><a name="Surface.dispose"></a>void <u>dispose</u>();
</big></dt>
<dd>Explicitly drecrease the reference count.
<br><br>
See <a href="https://github.com/jpf91/cairoD/wiki/Memory-Management#3-RC-class">https://github.com/jpf91/cairoD/wiki/Memory-Management#3-RC-class</a>
 for more information.<br><br>

</dd>
<dt><big><a name="Surface.checkError"></a>protected final void <u>checkError</u>();
</big></dt>
<dd>Method for use in subclasses.
 Calls  and throws
 an exception if the status isn't CAIRO_STATUS_SUCCESS<br><br>

</dd>
<dt><big><a name="Surface.this"></a>this(cairo_surface_t* <i>ptr</i>);
</big></dt>
<dd>Create a  from a existing .
 Surface is a garbage collected class. It will call 
 when it gets collected by the GC or when  is called.
<br><br>
<b>Warning:</b><br>
's reference count is not increased by this function!
 Adjust reference count before calling it if necessary
<br><br>

 <font color=red>Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</font><br><br>

</dd>
<dt><big><a name="Surface.createFromNative"></a>static Surface <u>createFromNative</u>(cairo_surface_t* <i>ptr</i>, bool <i>adjRefCount</i> = true);
</big></dt>
<dd>The <u>createFromNative</u> method for the Surface classes.
 See <a href="https://github.com/jpf91/cairoD/wiki/Memory-Management#createFromNative">https://github.com/jpf91/cairoD/wiki/Memory-Management#createFromNative</a>
 for more information.
<br><br>
<b>Warning:</b><br>
<font color=red>Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</font><br><br>

</dd>
<dt><big><a name="Surface.createSimilar"></a>static Surface <u>createSimilar</u>(Surface <i>other</i>, Content <i>content</i>, int <i>width</i>, int <i>height</i>);
</big></dt>
<dd>Create a new surface that is as compatible as possible with
 an existing surface. For example the new surface will have the
 same fallback resolution and font options as <i>other</i>. Generally,
 the new surface will also use the same backend as <i>other</i>, unless
 that is not possible for some reason. The type of the returned
 surface may be examined with .
<br><br>
Initially the surface contents are all 0 (transparent if
 contents have transparency, black otherwise.)

<br><br>
<b>Params:</b><br>
<table><tr><td>Surface <i>other</i></td>
<td>an existing surface used to select the backend of the new surface</td></tr>
<tr><td>Content <i>content</i></td>
<td>the <i>content</i> for the new surface</td></tr>
<tr><td>int <i>width</i></td>
<td><i>width</i> of the new surface, (in device-space units)</td></tr>
<tr><td>int <i>height</i></td>
<td><i>height</i> of the new surface (in device-space units)</td></tr>
</table><br>

</dd>
<dt><big><a name="Surface.createForRectangle"></a>static Surface <u>createForRectangle</u>(Surface <i>target</i>, Rectangle!double <i>rect</i>);
</big></dt>
<dd>Create a new surface that is a rectangle within the <i>target</i> surface.
 All operations drawn to this surface are then clipped and translated
 onto the <i>target</i> surface. Nothing drawn via this sub-surface
 outside of its bounds is drawn onto the <i>target</i> surface,
 making this a useful method for passing constrained child
 surfaces to library routines that draw directly onto the parent
 surface, i.e. with no further backend allocations, double
 buffering or copies.
<br><br>
<b>Note:</b><br>
The semantics of subsurfaces have not been finalized yet unless
 the rectangle is in full device units, is contained within
 the extents of the <i>target</i> surface, and the <i>target</i> or
 subsurface's device transforms are not changed.

<br><br>
<b>Params:</b><br>
<table><tr><td>Surface <i>target</i></td>
<td>an existing surface for which the sub-surface will point to</td></tr>
<tr><td>Rectangle!double <i>rect</i></td>
<td>location of the subsurface</td></tr>
</table><br>

</dd>
<dt><big><a name="Surface.finish"></a>void <u>finish</u>();
</big></dt>
<dd>This function finishes the surface and drops all references
 to external resources. For example, for the Xlib backend it
 means that cairo will no longer access the drawable, which
 can be freed. After calling  the only
 valid operations on a surface are getting and setting user,
 referencing and destroying, and flushing and finishing it.
<br><br>
Further drawing to the surface will not affect the surface
 but will instead trigger a CAIRO_STATUS_SURFACE_FINISHED exception.
<br><br>

 When the reference count id decreased to zero, cairo will call
  if it hasn't been called already, before
 freeing the resources associated with the surface.<br><br>

</dd>
<dt><big><a name="Surface.flush"></a>void <u>flush</u>();
</big></dt>
<dd>Do any pending drawing for the surface and also restore any temporary
 modifications cairo has made to the surface's state. This function
 must be called before switching from drawing on the surface
 with cairo to drawing on it directly with native APIs. If the
 surface doesn't support direct access, then this function does
 nothing.<br><br>

</dd>
<dt><big><a name="Surface.getDevice"></a>Device <u>getDevice</u>();
</big></dt>
<dd>This function returns the device for a surface. See .<br><br>

</dd>
<dt><big><a name="Surface.device"></a>alias <u>device</u> = getDevice;
</big></dt>
<dd>Convenience alias<br><br>

</dd>
<dt><big><a name="Surface.getFontOptions"></a>FontOptions <u>getFontOptions</u>();
</big></dt>
<dd>Retrieves the default font rendering options for the surface.
 This allows display surfaces to report the correct subpixel
 order for rendering on them, print surfaces to disable hinting
 of metrics and so forth. The result can then be used with
 .<br><br>

</dd>
<dt><big><a name="Surface.fontOptions"></a>alias <u>fontOptions</u> = getFontOptions;
</big></dt>
<dd>Convenience alias<br><br>

</dd>
<dt><big><a name="Surface.getContent"></a>Content <u>getContent</u>();
</big></dt>
<dd>This function returns the content type of surface which indicates
 whether the surface contains color and/or alpha information.
 See .<br><br>

</dd>
<dt><big><a name="Surface.content"></a>alias <u>content</u> = getContent;
</big></dt>
<dd>Convenience alias<br><br>

</dd>
<dt><big><a name="Surface.markDirty"></a>void <u>markDirty</u>();
</big></dt>
<dd>Tells cairo that drawing has been done to surface using means
 other than cairo, and that cairo should reread any cached areas.
 Note that you must call  before doing such drawing.<br><br>

</dd>
<dt><big><a name="Surface.markDirtyRectangle"></a>void <u>markDirtyRectangle</u>(int <i>x</i>, int <i>y</i>, int <i>width</i>, int <i>height</i>);
<br>void <u>markDirtyRectangle</u>(Rectangle!int <i>rect</i>);
</big></dt>
<dd>Like , but drawing has been done only
 to the specified rectangle, so that cairo can retain cached
 contents for other parts of the surface.
<br><br>
Any cached clip set on the surface will be reset by this function,
 to make sure that future cairo calls have the clip set that they expect.<br><br>

</dd>
<dt><big><a name="Surface.setDeviceOffset"></a>void <u>setDeviceOffset</u>(double <i>x_offset</i>, double <i>y_offset</i>);
<br>void <u>setDeviceOffset</u>(Point!double <i>offset</i>);
</big></dt>
<dd>Sets an <i>offset</i> that is added to the device coordinates determined
 by the CTM when drawing to surface. One use case for this function
 is when we want to create a  that redirects drawing
 for a portion of an onscreen surface to an offscreen surface
 in a way that is completely invisible to the user of the cairo API.
 Setting a transformation via  isn't sufficient
 to do this, since functions like  will
 expose the hidden <i>offset</i>.
<br><br>
<b>Note:</b><br>
the <i>offset</i> affects drawing to the surface as well as using the
 surface in a source pattern.

<br><br>
<b>Params:</b><br>
<table><tr><td>double <i>x_offset</i></td>
<td>the <i>offset</i> in the X direction, in device units</td></tr>
<tr><td>double <i>y_offset</i></td>
<td>the <i>offset</i> in the Y direction, in device units</td></tr>
</table><br>

</dd>
<dt><big><a name="Surface.getDeviceOffset"></a>Point!double <u>getDeviceOffset</u>();
</big></dt>
<dd>This function returns the previous device offset set
 by .
<br><br>
<b>Returns:</b><br>
Offset in device units<br><br>

</dd>
<dt><big><a name="Surface.deviceOffset"></a>@property void <u>deviceOffset</u>(Point!double <i>offset</i>);
<br>@property Point!double <u>deviceOffset</u>();
</big></dt>
<dd>Convenience property function
<br><br>
ditto<br><br>

</dd>
<dt><big><a name="Surface.setFallbackResolution"></a>void <u>setFallbackResolution</u>(Resolution <i>res</i>);
</big></dt>
<dd>Set the horizontal and vertical resolution for image fallbacks.
<br><br>
When certain operations aren't supported natively by a backend,
 cairo will fallback by rendering operations to an image and
 then overlaying that image onto the output. For backends that
 are natively vector-oriented, this function can be used to set
 the resolution used for these image fallbacks, (larger values
 will result in more detailed images, but also larger file sizes).
<br><br>

 Some examples of natively vector-oriented backends are the ps,
 pdf, and svg backends.
<br><br>

 For backends that are natively raster-oriented, image fallbacks
 are still possible, but they are always performed at the native
 device resolution. So this function has no effect on those backends.

<br><br>
<b>Note:</b><br>
The fallback resolution only takes effect at the time of
 completing a page (with  or )
 so there is currently no way to have more than one fallback
 resolution in effect on a single page.
<br><br>

 The default fallback resoultion is 300 pixels per inch in both
 dimensions.<br><br>

</dd>
<dt><big><a name="Surface.getFallbackResolution"></a>Resolution <u>getFallbackResolution</u>();
</big></dt>
<dd>This function returns the previous fallback resolution set
 by , or default
 fallback resolution if never set.<br><br>

</dd>
<dt><big><a name="Surface.fallbackResolution"></a>@property void <u>fallbackResolution</u>(Resolution <i>res</i>);
<br>@property Resolution <u>fallbackResolution</u>();
</big></dt>
<dd>Convenience property function<br><br>

</dd>
<dt><big><a name="Surface.getType"></a>SurfaceType <u>getType</u>();
</big></dt>
<dd>This function returns the C type of a Surface. See 
 for available types.<br><br>

</dd>
<dt><big><a name="Surface.type"></a>alias <u>type</u> = getType;
</big></dt>
<dd>convenience alias<br><br>

</dd>
<dt><big><a name="Surface.copyPage"></a>void <u>copyPage</u>();
</big></dt>
<dd>Emits the current page for backends that support multiple pages,
 but doesn't clear it, so that the contents of the current page
 will be retained for the next page. Use 
 if you want to get an empty page after the emission.
<br><br>
There is a convenience function for this that can be called on
 a , namely .<br><br>

</dd>
<dt><big><a name="Surface.showPage"></a>void <u>showPage</u>();
</big></dt>
<dd>Emits and clears the current page for backends that support
 multiple pages. Use  if you don't
 want to clear the page.
<br><br>
There is a convenience function for this that can be called on
 a , namely .<br><br>

</dd>
<dt><big><a name="Surface.hasShowTextGlyphs"></a>bool <u>hasShowTextGlyphs</u>();
</big></dt>
<dd>Returns whether the surface supports sophisticated 
 operations. That is, whether it actually uses the provided text
 and cluster data to a  call.
<br><br>
<b>Note:</b><br>
Even if this function returns <b>false</b>, a 
 operation targeted at surface will still succeed. It just will
 act like a  operation. Users can use this
 function to avoid computing UTF-8 text and cluster mapping
 if the target surface does not use it.

<br><br>
<b>Returns:</b><br>
<b>true</b> if surface supports , <b>false</b> otherwise<br><br>

</dd>
<dt><big><a name="Surface.setMimeData"></a>void <u>setMimeData</u>(string <i>type</i>, ubyte* <i>data</i>, ulong <i>length</i>, cairo_destroy_func_t <i>destroy</i>, void* <i>closure</i>);
</big></dt>
<dd>Attach an image in the format mime_type to surface. To remove
 the <i>data</i> from a surface, call this function with same mime
 <i>type</i> and NULL for <i>data</i>.
<br><br>
The attached image (or filename) <i>data</i> can later be used by
 backends which support it (currently: PDF, PS, SVG and Win32
 Printing surfaces) to emit this <i>data</i> instead of making a snapshot
 of the surface. This approach tends to be faster and requires
 less memory and disk space.
<br><br>

 The recognized MIME types are the following: CAIRO_MIME_TYPE_JPEG,
 CAIRO_MIME_TYPE_PNG, CAIRO_MIME_TYPE_JP2, CAIRO_MIME_TYPE_URI.
<br><br>

 See corresponding backend surface docs for details about which
 MIME types it can handle.

<br><br>
<b>Caution:</b><br>
the associated MIME <i>data</i> will be discarded if you draw
 on the surface afterwards. Use this function with care.

<br><br>
<b>Params:</b><br>
<table><tr><td>mime_type</td>
<td>the MIME <i>type</i> of the image <i>data</i></td></tr>
<tr><td>ubyte* <i>data</i></td>
<td>the image <i>data</i> to attach to the surface</td></tr>
<tr><td>ulong <i>length</i></td>
<td>the <i>length</i> of the image <i>data</i></td></tr>
<tr><td>cairo_destroy_func_t <i>destroy</i></td>
<td>a cairo_destroy_func_t which will be called when the
     surface is destroyed or when new image <i>data</i> is attached using
     the same mime <i>type</i>.</td></tr>
<tr><td>void* <i>closure</i></td>
<td>the <i>data</i> to be passed to the <i>destroy</i> notifier</td></tr>
</table><br>
<b>Throws:</b><br>
OutOfMemoryError if a slot could not be allocated for the user <i>data</i>.

<br><br>
<b>TODO:</b><br>
More D-like API

<br><br>
<b>Note:</b><br>
<font color=red>Only use this if you know what your doing! Make sure you get
 memory management of the passed in <i>data</i> right!</font><br><br>

</dd>
<dt><big><a name="Surface.getMimeData"></a>void <u>getMimeData</u>(string <i>type</i>, out ubyte* <i>data</i>, out ulong <i>length</i>);
</big></dt>
<dd>Return mime <i>data</i> previously attached to surface using the
 specified mime <i>type</i>. If no <i>data</i> has been attached with the given
 mime <i>type</i>, <i>data</i> is set <b>null</b>.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>type</i></td>
<td>the mime <i>type</i> of the image <i>data</i></td></tr>
</table><br>
<b>TODO:</b><br>
More D-like API

<br><br>
<b>Note:</b><br>
<font color=red>Only use this if you know what your doing! Make sure you get
 memory management of the <i>data</i> right!</font><br><br>

</dd>
</dl>
</dd>
<dt><big><a name="formatStrideForWidth"></a>int <u>formatStrideForWidth</u>(Format <i>format</i>, int <i>width</i>);
</big></dt>
<dd>This function provides a stride value that will respect all alignment
 requirements of the accelerated image-rendering code within cairo.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>int</font> stride;
<font color=blue>ubyte</font>[] data;
Surface surface;

stride = <u>formatStrideForWidth</u>(<i>format</i>, <i>width</i>);
data = <font color=blue>new</font> <font color=blue>ubyte</font>[](stride * height); <font color=green>//could also use malloc
</font>surface = <font color=blue>new</font> ImageSurface(data, <i>format</i>, <i>width</i>, height, stride);
</pre>

<br><br>
<b>Params:</b><br>
<table><tr><td>Format <i>format</i></td>
<td>The desired Format of an image surface to be created</td></tr>
<tr><td>int <i>width</i></td>
<td>The desired <i>width</i> of an image surface to be created</td></tr>
</table><br>
<b>Returns:</b><br>
 the appropriate stride to use given the desired <i>format</i> and <i>width</i>, or
 -1 if either the <i>format</i> is invalid or the <i>width</i> too large.<br><br>

</dd>
<dt><big><a name="ImageSurface"></a>class <u>ImageSurface</u>: <u>cairo.cairo.Surface</u>;
</big></dt>
<dd>Image Surfaces  Rendering to memory buffers
<br><br>
Image surfaces provide the ability to render to memory buffers either
 allocated by cairo or by the calling code. The supported image
 formats are those defined in .<br><br>

<dl><dt><big><a name="ImageSurface.this"></a>this(cairo_surface_t* <i>ptr</i>);
</big></dt>
<dd>Create a  from a existing .
 ImageSurface is a garbage collected class. It will call 
 when it gets collected by the GC or when  is called.
<br><br>
<b>Warning:</b><br>
's reference count is not increased by this function!
 Adjust reference count before calling it if necessary
<br><br>

 <font color=red>Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</font><br><br>

</dd>
<dt><big><a name="ImageSurface.this.2"></a>this(Format <i>format</i>, int <i>width</i>, int <i>height</i>);
</big></dt>
<dd>Creates an image surface of the specified <i>format</i> and dimensions.
 Initially the surface contents are all 0. (Specifically, within
 each pixel, each color or alpha channel belonging to <i>format</i> will
 be 0. The contents of bits within a pixel, but not belonging
 to the given <i>format</i> are undefined).
<br><br>
<b>Params:</b><br>
<table><tr><td>Format <i>format</i></td>
<td><i>format</i> of pixels in the surface to create</td></tr>
<tr><td>int <i>width</i></td>
<td><i>width</i> of the surface, in pixels</td></tr>
<tr><td>int <i>height</i></td>
<td><i>height</i> of the surface, in pixels</td></tr>
</table><br>

</dd>
<dt><big><a name="ImageSurface.this.3"></a>this(ubyte[] <i>data</i>, Format <i>format</i>, int <i>width</i>, int <i>height</i>, int <i>stride</i>);
</big></dt>
<dd>Creates an image surface for the provided pixel <i>data</i>.
 <font color=red>The output buffer must be kept around until the 
 is destroyed or  is called on the surface.</font>
 The initial contents of <i>data</i> will be used as the initial image
 contents; you must explicitly clear the buffer, using, for
 example,  and  if you
 want it cleared.
<br><br>
Note that the <i>stride</i> may be larger than <i>width</i>*bytes_per_pixel
 to provide proper alignment for each pixel and row.
 This alignment is required to allow high-performance rendering
 within cairo. The correct way to obtain a legal <i>stride</i> value is
 to call  with the desired <i>format</i> and
 maximum image <i>width</i> value, and then use the resulting <i>stride</i>
 value to allocate the <i>data</i> and to create the image surface.
 See  for example code.

<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte[] <i>data</i></td>
<td>a pointer to a buffer supplied by the application in
     which to write contents. This pointer must be suitably aligned
     for any kind of variable, (for example, a pointer returned by malloc).</td></tr>
<tr><td>Format <i>format</i></td>
<td>the <i>format</i> of pixels in the buffer</td></tr>
<tr><td>int <i>width</i></td>
<td>the <i>width</i> of the image to be stored in the buffer</td></tr>
<tr><td>int <i>height</i></td>
<td>the <i>height</i> of the image to be stored in the buffer</td></tr>
<tr><td>int <i>stride</i></td>
<td>the number of bytes between the start of rows in the
     buffer as allocated. This value should always be computed
     by  before allocating
     the <i>data</i> buffer.</td></tr>
</table><br>

</dd>
<dt><big><a name="ImageSurface.getData"></a>ubyte* <u>getData</u>();
</big></dt>
<dd>Get a pointer to the data of the image surface,
 for direct inspection or modification.
<br><br>
<b>Warning:</b><br>
There's no way to get the size of the buffer from
 cairo, so you'll only get a . Be careful!<br><br>

</dd>
<dt><big><a name="ImageSurface.data"></a>alias <u>data</u> = getData;
</big></dt>
<dd>convenience alias<br><br>

</dd>
<dt><big><a name="ImageSurface.getFormat"></a>Format <u>getFormat</u>();
</big></dt>
<dd>Get the format of the surface.<br><br>

</dd>
<dt><big><a name="ImageSurface.format"></a>alias <u>format</u> = getFormat;
</big></dt>
<dd>convenience alias<br><br>

</dd>
<dt><big><a name="ImageSurface.getWidth"></a>int <u>getWidth</u>();
</big></dt>
<dd>Get the width of the image surface in pixels.<br><br>

</dd>
<dt><big><a name="ImageSurface.width"></a>alias <u>width</u> = getWidth;
</big></dt>
<dd>convenience alias<br><br>

</dd>
<dt><big><a name="ImageSurface.getHeight"></a>int <u>getHeight</u>();
</big></dt>
<dd>Get the height of the image surface in pixels.<br><br>

</dd>
<dt><big><a name="ImageSurface.height"></a>alias <u>height</u> = getHeight;
</big></dt>
<dd>convenience alias<br><br>

</dd>
<dt><big><a name="ImageSurface.getStride"></a>int <u>getStride</u>();
</big></dt>
<dd>Get the stride of the image surface in bytes.<br><br>

</dd>
<dt><big><a name="ImageSurface.stride"></a>alias <u>stride</u> = getStride;
</big></dt>
<dd>convenience alias<br><br>

</dd>
<dt><big><a name="ImageSurface.fromPng"></a>static ImageSurface <u>fromPng</u>(string <i>file</i>);
</big></dt>
<dd>Creates a new image surface and initializes the contents to the given PNG <i>file</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>file</i></td>
<td>name of PNG <i>file</i> to load</td></tr>
</table><br>
<b>Note:</b><br>
Only available if cairo, cairoD and the cairoD user
 code were compiled with "version=CAIRO_HAS_PNG_FUNCTIONS"<br><br>

</dd>
<dt><big><a name="ImageSurface.writeToPNG"></a>void <u>writeToPNG</u>(string <i>file</i>);
</big></dt>
<dd>Writes the contents of surface to a new <i>file</i> filename as a PNG image.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>file</i></td>
<td>the name of a <i>file</i> to write to</td></tr>
</table><br>
<b>Note:</b><br>
Only available if cairo, cairoD and the cairoD user
 code were compiled with "version=CAIRO_HAS_PNG_FUNCTIONS"<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Context"></a>struct <u>Context</u>;
</big></dt>
<dd>The cairo drawing context
<br><br>
 is the main object used when drawing with cairo. To draw
 with cairo, you create a , set the target surface, and drawing
 options for the , create shapes with functions like 
 and , and then draw shapes with 
 or .
<br><br>

 's can be pushed to a stack via .
 They may then safely be changed, without loosing the current state.
 Use  to restore to the saved state.<br><br>

<dl><dt><big><a name="Context.nativePointer"></a>cairo_t* <u>nativePointer</u>;
</big></dt>
<dd>The underlying  handle<br><br>

</dd>
<dt><big><a name="Context.debugging"></a>bool <u>debugging</u>;
</big></dt>
<dd>Enable / disable memory management <u>debugging</u> for this Context
 instance. Only available if both cairoD and the cairoD user
 code were compiled with "debug=RefCounted"
<br><br>
Output is written to stdout, see
 <a href="https://github.com/jpf91/cairoD/wiki/Memory-Management#debugging">https://github.com/jpf91/cairoD/wiki/Memory-Management#debugging</a>
 for more information<br><br>

</dd>
<dt><big><a name="Context.dispose"></a>void <u>dispose</u>();
</big></dt>
<dd>Explicitly drecrease the reference count.
<br><br>
See <a href="https://github.com/jpf91/cairoD/wiki/Memory-Management#2.1-structs">https://github.com/jpf91/cairoD/wiki/Memory-Management#2.1-structs</a>
 for more information.<br><br>

</dd>
<dt><big><a name="Context.opAssign"></a>void <u>opAssign</u>(typeof(this) <i>rhs</i>);
</big></dt>
<dd>Assignment operator<br><br>

</dd>
<dt><big><a name="Context.this"></a>this(Surface <i>target</i>);
</big></dt>
<dd>Creates a new  with all graphics state parameters set
 to default values and with <i>target</i> as a <i>target</i> surface. The
 <i>target</i> surface should be constructed with a backend-specific
 function such as .
<br><br>
This function references <i>target</i>, so you can immediately call
  on it if you don't need to maintain
 a separate reference to it.<br><br>

</dd>
<dt><big><a name="Context.this.2"></a>this(cairo_t* <i>ptr</i>);
</big></dt>
<dd>Create a  from a existing .
 Context is a garbage collected class. It will call 
 when it gets collected by the GC or when  is called.
<br><br>
<b>Warning:</b><br>
's reference count is not increased by this function!
 Adjust reference count before calling it if necessary
<br><br>

 <font color=red>Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</font><br><br>

</dd>
<dt><big><a name="Context.save"></a>void <u>save</u>();
</big></dt>
<dd>Makes a copy of the current state of cr and saves it on an
 internal stack of saved states for cr. When 
 is called, cr will be restored to the saved state. Multiple
 calls to  and   can be nested; each
 call to   restores the state from the matching
 paired .
<br><br>
It isn't necessary to clear all saved states before a 
 is freed. If the reference count of a  drops to zero
 , any saved states will be freed along with the .<br><br>

</dd>
<dt><big><a name="Context.restore"></a>void <u>restore</u>();
</big></dt>
<dd>Restores cr to the state saved by a preceding call to
  and removes that state from the stack of
 saved states.<br><br>

</dd>
<dt><big><a name="Context.getTarget"></a>Surface <u>getTarget</u>();
</big></dt>
<dd>Gets the target surface for the cairo context as passed to
 the constructor.<br><br>

</dd>
<dt><big><a name="Context.target"></a>alias <u>target</u> = getTarget;
</big></dt>
<dd>convenience alias<br><br>

</dd>
<dt><big><a name="Context.pushGroup"></a>void <u>pushGroup</u>();
</big></dt>
<dd>Temporarily redirects drawing to an intermediate surface known
 as a group. The redirection lasts until the group is completed
 by a call to  or .
 These calls provide the result of any drawing to the group
 as a pattern, (either as an explicit object, or set as the
 source pattern).
<br><br>
 This group functionality can be convenient for performing
 intermediate compositing. One common use of a group is to render
 objects as opaque within the group, (so that they occlude each other),
 and then blend the result with translucence onto the destination.
<br><br>

 Groups can be nested arbitrarily deep by making balanced calls
 to /. Each call pushes/pops
 the new target group onto/from a stack.
<br><br>

 The  function calls  so that any
 changes to the graphics state will not be visible outside the
 group, (the  functions call ).
<br><br>

 By default the intermediate group will have a content type of
 CAIRO_CONTENT_COLOR_ALPHA. Other content types can be chosen
 for the group by using  instead.
<br><br>

 As an example, here is how one might fill and stroke a path with
 translucence, but without any portion of the fill being visible
 under the stroke:
<pre class="d_code">cr.<u>pushGroup</u>();
cr.setSource(fill_pattern);
cr.fillPreserve();
cr.setSource(stroke_pattern);
cr.stroke();
cr.popGroupToSource();
cr.paintWithAlpha(alpha);
</pre>
<br><br>

</dd>
<dt><big><a name="Context.pushGroup.2"></a>void <u>pushGroup</u>(Content <i>cont</i>);
</big></dt>
<dd>Temporarily redirects drawing to an intermediate surface known
 as a group. The redirection lasts until the group is completed
 by a call to  or .
 These calls provide the result of any drawing to the group as
 a pattern, (either as an explicit object, or set as the source
 pattern).
<br><br>
The group will have a content type of content. The ability to
 control this content type is the only distinction between this
 function and  which you should see for a more
 detailed description of group rendering.<br><br>

</dd>
<dt><big><a name="Context.popGroup"></a>Pattern <u>popGroup</u>();
</big></dt>
<dd>Terminates the redirection begun by a call to 
 or  and returns a new pattern
 containing the results of all drawing operations performed to
 the group.
<br><br>
The  function calls , (balancing
 a call to  by the  function), so that any
 changes to the graphics state will not be visible outside the group.<br><br>

</dd>
<dt><big><a name="Context.popGroupToSource"></a>void <u>popGroupToSource</u>();
</big></dt>
<dd>Terminates the redirection begun by a call to 
 or  and installs the resulting
 pattern as the source pattern in the given cairo context.
<br><br>
 The behavior of this function is equivalent to the sequence
 of operations:
<pre class="d_code">Pattern group = cr.popGroup();
cr.setSource(group);
group.dispose();
</pre>
 but is more convenient as their is no need for a variable to
 store the short-lived pointer to the pattern.
<br><br>

 The  function calls ,
 (balancing a call to  by the  function),
 so that any changes to the graphics state will not be
 visible outside the group.<br><br>

</dd>
<dt><big><a name="Context.getGroupTarget"></a>Surface <u>getGroupTarget</u>();
</big></dt>
<dd>Gets the current destination surface for the context.
 This is either the original target surface as passed to
 the Context constructor or the target surface for the current
 group as started by the most recent call to
   or  .<br><br>

</dd>
<dt><big><a name="Context.groupTarget"></a>alias <u>groupTarget</u> = getGroupTarget;
</big></dt>
<dd>convenience alias<br><br>

</dd>
<dt><big><a name="Context.setSourceRGB"></a>void <u>setSourceRGB</u>(double <i>red</i>, double <i>green</i>, double <i>blue</i>);
<br>void <u>setSourceRGB</u>(RGB <i>rgb</i>);
</big></dt>
<dd>Sets the source pattern within cr to an opaque color.
 This opaque color will then be used for any subsequent
 drawing operation until a new source pattern is set.
<br><br>
The color components are floating point numbers in the range
 0 to 1. If the values passed in are outside that range,
 they will be clamped.
<br><br>

 The default source pattern is opaque black,
 (that is, it is equivalent to <u>setSourceRGB</u>(0.0, 0.0, 0.0)).<br><br>

</dd>
<dt><big><a name="Context.setSourceRGBA"></a>void <u>setSourceRGBA</u>(double <i>red</i>, double <i>green</i>, double <i>blue</i>, double <i>alpha</i>);
<br>void <u>setSourceRGBA</u>(RGBA <i>rgba</i>);
</big></dt>
<dd>Sets the source pattern within cr to a translucent color.
 This color will then be used for any subsequent drawing
 operation until a new source pattern is set.
<br><br>
The color and <i>alpha</i> components are floating point numbers in
 the range 0 to 1. If the values passed in are outside that
 range, they will be clamped.
<br><br>

 The default source pattern is opaque black, (that is, it is
 equivalent to <u>setSourceRGBA</u>(0.0, 0.0, 0.0, 1.0)).<br><br>

</dd>
<dt><big><a name="Context.setSource"></a>void <u>setSource</u>(Pattern <i>pat</i>);
</big></dt>
<dd>Sets the source pattern within cr to source. This pattern will
 then be used for any subsequent drawing operation until
 a new source pattern is set.
<br><br>
<b>Note:</b><br>
The pattern's transformation matrix will be locked to
 the user space in effect at the time of <u>setSource</u>(). This
 means that further modifications of the current transformation
 matrix will not affect the source pattern.
 See .
<br><br>

 The default source pattern is a solid pattern that is opaque
 black, (that is, it is equivalent
 to setSourceRGB(0.0, 0.0, 0.0)).<br><br>

</dd>
<dt><big><a name="Context.getSource"></a>Pattern <u>getSource</u>();
</big></dt>
<dd>Gets the current source pattern for cr.<br><br>

</dd>
<dt><big><a name="Context.source"></a>@property void <u>source</u>(Pattern <i>pat</i>);
<br>@property Pattern <u>source</u>();
</big></dt>
<dd>Convenience property<br><br>

</dd>
<dt><big><a name="Context.setSourceSurface"></a>void <u>setSourceSurface</u>(Surface <i>sur</i>, double <i>x</i>, double <i>y</i>);
<br>void <u>setSourceSurface</u>(Surface <i>sur</i>, Point!double <i>p1</i>);
</big></dt>
<dd>This is a convenience function for creating a pattern from
 surface and setting it as the source in cr with .
<br><br>
The <i>x</i> and <i>y</i> parameters give the user-space coordinate at
 which the surface origin should appear. (The surface origin
 is its upper-left corner before any transformation has been
 applied.) The <i>x</i> and <i>y</i> parameters are negated and then set
 as translation values in the pattern matrix.
<br><br>

 Other than the initial translation pattern matrix,
 as described above, all other pattern attributes,
 (such as its extend mode), are set to the default values as
 in . The resulting pattern can be
 queried with  so that these
 attributes can be modified if desired, (eg. to create a
 repeating pattern with ).

<br><br>
<b>Params:</b><br>
<table><tr><td>double <i>x</i></td>
<td>User-space X coordinate for surface origin</td></tr>
<tr><td>double <i>y</i></td>
<td>User-space Y coordinate for surface origin</td></tr>
</table><br>

</dd>
<dt><big><a name="Context.setAntiAlias"></a>void <u>setAntiAlias</u>(AntiAlias <i>antialias</i>);
</big></dt>
<dd>Set the antialiasing mode of the rasterizer used for
 drawing shapes. This value is a hint, and a particular
 backend may or may not support a particular value. At
 the current time, no backend supports CAIRO_ANTIALIAS_SUBPIXEL
 when drawing shapes.
<br><br>
Note that this option does not affect text rendering,
 instead see .<br><br>

</dd>
<dt><big><a name="Context.getAntiAlias"></a>AntiAlias <u>getAntiAlias</u>();
</big></dt>
<dd>Gets the current shape antialiasing mode, as set by .<br><br>

</dd>
<dt><big><a name="Context.antiAlias"></a>@property void <u>antiAlias</u>(AntiAlias <i>aa</i>);
<br>@property AntiAlias <u>antiAlias</u>();
</big></dt>
<dd>Convenience property<br><br>

</dd>
<dt><big><a name="Context.setDash"></a>void <u>setDash</u>(const(double[]) <i>dashes</i>, double <i>offset</i>);
</big></dt>
<dd>Sets the dash pattern to be used by . A dash
 pattern is specified by <i>dashes</i>, an array of positive values.
 Each value provides the length of alternate "on" and
 "off" portions of the stroke. The <i>offset</i> specifies an <i>offset</i>
 into the pattern at which the stroke begins.
<br><br>
Each "on" segment will have caps applied as if the segment
 were a separate sub-path. In particular, it is valid to use
 an "on" length of 0.0 with CAIRO_LINE_CAP_ROUND or
 CAIRO_LINE_CAP_SQUARE in order to distributed dots
 or squares along a path.

<br><br>
<b>Note:</b><br>
The length values are in user-space units as
 evaluated at the time of stroking. This is not necessarily
 the same as the user space at the time of .
<br><br>

 If <i>dashes</i> is empty dashing is disabled.
<br><br>

 If <i>dashes</i>.length is 1 a symmetric pattern is assumed with alternating
 on and off portions of the size specified by the single value
 in <i>dashes</i>.
<br><br>

 If any value in <i>dashes</i> is negative, or if all values are 0, then
 cr will be put into an error state with a
 status of CAIRO_STATUS_INVALID_DASH.

<br><br>
<b>Params:</b><br>
<table><tr><td>const(double[]) <i>dashes</i></td>
<td>an array specifying alternate lengths of on and off stroke portions</td></tr>
<tr><td>double <i>offset</i></td>
<td>an <i>offset</i> into the dash pattern at which the stroke should start</td></tr>
</table><br>

</dd>
<dt><big><a name="Context.getDash"></a>double[] <u>getDash</u>(out double <i>offset</i>);
</big></dt>
<dd>Gets the current dash array.<br><br>

</dd>
<dt><big><a name="Context.getDashCount"></a>int <u>getDashCount</u>();
</big></dt>
<dd>This function returns the length of the dash array in cr
 (0 if dashing is not currently in effect).<br><br>

</dd>
<dt><big><a name="Context.setFillRule"></a>void <u>setFillRule</u>(FillRule <i>rule</i>);
</big></dt>
<dd>Set the current fill <i>rule</i> within the cairo context. The fill
 <i>rule</i> is used to determine which regions are inside or outside
 a complex (potentially self-intersecting) path. The current
 fill <i>rule</i> affects both  and . See
  for details on the semantics of each
 available fill <i>rule</i>.
<br><br>
The default fill <i>rule</i> is CAIRO_FILL_RULE_WINDING.<br><br>

</dd>
<dt><big><a name="Context.getFillRule"></a>FillRule <u>getFillRule</u>();
</big></dt>
<dd>Gets the current fill rule, as set by .<br><br>

</dd>
<dt><big><a name="Context.fillRule"></a>@property void <u>fillRule</u>(FillRule <i>rule</i>);
<br>@property FillRule <u>fillRule</u>();
</big></dt>
<dd>Convenience property<br><br>

</dd>
<dt><big><a name="Context.setLineCap"></a>void <u>setLineCap</u>(LineCap <i>cap</i>);
</big></dt>
<dd>Sets the current line <i>cap</i> style within the cairo context.
 See  for details about how the available
 line <i>cap</i> styles are drawn.
<br><br>
As with the other stroke parameters, the current line <i>cap</i>
 style is examined by , 
 and , but does not have any
 effect during path construction.
<br><br>

 The default line <i>cap</i> style is CAIRO_LINE_CAP_BUTT.<br><br>

</dd>
<dt><big><a name="Context.getLineCap"></a>LineCap <u>getLineCap</u>();
</big></dt>
<dd>Gets the current line cap style, as set by .<br><br>

</dd>
<dt><big><a name="Context.lineCap"></a>@property void <u>lineCap</u>(LineCap <i>cap</i>);
<br>@property LineCap <u>lineCap</u>();
</big></dt>
<dd>Convenience property<br><br>

</dd>
<dt><big><a name="Context.setLineJoin"></a>void <u>setLineJoin</u>(LineJoin <i>join</i>);
</big></dt>
<dd>Sets the current line <i>join</i> style within the cairo context.
 See  for details about how the available
 line <i>join</i> styles are drawn.
<br><br>
As with the other stroke parametes, the current line <i>join</i>
 style is examined by , 
 and , but does not have any effect
 during path construction.
<br><br>

 The default line <i>join</i> style is CAIRO_LINE_JOIN_MITER.<br><br>

</dd>
<dt><big><a name="Context.getLineJoin"></a>LineJoin <u>getLineJoin</u>();
</big></dt>
<dd>Gets the current line join style, as set by <br><br>

</dd>
<dt><big><a name="Context.lineJoin"></a>@property void <u>lineJoin</u>(LineJoin <i>join</i>);
<br>@property LineJoin <u>lineJoin</u>();
</big></dt>
<dd>Convenience property<br><br>

</dd>
<dt><big><a name="Context.setLineWidth"></a>void <u>setLineWidth</u>(double <i>width</i>);
</big></dt>
<dd>Sets the current line <i>width</i> within the cairo context. The line
 <i>width</i> value specifies the diameter of a pen that is circular
 in user space, (though device-space pen may be an ellipse
 in general due to scaling/shear/rotation of the CTM).
<br><br>
<b>Note:</b><br>
When the description above refers to user space and CTM
 it refers to the user space and CTM in effect at the time
 of the stroking operation, not the user space and CTM in
 effect at the time of the call to .
 The simplest usage makes both of these spaces identical.
 That is, if there is no change to the CTM between a call to
  and the stroking operation, then one
 can just pass user-space values to  and
 ignore this note.
<br><br>

 As with the other stroke parameters, the current line <i>width</i> is
 examined by , 
 and , but does not have any effect during
 path construction.
<br><br>

 The default line <i>width</i> value is 2.0.<br><br>

</dd>
<dt><big><a name="Context.getLineWidth"></a>double <u>getLineWidth</u>();
</big></dt>
<dd>This function returns the current line width value exactly
 as set by cairo_set_line_width(). Note that the value is
 unchanged even if the CTM has changed between the calls
 to  and .<br><br>

</dd>
<dt><big><a name="Context.lineWidth"></a>@property void <u>lineWidth</u>(double <i>width</i>);
<br>@property double <u>lineWidth</u>();
</big></dt>
<dd>Convenience property<br><br>

</dd>
<dt><big><a name="Context.setMiterLimit"></a>void <u>setMiterLimit</u>(double <i>limit</i>);
</big></dt>
<dd>Sets the current miter <i>limit</i> within the cairo context.
<br><br>
If the current line join style is set to
 CAIRO_LINE_JOIN_MITER (see cairo_set_line_join()), the miter
 <i>limit</i> is used to determine whether the lines should be joined
 with a bevel instead of a miter. Cairo divides the length of
 the miter by the line width. If the result is greater than the
 miter <i>limit</i>, the style is converted to a bevel.
<br><br>

 As with the other stroke parameters, the current line miter
 <i>limit</i> is examined by , 
 and , but does not have any effect
 during path construction.
<br><br>

 The default miter <i>limit</i> value is 10.0, which will convert
 joins with interior angles less than 11 degrees to bevels
 instead of miters. For reference, a miter <i>limit</i> of 2.0 makes
 the miter cutoff at 60 degrees, and a miter <i>limit</i> of 1.414
 makes the cutoff at 90 degrees.
<br><br>

 A miter <i>limit</i> for a desired angle can be computed as: miter
 <i>limit</i> = 1/sin(angle/2)<br><br>

</dd>
<dt><big><a name="Context.getMiterLimit"></a>double <u>getMiterLimit</u>();
</big></dt>
<dd>Gets the current miter limit, as set by <br><br>

</dd>
<dt><big><a name="Context.miterLimit"></a>@property void <u>miterLimit</u>(double <i>limit</i>);
<br>@property double <u>miterLimit</u>();
</big></dt>
<dd>Convenience property<br><br>

</dd>
<dt><big><a name="Context.setOperator"></a>void <u>setOperator</u>(Operator <i>op</i>);
</big></dt>
<dd>Sets the compositing operator to be used for all
 drawing operations. See  for details on
 the semantics of each available compositing operator.
<br><br>
The default operator is CAIRO_OPERATOR_OVER.<br><br>

</dd>
<dt><big><a name="Context.getOperator"></a>Operator <u>getOperator</u>();
</big></dt>
<dd>Gets the current compositing operator for a cairo context.<br><br>

</dd>
<dt><big><a name="Context.operator"></a>@property void <u>operator</u>(Operator <i>op</i>);
<br>@property Operator <u>operator</u>();
</big></dt>
<dd>Convenience property<br><br>

</dd>
<dt><big><a name="Context.setTolerance"></a>void <u>setTolerance</u>(double <i>tolerance</i>);
</big></dt>
<dd>Sets the <i>tolerance</i> used when converting paths into trapezoids.
 Curved segments of the path will be subdivided until the maximum
 deviation between the original path and the polygonal
 approximation is less than <i>tolerance</i>. The default value
 is 0.1. A larger value will give better performance, a smaller
 value, better appearance. (Reducing the value from the
 default value of 0.1 is unlikely to improve appearance
 significantly.) The accuracy of paths within Cairo is limited
 by the precision of its internal arithmetic, and the prescribed
 <i>tolerance</i> is restricted to the smallest representable
 internal value.<br><br>

</dd>
<dt><big><a name="Context.getTolerance"></a>double <u>getTolerance</u>();
</big></dt>
<dd>Gets the current tolerance value, as set by <br><br>

</dd>
<dt><big><a name="Context.tolerance"></a>@property void <u>tolerance</u>(double <u>tolerance</u>);
<br>@property double <u>tolerance</u>();
</big></dt>
<dd>Convenience property<br><br>

</dd>
<dt><big><a name="Context.clip"></a>void <u>clip</u>();
</big></dt>
<dd>Establishes a new <u>clip</u> region by intersecting the current
 <u>clip</u> region with the current path as it would be filled by
  and according to the current
 fill rule (see ).
<br><br>
After , the current path will be cleared from the
 cairo context.
<br><br>

 The current <u>clip</u> region affects all drawing operations by
 effectively masking out any changes to the surface that are
 outside the current <u>clip</u> region.
<br><br>

 Calling  can only make the <u>clip</u> region smaller,
 never larger. But the current <u>clip</u> is part of the graphics state,
 so a temporary restriction of the <u>clip</u> region can be achieved
 by calling  within a /
 pair. The only other means of increasing the size of the <u>clip</u>
 region is .<br><br>

</dd>
<dt><big><a name="Context.clipPreserve"></a>void <u>clipPreserve</u>();
</big></dt>
<dd>Establishes a new clip region by intersecting the current clip
 region with the current path as it would be filled by
  and according to the current fill rule
 (see ).
<br><br>
Unlike ,  preserves the
 path within the cairo context.
<br><br>

 The current clip region affects all drawing operations by
 effectively masking out any changes to the surface that are
 outside the current clip region.
<br><br>

 Calling  can only make the clip region
 smaller, never larger. But the current clip is part of the
 graphics state, so a temporary restriction of the clip region
 can be achieved by calling  within a /
 pair. The only other means of increasing the size of the clip
 region is .<br><br>

</dd>
<dt><big><a name="Context.clipExtents"></a>Box <u>clipExtents</u>();
</big></dt>
<dd>Computes a bounding box in user coordinates covering the area
 inside the current clip.<br><br>

</dd>
<dt><big><a name="Context.inClip"></a>bool <u>inClip</u>(Point!double <i>point</i>);
</big></dt>
<dd>Tests whether the given <i>point</i> is inside the area that would
 be visible through the current clip, i.e. the area that
 would be filled by a cairo_paint() operation.
<br><br>
See , and .<br><br>

</dd>
<dt><big><a name="Context.resetClip"></a>void <u>resetClip</u>();
</big></dt>
<dd>Reset the current clip region to its original, unrestricted
 state. That is, set the clip region to an infinitely
 large shape containing the target surface. Equivalently,
 if infinity is too hard to grasp, one can imagine the clip
 region being reset to the exact bounds of the target surface.
<br><br>
Note that code meant to be reusable should not call
  as it will cause results unexpected by
 higher-level code which calls . Consider using
  and  around  as a
 more robust means of temporarily restricting the clip region.<br><br>

</dd>
<dt><big><a name="Context.copyClipRectangles"></a>Rectangle!double[] <u>copyClipRectangles</u>();
</big></dt>
<dd>Gets the current clip region as a list of rectangles in user
 coordinates.<br><br>

</dd>
<dt><big><a name="Context.fill"></a>void <u>fill</u>();
</big></dt>
<dd>A drawing operator that fills the current path according to
 the current <u>fill</u> rule, (each sub-path is implicitly closed
 before being filled). After c, the current
 path will be cleared from the cairo context. See
  and .<br><br>

</dd>
<dt><big><a name="Context.fillPreserve"></a>void <u>fillPreserve</u>();
</big></dt>
<dd>A drawing operator that fills the current path according to
 the current fill rule, (each sub-path is implicitly closed
 before being filled). Unlike , 
 preserves the path within the cairo context.<br><br>

</dd>
<dt><big><a name="Context.fillExtends"></a>Box <u>fillExtends</u>();
</big></dt>
<dd>Computes a bounding box in user coordinates covering the area
 that would be affected, (the "inked" area), by a
  operation given the current path and fill parameters.
 If the current path is empty, returns an empty rectangle
 ((0,0), (0,0)). Surface dimensions and clipping are not
 taken into account.
<br><br>
Contrast with , which is similar, but
 returns non-zero extents for some paths with no inked area,
 (such as a simple line segment).
<br><br>

 Note that  must necessarily do more work
 to compute the precise inked areas in light of the fill rule,
 so  may be more desirable for sake of
 performance if the non-inked path extents are desired.
<br><br>

 See ,  and .<br><br>

</dd>
<dt><big><a name="Context.inFill"></a>bool <u>inFill</u>(Point!double <i>point</i>);
</big></dt>
<dd>Tests whether the given <i>point</i> is inside the area that would
 be affected by a cairo_fill() operation given the current path
 and filling parameters. Surface dimensions and clipping are not
 taken into account.
<br><br>
See ,  and .<br><br>

</dd>
<dt><big><a name="Context.mask"></a>void <u>mask</u>(Pattern <i>pattern</i>);
</big></dt>
<dd>A drawing operator that paints the current source using the
 alpha channel of <i>pattern</i> as a <u>mask</u>. (Opaque areas of <i>pattern</i>
 are painted with the source, transparent areas are not painted.)<br><br>

</dd>
<dt><big><a name="Context.maskSurface"></a>void <u>maskSurface</u>(Surface <i>surface</i>, Point!double <i>location</i>);
<br>void <u>maskSurface</u>(Surface <i>surface</i>, double <i>x</i>, double <i>y</i>);
</big></dt>
<dd>A drawing operator that paints the current source using
 the alpha channel of <i>surface</i> as a mask. (Opaque areas of
 <i>surface</i> are painted with the source, transparent areas
 are not painted.)
<br><br>
<b>Params:</b><br>
<table><tr><td>Point!double <i>location</i></td>
<td>coordinates at which to place the origin of <i>surface</i></td></tr>
</table><br>

</dd>
<dt><big><a name="Context.paint"></a>void <u>paint</u>();
</big></dt>
<dd>A drawing operator that paints the current source everywhere
 within the current clip region.<br><br>

</dd>
<dt><big><a name="Context.paintWithAlpha"></a>void <u>paintWithAlpha</u>(double <i>alpha</i>);
</big></dt>
<dd>A drawing operator that paints the current source everywhere
 within the current clip region using a mask of constant <i>alpha</i>
 value <i>alpha</i>. The effect is similar to , but
 the drawing is faded out using the <i>alpha</i> value.<br><br>

</dd>
<dt><big><a name="Context.stroke"></a>void <u>stroke</u>();
</big></dt>
<dd>A drawing operator that strokes the current path according to
 the current line width, line join, line cap, and dash settings.
 After , the current path will be cleared from
 the cairo context. See ,
 , , ,
 and .
<br><br>
<b>Note:</b><br>
Degenerate segments and sub-paths are treated specially
 and provide a useful result. These can result in two
 different situations:
<br><br>

 1. Zero-length "on" segments set in cairo_set_dash(). If the
 cap style is CAIRO_LINE_CAP_ROUND or CAIRO_LINE_CAP_SQUARE
 then these segments will be drawn as circular dots or squares
 respectively. In the case of CAIRO_LINE_CAP_SQUARE, the
 orientation of the squares is determined by the direction
 of the underlying path.
<br><br>

 2. A sub-path created by  followed by either a
  or one or more calls to  to
 the same coordinate as the . If the cap style
 is CAIRO_LINE_CAP_ROUND then these sub-paths will be drawn as
 circular dots. Note that in the case of CAIRO_LINE_CAP_SQUARE
 a degenerate sub-path will not be drawn at all, (since the
 correct orientation is indeterminate).
<br><br>

 In no case will a cap style of CAIRO_LINE_CAP_BUTT cause
 anything to be drawn in the case of either degenerate
 segments or sub-paths.<br><br>

</dd>
<dt><big><a name="Context.strokePreserve"></a>void <u>strokePreserve</u>();
</big></dt>
<dd>A drawing operator that strokes the current path according to
 the current line width, line join, line cap, and dash settings.
 Unlike ,  preserves
 the path within the cairo context.
<br><br>
See , ,
 , , and .<br><br>

</dd>
<dt><big><a name="Context.strokeExtends"></a>Box <u>strokeExtends</u>();
</big></dt>
<dd>Computes a bounding box in user coordinates covering the area
 that would be affected, (the "inked" area), by a 
 operation given the current path and stroke parameters. If the
 current path is empty, returns an empty rectangle ((0,0), (0,0)).
 Surface dimensions and clipping are not taken into account.
<br><br>
Note that if the line width is set to exactly zero, then
  will return an empty rectangle.
 Contrast with  which can be used to
 compute the non-empty bounds as the line width approaches zero.
<br><br>

 Note that  must necessarily do more
 work to compute the precise inked areas in light of the
 stroke parameters, so  may be more
 desirable for sake of performance if non-inked path extents
 are desired.
<br><br>

 See , , ,
 , , and .<br><br>

</dd>
<dt><big><a name="Context.inStroke"></a>bool <u>inStroke</u>(Point!double <i>point</i>);
<br>bool <u>inStroke</u>(double <i>x</i>, double <i>y</i>);
</big></dt>
<dd>Tests whether the given <i>point</i> is inside the area that would be
 affected by a cairo_stroke() operation given the current path
 and stroking parameters. Surface dimensions and clipping are
 not taken into account.
<br><br>
See , , ,
 , , and .<br><br>

</dd>
<dt><big><a name="Context.copyPage"></a>void <u>copyPage</u>();
</big></dt>
<dd>Emits the current page for backends that support multiple
 pages, but doesn't clear it, so, the contents of the current
 page will be retained for the next page too.
 Use  if you want to get an empty page after
 the emission.
<br><br>
This is a convenience function that simply calls 
 on this's target.<br><br>

</dd>
<dt><big><a name="Context.showPage"></a>void <u>showPage</u>();
</big></dt>
<dd>Emits and clears the current page for backends that support
 multiple pages. Use  if you don't want to
 clear the page.
<br><br>
This is a convenience function that simply calls
  on this's target.<br><br>

</dd>
<dt><big><a name="Context.copyPath"></a>Path <u>copyPath</u>();
</big></dt>
<dd>Creates a copy of the current path and returns it to the user
 as a . See  for hints on how to
 iterate over the returned data structure.<br><br>

</dd>
<dt><big><a name="Context.copyPathFlat"></a>Path <u>copyPathFlat</u>();
</big></dt>
<dd>Gets a flattened copy of the current path and returns it to
 the user as a . See  for hints
 on how to iterate over the returned data structure.
<br><br>
This function is like  except that any
 curves in the path will be approximated with piecewise-linear
 approximations, (accurate to within the current tolerance value).
 That is, the result is guaranteed to not have any elements of
 type CAIRO_PATH_CURVE_TO which will instead be replaced by
 a series of CAIRO_PATH_LINE_TO elements.<br><br>

</dd>
<dt><big><a name="Context.appendPath"></a>void <u>appendPath</u>(Path <i>p</i>);
</big></dt>
<dd>Append the path onto the current path. The path may be
 the return value from one of  or .<br><br>

</dd>
<dt><big><a name="Context.appendPath.2"></a>void <u>appendPath</u>(cairo_path_t* <i>path</i>);
</big></dt>
<dd><u>appendPath</u> for user created paths. There is no high level API
 for user defined paths. Use  for paths
 which were obtained from cairo.
<br><br>
See  for details
 on how the <i>path</i> data structure should be initialized,
 and note that <i>path</i>.status must be initialized to CAIRO_STATUS_SUCCESS.

<br><br>
<b>Warning:</b><br>
<font color=red>Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</font><br><br>

</dd>
<dt><big><a name="Context.hasCurrentPoint"></a>bool <u>hasCurrentPoint</u>();
</big></dt>
<dd>Returns whether a current point is defined on the current path.
 See  for details on the current point.<br><br>

</dd>
<dt><big><a name="Context.getCurrentPoint"></a>Point!double <u>getCurrentPoint</u>();
</big></dt>
<dd>Gets the current point of the current path, which is conceptually
 the final point reached by the path so far.
<br><br>
The current point is returned in the user-space coordinate system.
 If there is no defined current point or if cr is in an error status,
 x and y will both be set to 0.0. It is possible to check
 this in advance with .
<br><br>

 Most path construction functions alter the current point. See
 the following for details on how they affect the current point:
 , , ,
 , , ,
 , , ,
 , , ,
 , , ,
 .
<br><br>

 Some functions use and alter the current point but do not
 otherwise change current path: .
<br><br>

 Some functions unset the current path and as a result,
 current point: , .<br><br>

</dd>
<dt><big><a name="Context.currentPoint"></a>alias <u>currentPoint</u> = getCurrentPoint;
</big></dt>
<dd>convenience alias<br><br>

</dd>
<dt><big><a name="Context.newPath"></a>void <u>newPath</u>();
</big></dt>
<dd>Clears the current path. After this call there will be no path
 and no current point.<br><br>

</dd>
<dt><big><a name="Context.newSubPath"></a>void <u>newSubPath</u>();
</big></dt>
<dd>Begin a new sub-path. Note that the existing path is not affected.
 After this call there will be no current point.
<br><br>
In many cases, this call is not needed since new sub-paths are
 frequently started with cairo_move_to().
<br><br>

 A call to  is particularly useful when
 beginning a new sub-path with one of the  calls.
 This makes things easier as it is no longer necessary to
 manually compute the arc's initial coordinates for a call
 to .<br><br>

</dd>
<dt><big><a name="Context.closePath"></a>void <u>closePath</u>();
</big></dt>
<dd>Adds a line segment to the path from the current point to
 the beginning of the current sub-path, (the most recent
 point passed to ), and closes this sub-path.
 After this call the current point will be at the joined
 endpoint of the sub-path.
<br><br>
The behavior of  is distinct from simply
 calling  with the equivalent coordinate in
 the case of stroking. When a closed sub-path is stroked,
 there are no caps on the ends of the sub-path. Instead,
 there is a line join connecting the final and initial
 segments of the sub-path.
<br><br>

 If there is no current point before the call to ,
 this function will have no effect.

<br><br>
<b>Note:</b><br>
As of cairo version 1.2.4 any call to 
 will place an explicit MOVE_TO element into the path immediately
 after the CLOSE_PATH element, (which can be seen in
  for example). This can simplify path processing
 in some cases as it may not be necessary to save the "last
 move_to point" during processing as the MOVE_TO immediately
 after the CLOSE_PATH will provide that point.<br><br>

</dd>
<dt><big><a name="Context.arc"></a>void <u>arc</u>(Point!double <i>center</i>, double <i>radius</i>, double <i>angle1</i>, double <i>angle2</i>);
<br>void <u>arc</u>(double <i>centerX</i>, double <i>centerY</i>, double <i>radius</i>, double <i>angle1</i>, double <i>angle2</i>);
</big></dt>
<dd>Adds a circular <u>arc</u> of the given <i>radius</i> to the current path.
 The <u>arc</u> is centered at <i>center</i>, begins at <i>angle1</i> and proceeds in
 the direction of increasing angles to end at <i>angle2</i>.
 If <i>angle2</i> is less than <i>angle1</i> it will be progressively
 increased by 2*PI until it is greater than <i>angle1</i>.
<br><br>
 If there is a current point, an initial line segment will be
 added to the path to connect the current point to the beginning
 of the <u>arc</u>. If this initial line is undesired, it can be
 avoided by calling  before calling .
<br><br>

 Angles are measured in radians. An angle of 0.0 is in the
 direction of the positive X axis (in user space). An angle
 of PI/2.0 radians (90 degrees) is in the direction of the
 positive Y axis (in user space). Angles increase in the
 direction from the positive X axis toward the positive Y
 axis. So with the default transformation matrix, angles
 increase in a clockwise direction.
<br><br>

 (To convert from degrees to radians, use degrees * (PI / 180))
<br><br>

 This function gives the <u>arc</u> in the direction of increasing angles;
 see  to get the <u>arc</u> in the direction of decreasing angles.
<br><br>

 The <u>arc</u> is circular in user space. To achieve an elliptical <u>arc</u>,
 you can scale the current transformation matrix by different
 amounts in the X and Y directions. For example, to draw an
 ellipse in the box given by x, y, width, height:
<pre class="d_code">cr.save();
cr.translate(x + width / 2, y + height / 2);
cr.scale(width / 2, height / 2);
cr.<u>arc</u>(Point(0, 0), 1, 0, 2 * PI);
cr.restore();
</pre>
<br><br>
<b>Params:</b><br>
<table><tr><td>double <i>radius</i></td>
<td>the <i>radius</i> of the <u>arc</u></td></tr>
<tr><td>double <i>angle1</i></td>
<td>the start angle, in radians</td></tr>
<tr><td>double <i>angle2</i></td>
<td>the end angle, in radians</td></tr>
</table><br>

</dd>
<dt><big><a name="Context.arcNegative"></a>void <u>arcNegative</u>(Point!double <i>center</i>, double <i>radius</i>, double <i>angle1</i>, double <i>angle2</i>);
<br>void <u>arcNegative</u>(double <i>centerX</i>, double <i>centerY</i>, double <i>radius</i>, double <i>angle1</i>, double <i>angle2</i>);
</big></dt>
<dd>Adds a circular arc of the given <i>radius</i> to the current path.
 The arc is centered at <i>center</i>, begins at <i>angle1</i> and proceeds
 in the direction of decreasing angles to end at <i>angle2</i>.
 If <i>angle2</i> is greater than <i>angle1</i> it will be progressively
 decreased by 2*PI until it is less than <i>angle1</i>.
<br><br>
See  for more details. This function differs only
 in the direction of the arc between the two angles.

<br><br>
<b>Params:</b><br>
<table><tr><td>double <i>radius</i></td>
<td>the <i>radius</i> of the arc</td></tr>
<tr><td>double <i>angle1</i></td>
<td>the start angle, in radians</td></tr>
<tr><td>double <i>angle2</i></td>
<td>the end angle, in radians</td></tr>
</table><br>

</dd>
<dt><big><a name="Context.curveTo"></a>void <u>curveTo</u>(Point!double <i>p1</i>, Point!double <i>p2</i>, Point!double <i>p3</i>);
<br>void <u>curveTo</u>(double <i>p1x</i>, double <i>p1y</i>, double <i>p2x</i>, double <i>p2y</i>, double <i>p3x</i>, double <i>p3y</i>);
</big></dt>
<dd>Adds a cubic Bzier spline to the path from the current
 point to position <i>p3</i> in user-space coordinates, using <i>p1</i> and <i>p2</i>
 as the control points. After this call the current point will be <i>p3</i>.
<br><br>
If there is no current point before the call to 
 this function will behave as if preceded by a call to
 .

<br><br>
<b>Params:</b><br>
<table><tr><td>Point!double <i>p1</i></td>
<td>First control point</td></tr>
<tr><td>Point!double <i>p2</i></td>
<td>Second control point</td></tr>
<tr><td>Point!double <i>p3</i></td>
<td>End of the curve</td></tr>
</table><br>

</dd>
<dt><big><a name="Context.lineTo"></a>void <u>lineTo</u>(Point!double <i>p1</i>);
<br>void <u>lineTo</u>(double <i>x</i>, double <i>y</i>);
</big></dt>
<dd>Adds a line to the path from the current point to position <i>p1</i>
 in user-space coordinates. After this call the current point
 will be <i>p1</i>.
<br><br>
If there is no current point before the call to 
 this function will behave as .

<br><br>
<b>Params:</b><br>
<table><tr><td>Point!double <i>p1</i></td>
<td>End of the line</td></tr>
</table><br>

</dd>
<dt><big><a name="Context.moveTo"></a>void <u>moveTo</u>(Point!double <i>p1</i>);
<br>void <u>moveTo</u>(double <i>x</i>, double <i>y</i>);
</big></dt>
<dd>Begin a new sub-path. After this call the current point will be <i>p1</i>.<br><br>

</dd>
<dt><big><a name="Context.rectangle"></a>void <u>rectangle</u>(Rectangle!double <i>r</i>);
<br>void <u>rectangle</u>(double <i>x</i>, double <i>y</i>, double <i>width</i>, double <i>height</i>);
</big></dt>
<dd> Adds a closed sub-path <u>rectangle</u> of the given size to the
 current path at position <i>r</i>.point in user-space coordinates.
 This function is logically equivalent to:
<pre class="d_code">cr.moveTo(<i>r</i>.point);
cr.relLineTo(<i>r</i>.<i>width</i>, 0);
cr.relLineTo(0, <i>r</i>.<i>height</i>);
cr.relLineTo(-<i>r</i>.<i>width</i>, 0);
cr.closePath();
</pre>
<br><br>

</dd>
<dt><big><a name="Context.glyphPath"></a>void <u>glyphPath</u>(Glyph[] <i>glyphs</i>);
</big></dt>
<dd>Adds closed paths for the <i>glyphs</i> to the current path.
 The generated path if filled, achieves an effect
 similar to that of .<br><br>

</dd>
<dt><big><a name="Context.textPath"></a>void <u>textPath</u>(string <i>text</i>);
</big></dt>
<dd>Adds closed paths for <i>text</i> to the current path. The generated
 path if filled, achieves an effect similar to that of
 .
<br><br>
Text conversion and positioning is done similar to .
<br><br>

 Like , After this call the current point is moved
 to the origin of where the next glyph would be placed in this
 same progression. That is, the current point will be at the
 origin of the final glyph offset by its advance values. This
 allows for chaining multiple calls to to 
 without having to set current point in between.

<br><br>
<b>Note:</b><br>
The  function call is part of what the
 cairo designers call the "toy" <i>text</i> API. It is convenient for
 short demos and simple programs, but it is not expected
 to be adequate for serious <i>text</i>-using applications. See
  for the "real" <i>text</i> path API in cairo.<br><br>

</dd>
<dt><big><a name="Context.relCurveTo"></a>void <u>relCurveTo</u>(Point!double <i>rp1</i>, Point!double <i>rp2</i>, Point!double <i>rp3</i>);
<br>void <u>relCurveTo</u>(double <i>rp1x</i>, double <i>rp1y</i>, double <i>rp2x</i>, double <i>rp2y</i>, double <i>rp3x</i>, double <i>rp3y</i>);
</big></dt>
<dd>Relative-coordinate version of .
 All offsets are relative to the current point. Adds a
 cubic Bzier spline to the path from the current point
 to a point offset from the current point by <i>rp3</i>,
 using points offset by <i>rp1</i> and <i>rp2</i> as the
 control points. After this call the current point will
 be offset by <i>rp3</i>.
<br><br>
Given a current point of (x, y),
 cairo_rel_curve_to(cr, dx1, dy1, dx2, dy2, dx3, dy3) is logically
 equivalent to
 cairo_curve_to(cr, x+dx1, y+dy1, x+dx2, y+dy2, x+dx3, y+dy3).
<br><br>

 It is an error to call this function with no current point.
 Doing so will cause an CairoException with a
 status of CAIRO_STATUS_NO_CURRENT_POINT.

<br><br>
<b>Params:</b><br>
<table><tr><td>Point!double <i>rp1</i></td>
<td>First control point</td></tr>
<tr><td>Point!double <i>rp2</i></td>
<td>Second control point</td></tr>
<tr><td>Point!double <i>rp3</i></td>
<td>offset to the end of the curve</td></tr>
</table><br>

</dd>
<dt><big><a name="Context.relLineTo"></a>void <u>relLineTo</u>(Point!double <i>rp1</i>);
<br>void <u>relLineTo</u>(double <i>x</i>, double <i>y</i>);
</big></dt>
<dd>Relative-coordinate version of . Adds a line
 to the path from the current point to a point that is
 offset from the current point by <i>rp1</i> in user space.
 After this call the current point will be offset by <i>rp1</i>.
<br><br>
Given a current point of (<i>x</i>, <i>y</i>), cairo_rel_line_to(cr, dx, dy)
 is logically equivalent to cairo_line_to(cr, <i>x</i> + dx, <i>y</i> + dy).
<br><br>

 It is an error to call this function with no current point.
 Doing so will cause an CairoException with a
 status of CAIRO_STATUS_NO_CURRENT_POINT.<br><br>

</dd>
<dt><big><a name="Context.relMoveTo"></a>void <u>relMoveTo</u>(Point!double <i>rp1</i>);
<br>void <u>relMoveTo</u>(double <i>x</i>, double <i>y</i>);
</big></dt>
<dd>Begin a new sub-path. After this call the current point will
 offset by <i>rp1</i>.
<br><br>
Given a current point of (<i>x</i>, <i>y</i>), cairo_rel_move_to(cr, dx, dy)
 is logically equivalent to cairo_move_to(cr, <i>x</i> + dx, <i>y</i> + dy).
<br><br>

 It is an error to call this function with no current point.
 Doing so will cause an CairoException with a status of
 CAIRO_STATUS_NO_CURRENT_POINT.<br><br>

</dd>
<dt><big><a name="Context.pathExtends"></a>Box <u>pathExtends</u>();
</big></dt>
<dd>Computes a bounding box in user-space coordinates covering
 the points on the current path. If the current path is empty,
 returns an empty Box ((0,0), (0,0)). Stroke parameters,
 fill rule, surface dimensions and clipping are not taken
 into account.
<br><br>
Contrast with  and 
 which return the extents of only the area that would be "inked"
 by the corresponding drawing operations.
<br><br>

 The result of  is defined as equivalent
 to the limit of  with CAIRO_LINE_CAP_ROUND
 as the line width approaches 0.0, (but never reaching the
 empty-rectangle returned by  for a
 line width of 0.0).
<br><br>

 Specifically, this means that zero-area sub-paths such as
 ; segments, (even degenerate
 cases where the coordinates to both calls are identical),
 will be considered as contributing to the extents. However,
 a lone  will not contribute to the
 results of .<br><br>

</dd>
<dt><big><a name="Context.translate"></a>void <u>translate</u>(double <i>tx</i>, double <i>ty</i>);
</big></dt>
<dd>Modifies the current transformation matrix (CTM) by translating
 the user-space origin by (<i>tx</i>, <i>ty</i>). This offset is interpreted
 as a user-space coordinate according to the CTM in place
 before the new call to . In other words,
 the translation of the user-space origin takes place
 after any existing transformation.
<br><br>
<b>Params:</b><br>
<table><tr><td>double <i>tx</i></td>
<td>amount to <u>translate</u> in the X direction</td></tr>
<tr><td>double <i>ty</i></td>
<td>amount to <u>translate</u> in the Y direction</td></tr>
</table><br>

</dd>
<dt><big><a name="Context.scale"></a>void <u>scale</u>(double <i>sx</i>, double <i>sy</i>);
<br>void <u>scale</u>(Point!double <i>point</i>);
</big></dt>
<dd>Modifies the current transformation matrix (CTM) by scaling
 the X and Y user-space axes by <i>sx</i> and <i>sy</i> respectively.
 The scaling of the axes takes place after any existing
 transformation of user space.
<br><br>
<b>Params:</b><br>
<table><tr><td>double <i>sx</i></td>
<td><u>scale</u> factor for the X dimension</td></tr>
<tr><td>double <i>sy</i></td>
<td><u>scale</u> factor for the Y dimension</td></tr>
</table><br>

</dd>
<dt><big><a name="Context.rotate"></a>void <u>rotate</u>(double <i>angle</i>);
</big></dt>
<dd>Modifies the current transformation matrix (CTM) by rotating
 the user-space axes by <i>angle</i> radians. The rotation of the
 axes takes places after any existing transformation of user
 space. The rotation direction for positive angles is from
 the positive X axis toward the positive Y axis.
<br><br>
<b>Params:</b><br>
<table><tr><td>double <i>angle</i></td>
<td><i>angle</i> (in radians) by which the user-space axes will be rotated</td></tr>
</table><br>

</dd>
<dt><big><a name="Context.transform"></a>void <u>transform</u>(const Matrix <i>matrix</i>);
</big></dt>
<dd>Modifies the current transformation <i>matrix</i> (CTM) by applying
 <i>matrix</i> as an additional transformation. The new
 transformation of user space takes place after any
 existing transformation.
<br><br>
<b>Params:</b><br>
<table><tr><td>Matrix <i>matrix</i></td>
<td>a transformation to be applied to the user-space axes</td></tr>
</table><br>

</dd>
<dt><big><a name="Context.setMatrix"></a>void <u>setMatrix</u>(const Matrix <i>matrix</i>);
</big></dt>
<dd>Modifies the current transformation <i>matrix</i> (CTM) by setting it
 equal to <i>matrix</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>Matrix</td>
<td>a transformation <i>matrix</i> from user space to device space</td></tr>
</table><br>

</dd>
<dt><big><a name="Context.getMatrix"></a>Matrix <u>getMatrix</u>();
</big></dt>
<dd>Returns the current transformation matrix (CTM)<br><br>

</dd>
<dt><big><a name="Context.matrix"></a>@property void <u>matrix</u>(const Matrix <u>matrix</u>);
<br>@property Matrix <u>matrix</u>();
</big></dt>
<dd>Convenience property<br><br>

</dd>
<dt><big><a name="Context.identityMatrix"></a>void <u>identityMatrix</u>();
</big></dt>
<dd>Resets the current transformation matrix (CTM) by setting it
 equal to the identity matrix. That is, the user-space and
 device-space axes will be aligned and one user-space unit
 will transform to one device-space unit.<br><br>

</dd>
<dt><big><a name="Context.userToDevice"></a>Point!double <u>userToDevice</u>(Point!double <i>inp</i>);
</big></dt>
<dd>Transform a coordinate from user space to device space by
 multiplying the given point by the current
 transformation matrix (CTM).<br><br>

</dd>
<dt><big><a name="Context.userToDeviceDistance"></a>Point!double <u>userToDeviceDistance</u>(Point!double <i>inp</i>);
</big></dt>
<dd>Transform a distance vector from user space to device space.
 This function is similar to  except that
 the translation components of the CTM will be ignored when
 transforming <i>inp</i>.<br><br>

</dd>
<dt><big><a name="Context.deviceToUser"></a>Point!double <u>deviceToUser</u>(Point!double <i>inp</i>);
</big></dt>
<dd>Transform a coordinate from device space to user space by
 multiplying the given point by the inverse of the current
 transformation matrix (CTM).<br><br>

</dd>
<dt><big><a name="Context.deviceToUserDistance"></a>Point!double <u>deviceToUserDistance</u>(Point!double <i>inp</i>);
</big></dt>
<dd>Transform a distance vector from device space to user space.
 This function is similar to  except that
 the translation components of the inverse CTM will be ignored
 when transforming <i>inp</i>.<br><br>

</dd>
<dt><big><a name="Context.selectFontFace"></a>void <u>selectFontFace</u>(string <i>family</i>, FontSlant <i>slant</i>, FontWeight <i>weight</i>);
</big></dt>
<dd><b>Note:</b><br>
The  function call is part of
 what the cairo designers call the "toy" text API. It
 is convenient for short demos and simple programs, but
 it is not expected to be adequate for serious text-using
 applications.
<br><br>

 Selects a <i>family</i> and style of font from a simplified description
 as a <i>family</i> name, <i>slant</i> and <i>weight</i>. Cairo provides no
 operation to list available <i>family</i> names on the system
 (this is a "toy", remember), but the standard CSS2 generic
 <i>family</i> names, ("serif", "sans-serif", "cursive", "fantasy",
 "monospace"), are likely to work as expected.
<br><br>

 If <i>family</i> starts with the string "cairo:", or if no native
 font backends are compiled in, cairo will use an internal
 font <i>family</i>. The internal font <i>family</i> recognizes many
 modifiers in the <i>family</i> string, most notably, it recognizes
 the string "monospace". That is, the <i>family</i> name
 "cairo:monospace" will use the monospace version of the
 internal font <i>family</i>.
<br><br>

 For "real" font selection, see the font-backend-specific
  classes for the font backend you are using.
 (For example, if you are using the freetype-based cairo-ft
 font backend, see )
<br><br>

 The resulting font face could then be used
 with  and .
<br><br>

 Similarly, when using the "real" font support, you can call
 directly into the underlying font system, (such as
 fontconfig or freetype), for operations such as listing
 available fonts, etc.
<br><br>

 It is expected that most applications will need to use a more
 comprehensive font handling and text layout library,
 (for example, pango), in conjunction with cairo.
<br><br>

 If text is drawn without a call to ,
 (nor  nor ),
 the default <i>family</i> is platform-specific, but is essentially
 "sans-serif". Default <i>slant</i> is CAIRO_FONT_SLANT_NORMAL,
 and default <i>weight</i> is CAIRO_FONT_WEIGHT_NORMAL.
<br><br>

 This function is equivalent to a call to
  followed by .

<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>family</i></td>
<td>a font <i>family</i> name, encoded in UTF-8</td></tr>
<tr><td>FontSlant <i>slant</i></td>
<td>the <i>slant</i> for the font</td></tr>
<tr><td>FontWeight <i>weight</i></td>
<td>the <i>weight</i> for the font</td></tr>
</table><br>

</dd>
<dt><big><a name="Context.setFontSize"></a>void <u>setFontSize</u>(double <i>size</i>);
</big></dt>
<dd>Sets the current font matrix to a scale by a factor of <i>size</i>,
 replacing any font matrix previously set with 
 or . This results in a font <i>size</i> of
 <i>size</i> user space units. (More precisely, this matrix will
 result in the font's em-square being a <i>size</i> by <i>size</i>
 square in user space.)
<br><br>
If text is drawn without a call to ,
 (nor  nor ),
 the default font <i>size</i> is 10.0.

<br><br>
<b>Params:</b><br>
<table><tr><td>double <i>size</i></td>
<td>the new font <i>size</i>, in user space units</td></tr>
</table><br>

</dd>
<dt><big><a name="Context.setFontMatrix"></a>void <u>setFontMatrix</u>(Matrix <i>matrix</i>);
</big></dt>
<dd>Sets the current font <i>matrix</i> to <i>matrix</i>. The font <i>matrix</i> gives
 a transformation from the design space of the font (in this
 space, the em-square is 1 unit by 1 unit) to user space.
 Normally, a simple scale is used (see ),
 but a more complex font <i>matrix</i> can be used to shear the font
 or stretch it unequally along the two axes
<br><br>
<b>Params:</b><br>
<table><tr><td>Matrix <i>matrix</i></td>
<td>a  describing a transform to be applied
 to the current font.</td></tr>
</table><br>

</dd>
<dt><big><a name="Context.getFontMatrix"></a>Matrix <u>getFontMatrix</u>();
</big></dt>
<dd>Returns the current font matrix. See .<br><br>

</dd>
<dt><big><a name="Context.fontMatrix"></a>@property void <u>fontMatrix</u>(Matrix <i>matrix</i>);
<br>@property Matrix <u>fontMatrix</u>();
</big></dt>
<dd>Convenience property<br><br>

</dd>
<dt><big><a name="Context.setFontOptions"></a>void <u>setFontOptions</u>(FontOptions <i>options</i>);
</big></dt>
<dd>Sets a set of custom font rendering <i>options</i> for the
 . Rendering <i>options</i> are derived by merging these
 <i>options</i> with the <i>options</i> derived from underlying surface;
 if the value in <i>options</i> has a default value (like CAIRO_ANTIALIAS_DEFAULT),
 then the value from the surface is used.<br><br>

</dd>
<dt><big><a name="Context.getFontOptions"></a>FontOptions <u>getFontOptions</u>();
</big></dt>
<dd>Retrieves font rendering options set via .
 Note that the returned options do not include any options
 derived from the underlying surface; they are literally
 the options passed to .<br><br>

</dd>
<dt><big><a name="Context.fontOptions"></a>@property void <u>fontOptions</u>(FontOptions <i>options</i>);
<br>@property FontOptions <u>fontOptions</u>();
</big></dt>
<dd>Convenience property<br><br>

</dd>
<dt><big><a name="Context.setFontFace"></a>void <u>setFontFace</u>(FontFace <i>font_face</i>);
</big></dt>
<dd>Replaces the current  object in the 
 with <i>font_face</i>. The replaced font face in the  will
 be destroyed if there are no other references to it.<br><br>

</dd>
<dt><big><a name="Context.setFontFace.2"></a>void <u>setFontFace</u>();
</big></dt>
<dd>Replaces the current  object in the 
 with the default font.<br><br>

</dd>
<dt><big><a name="Context.resetFontFace"></a>alias <u>resetFontFace</u> = setFontFace;
</big></dt>
<dd>convenience alias<br><br>

</dd>
<dt><big><a name="Context.getFontFace"></a>FontFace <u>getFontFace</u>();
</big></dt>
<dd>Gets the current font face for a .<br><br>

</dd>
<dt><big><a name="Context.fontFace"></a>@property void <u>fontFace</u>(FontFace <i>font_face</i>);
<br>@property FontFace <u>fontFace</u>();
</big></dt>
<dd>Convenience property<br><br>

</dd>
<dt><big><a name="Context.setScaledFont"></a>void <u>setScaledFont</u>(ScaledFont <i>scaled_font</i>);
</big></dt>
<dd>Replaces the current font face, font matrix, and font options
 in the  with those of the . Except
 for some translation, the current CTM of the cairo_t should be
 the same as that of the , which can be
 accessed using .<br><br>

</dd>
<dt><big><a name="Context.getScaledFont"></a>ScaledFont <u>getScaledFont</u>();
</big></dt>
<dd>Gets the current scaled font for a .<br><br>

</dd>
<dt><big><a name="Context.scaledFont"></a>@property void <u>scaledFont</u>(ScaledFont <i>scaled_font</i>);
<br>@property ScaledFont <u>scaledFont</u>();
</big></dt>
<dd>Convenience property<br><br>

</dd>
<dt><big><a name="Context.showText"></a>void <u>showText</u>(string <i>text</i>);
</big></dt>
<dd>A drawing operator that generates the shape from a string of
 UTF-8 characters, rendered according to the current
 fontFace, fontSize (fontMatrix), and fontOptions.
<br><br>
This function first computes a set of glyphs for the string
 of <i>text</i>. The first glyph is placed so that its origin is
 at the current point. The origin of each subsequent glyph
 is offset from that of the previous glyph by the advance
 values of the previous glyph.
<br><br>

 After this call the current point is moved to the origin
 of where the next glyph would be placed in this same
 progression. That is, the current point will be at the
 origin of the final glyph offset by its advance values.
 This allows for easy display of a single logical string
 with multiple calls to .

<br><br>
<b>Note:</b><br>
The  function call is part of
 what the cairo designers call the "toy" <i>text</i> API. It
 is convenient for short demos and simple programs, but
 it is not expected to be adequate for serious <i>text</i>-using
 applications. See  for the "real" <i>text</i>
 display API in cairo.<br><br>

</dd>
<dt><big><a name="Context.showGlyphs"></a>void <u>showGlyphs</u>(Glyph[] <i>glyphs</i>);
</big></dt>
<dd>A drawing operator that generates the shape from an array of
 <i>glyphs</i>, rendered according to the current fontFace,
 fontSize (fontMatrix), and font options.<br><br>

</dd>
<dt><big><a name="Context.showTextGlyphs"></a>void <u>showTextGlyphs</u>(TextGlyph <i>glyph</i>);
</big></dt>
<dd>This operation has rendering effects similar to 
 but, if the target surface supports it, uses the provided
 text and cluster mapping to embed the text for the glyphs
 shown in the output. If the target does not support the
 extended attributes, this function acts like the basic
 .<br><br>

</dd>
<dt><big><a name="Context.fontExtents"></a>FontExtents <u>fontExtents</u>();
</big></dt>
<dd>Gets the font extents for the currently selected font.<br><br>

</dd>
<dt><big><a name="Context.textExtents"></a>TextExtents <u>textExtents</u>(string <i>text</i>);
</big></dt>
<dd>Gets the extents for a string of <i>text</i>. The extents describe
 a user-space rectangle that encloses the "inked"
 portion of the <i>text</i>, (as it would be drawn by ).
 Additionally, the x_advance and y_advance values indicate
 the amount by which the current point would be advanced
 by .
<br><br>
Note that whitespace characters do not directly contribute
 to the size of the rectangle (extents.width and extents.height).
 They do contribute indirectly by changing the position of
 non-whitespace characters. In particular, trailing whitespace
 characters are likely to not affect the size of the rectangle,
 though they will affect the x_advance and y_advance values.<br><br>

</dd>
<dt><big><a name="Context.glyphExtents"></a>TextExtents <u>glyphExtents</u>(Glyph[] <i>glyphs</i>);
</big></dt>
<dd>Gets the extents for an array of <i>glyphs</i>. The extents describe
 a user-space rectangle that encloses the "inked" portion of
 the <i>glyphs</i>, (as they would be drawn by ).
 Additionally, the x_advance and y_advance values indicate
 the amount by which the current point would be advanced by
 .
<br><br>
Note that whitespace <i>glyphs</i> do not contribute to the size of
 the rectangle (extents.width and extents.height).<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="FontOptions"></a>struct <u>FontOptions</u>;
</big></dt>
<dd> - How a font should be rendered
<br><br>
The font options specify how fonts should be rendered. Most of the
 time the font options implied by a surface are just right and do
 not need any changes, but for pixel-based targets tweaking font
 options may result in superior output on a particular display.

<br><br>
<b>Warning:</b><br>
 Instances must be created with the create static member function!
<pre class="d_code"><font color=blue>auto</font> options = <u>FontOptions</u>.create(); <font color=green>//Correct
</font>options.toHash();
</pre>
<br><br>

<pre class="d_code"><u>FontOptions</u> options; <font color=green>//Wrong
</font>options.toHash();
</pre>
<br><br>

<pre class="d_code"><u>FontOptions</u> options;
options = <u>FontOptions</u>.create(); <font color=green>//Correct
</font>options.toHash();
</pre>
<br><br>

<dl><dt><big><a name="FontOptions.nativePointer"></a>@property cairo_font_options_t* <u>nativePointer</u>();
</big></dt>
<dd>The underlying  handle<br><br>

</dd>
<dt><big><a name="FontOptions.debugging"></a>@property bool <u>debugging</u>();
<br>@property void <u>debugging</u>(bool <i>value</i>);
</big></dt>
<dd>Enable / disable memory management <u>debugging</u> for this FontOptions
 instance. Only available if both cairoD and the cairoD user
 code were compiled with "debug=RefCounted"
<br><br>
Output is written to stdout, see
 <a href="https://github.com/jpf91/cairoD/wiki/Memory-Management#debugging">https://github.com/jpf91/cairoD/wiki/Memory-Management#debugging</a>
 for more information<br><br>

</dd>
<dt><big><a name="FontOptions.create"></a>static FontOptions <u>create</u>();
</big></dt>
<dd>Allocates a new font options object with all
 options initialized to default values.<br><br>

</dd>
<dt><big><a name="FontOptions.this"></a>this(cairo_font_options_t* <i>ptr</i>);
</big></dt>
<dd>Create  from a existing .
 FontOptions is a reference counted struct. It will call
  when it's reference count is 0.
 See <a href="https://github.com/jpf91/cairoD/wiki/Memory-Management#2.2-structs">https://github.com/jpf91/cairoD/wiki/Memory-Management#2.2-structs</a>
 for more information.
<br><br>
<b>Warning:</b><br>
<font color=red>Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</font><br><br>

</dd>
<dt><big><a name="FontOptions.copy"></a>FontOptions <u>copy</u>();
</big></dt>
<dd>Allocates a new font options object copying the option values
 from original.
<br><br>
This new object's reference counting is independent from the
 current object's.<br><br>

</dd>
<dt><big><a name="FontOptions.merge"></a>void <u>merge</u>(FontOptions <i>other</i>);
</big></dt>
<dd>Merges non-default options from <i>other</i> into this object,
 replacing existing values. This operation can be thought
 of as somewhat similar to compositing <i>other</i> onto options
 with the operation of CAIRO_OPERATION_OVER.<br><br>

</dd>
<dt><big><a name="FontOptions.toHash"></a>size_t <u>toHash</u>();
</big></dt>
<dd>Compute a hash for the font options object; this value
 will be useful when storing an object containing a
 FontOptions in a hash table.<br><br>

</dd>
<dt><big><a name="FontOptions.opEquals"></a>const bool <u>opEquals</u>(ref const(FontOptions) <i>other</i>);
</big></dt>
<dd>Compares two font options objects for equality.
<br><br>
<b>Returns:</b><br>
<b>true</b> if all fields of the two font options objects match.
 Note that this function will return <b>false</b> if either object is
 in error.<br><br>

</dd>
<dt><big><a name="FontOptions.setAntiAlias"></a>void <u>setAntiAlias</u>(AntiAlias <i>antialias</i>);
</big></dt>
<dd>Sets the antialiasing mode for the font options object. This
 specifies the type of antialiasing to do when rendering text.<br><br>

</dd>
<dt><big><a name="FontOptions.getAntiAlias"></a>AntiAlias <u>getAntiAlias</u>();
</big></dt>
<dd>Gets the antialiasing mode for the font options object.<br><br>

</dd>
<dt><big><a name="FontOptions.antiAlias"></a>@property void <u>antiAlias</u>(AntiAlias <i>aa</i>);
<br>@property AntiAlias <u>antiAlias</u>();
</big></dt>
<dd>Convenience property<br><br>

</dd>
<dt><big><a name="FontOptions.setSubpixelOrder"></a>void <u>setSubpixelOrder</u>(SubpixelOrder <i>order</i>);
</big></dt>
<dd>Sets the subpixel <i>order</i> for the font options object.
 The subpixel <i>order</i> specifies the <i>order</i> of color elements
 within each pixel on the display device when rendering with
 an antialiasing mode of CAIRO_ANTIALIAS_SUBPIXEL.
 See the documentation for  for full details.<br><br>

</dd>
<dt><big><a name="FontOptions.getSubpixelOrder"></a>SubpixelOrder <u>getSubpixelOrder</u>();
</big></dt>
<dd>Gets the subpixel order for the font options object.
 See the documentation for  for full details.<br><br>

</dd>
<dt><big><a name="FontOptions.subpixelOrder"></a>alias <u>subpixelOrder</u> = getSubpixelOrder;
</big></dt>
<dd>convenience alias<br><br>

</dd>
<dt><big><a name="FontOptions.setHintStyle"></a>void <u>setHintStyle</u>(HintStyle <i>style</i>);
</big></dt>
<dd>Sets the hint <i>style</i> for font outlines for the font options object.
 This controls whether to fit font outlines to the pixel grid,
 and if so, whether to optimize for fidelity or contrast.
 See the documentation for  for full details.<br><br>

</dd>
<dt><big><a name="FontOptions.getHintStyle"></a>HintStyle <u>getHintStyle</u>();
</big></dt>
<dd>Gets the hint style for font outlines for the font options object.
 See the documentation for  for full details.<br><br>

</dd>
<dt><big><a name="FontOptions.hintStyle"></a>@property void <u>hintStyle</u>(HintStyle <i>style</i>);
<br>@property HintStyle <u>hintStyle</u>();
</big></dt>
<dd>Convenience property<br><br>

</dd>
<dt><big><a name="FontOptions.setHintMetrics"></a>void <u>setHintMetrics</u>(HintMetrics <i>metrics</i>);
</big></dt>
<dd>Sets the <i>metrics</i> hinting mode for the font options object.
 This controls whether <i>metrics</i> are quantized to integer
 values in device units. See the documentation for
  for full details.<br><br>

</dd>
<dt><big><a name="FontOptions.getHintMetrics"></a>HintMetrics <u>getHintMetrics</u>();
</big></dt>
<dd>Gets the metrics hinting mode for the font options object.
 See the documentation for  for full details.<br><br>

</dd>
<dt><big><a name="FontOptions.hintMetrics"></a>@property void <u>hintMetrics</u>(HintMetrics <i>metrics</i>);
<br>@property HintMetrics <u>hintMetrics</u>();
</big></dt>
<dd>Convenience property<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="TextGlyph"></a>struct <u>TextGlyph</u>;
</big></dt>
<dd>The mapping between utf8 and glyphs is provided by an array
 of clusters. Each cluster covers a number of text bytes and
 glyphs, and neighboring clusters cover neighboring areas of
 utf8 and glyphs. The clusters should collectively cover
 utf8 and glyphs in entirety.
<br><br>
The first cluster always covers bytes from the beginning of
 utf8. If cluster_flags do not have the
 CAIRO_TEXT_CLUSTER_FLAG_BACKWARD set, the first cluster also
 covers the beginning of glyphs, otherwise it covers the end
 of the glyphs array and following clusters move backward.
<br><br>

 See cairo_text_cluster_t for constraints on valid clusters.<br><br>

<dl><dt><big><a name="TextGlyph.glyphs"></a>Glyph[] <u>glyphs</u>;
</big></dt>
<dd>array of <u>glyphs</u><br><br>

</dd>
<dt><big><a name="TextGlyph.cluster"></a>TextCluster[] <u>cluster</u>;
</big></dt>
<dd>array of <u>cluster</u> mapping information<br><br>

</dd>
<dt><big><a name="TextGlyph.text"></a>string <u>text</u>;
</big></dt>
<dd>a string of <u>text</u> encoded in UTF-8<br><br>

</dd>
<dt><big><a name="TextGlyph.flags"></a>TextClusterFlags <u>flags</u>;
</big></dt>
<dd>cluster mapping <u>flags</u><br><br>

</dd>
</dl>
</dd>
<dt><big><a name="ScaledFont"></a>class <u>ScaledFont</u>;
</big></dt>
<dd>Font face at particular size and options
<br><br>
 represents a realization of a font face at a particular
 size and transformation and a certain set of font options.<br><br>

<dl><dt><big><a name="ScaledFont._count"></a>@property uint <u>_count</u>();
</big></dt>
<dd>Reference count. For use in child classes<br><br>

</dd>
<dt><big><a name="ScaledFont._reference"></a>void <u>_reference</u>();
</big></dt>
<dd>Increase reference count. For use in child classes<br><br>

</dd>
<dt><big><a name="ScaledFont._dereference"></a>void <u>_dereference</u>();
</big></dt>
<dd>Decrease reference count. For use in child classes<br><br>

</dd>
<dt><big><a name="ScaledFont.nativePointer"></a>T <u>nativePointer</u>;
</big></dt>
<dd>The underlying  handle<br><br>

</dd>
<dt><big><a name="ScaledFont.debugging"></a>bool <u>debugging</u>;
</big></dt>
<dd>Enable / disable memory management <u>debugging</u> for this
 instance. Only available if both cairoD and the cairoD user
 code were compiled with "debug=RefCounted"
<br><br>
Output is written to stdout, see
 <a href="https://github.com/jpf91/cairoD/wiki/Memory-Management#debugging">https://github.com/jpf91/cairoD/wiki/Memory-Management#debugging</a>
 for more information<br><br>

</dd>
<dt><big><a name="ScaledFont.dispose"></a>void <u>dispose</u>();
</big></dt>
<dd>Explicitly drecrease the reference count.
<br><br>
See <a href="https://github.com/jpf91/cairoD/wiki/Memory-Management#3-RC-class">https://github.com/jpf91/cairoD/wiki/Memory-Management#3-RC-class</a>
 for more information.<br><br>

</dd>
<dt><big><a name="ScaledFont.checkError"></a>protected final void <u>checkError</u>();
</big></dt>
<dd>Method for use in subclasses.
 Calls  and throws
 an exception if the status isn't CAIRO_STATUS_SUCCESS<br><br>

</dd>
<dt><big><a name="ScaledFont.this"></a>this(cairo_scaled_font_t* <i>ptr</i>);
</big></dt>
<dd>Create a  from a existing .
 ScaledFont is a garbage collected class. It will call 
 when it gets collected by the GC or when  is called.
<br><br>
<b>Warning:</b><br>
's reference count is not increased by this function!
 Adjust reference count before calling it if necessary
<br><br>

 <font color=red>Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</font><br><br>

</dd>
<dt><big><a name="ScaledFont.this.2"></a>this(FontFace <i>font_face</i>, Matrix <i>font_matrix</i>, Matrix <i>ctm</i>, FontOptions <i>options</i>);
</big></dt>
<dd>Creates a  object from a font face and
 matrices that describe the size of the font and the
 environment in which it will be used.
<br><br>
<b>Params:</b><br>
<table><tr><td>Matrix <i>font_matrix</i></td>
<td>font space to user space transformation matrix
   for the font. In the simplest case of a N point font, this
   matrix is just a scale by N, but it can also be used to
   shear the font or stretch it unequally along the two axes.
   See .</td></tr>
<tr><td>Matrix <i>ctm</i></td>
<td>user to device transformation matrix with which
   the font will be used.</td></tr>
</table><br>

</dd>
<dt><big><a name="ScaledFont.createFromNative"></a>static ScaledFont <u>createFromNative</u>(cairo_scaled_font_t* <i>ptr</i>, bool <i>adjRefCount</i> = true);
</big></dt>
<dd>The <u>createFromNative</u> method for the ScaledFont classes.
 See <a href="https://github.com/jpf91/cairoD/wiki/Memory-Management#createFromNative">https://github.com/jpf91/cairoD/wiki/Memory-Management#createFromNative</a>
 for more information.
<br><br>
<b>Warning:</b><br>
<font color=red>Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</font><br><br>

</dd>
<dt><big><a name="ScaledFont.extents"></a>FontExtents <u>extents</u>();
</big></dt>
<dd>Gets the metrics for a .<br><br>

</dd>
<dt><big><a name="ScaledFont.textExtents"></a>TextExtents <u>textExtents</u>(string <i>text</i>);
</big></dt>
<dd>Gets the extents for a string of <i>text</i>. The extents describe a
 user-space rectangle that encloses the "inked" portion of the
 <i>text</i> drawn at the origin (0,0) (as it would be drawn by
  if the cairo graphics state were set
 to the same fontFace, fontMatrix, ctm, and fontOptions
 as ). Additionally, the x_advance and y_advance
 values indicate the amount by which the current point would
 be advanced by .
<br><br>
Note that whitespace characters do not directly contribute
 to the size of the rectangle (extents.width and extents.height).
 They do contribute indirectly by changing the position of
 non-whitespace characters. In particular, trailing whitespace
 characters are likely to not affect the size of the
 rectangle, though they will affect the x_advance
 and y_advance values.<br><br>

</dd>
<dt><big><a name="ScaledFont.glyphExtents"></a>TextExtents <u>glyphExtents</u>(Glyph[] <i>glyphs</i>);
</big></dt>
<dd>Gets the extents for an array of <i>glyphs</i>. The extents describe
 a user-space rectangle that encloses the "inked" portion
 of the <i>glyphs</i>, (as they would be drawn by 
 if the cairo graphics state were set to the same fontFace,
 fontMatrix, ctm, and fontOptions as scaled_font). Additionally,
 the x_advance and y_advance values indicate the amount by
 which the current point would be advanced by .
<br><br>
Note that whitespace <i>glyphs</i> do not contribute to the size
 of the rectangle (extents.width and extents.height).<br><br>

</dd>
<dt><big><a name="ScaledFont.textToGlyphs"></a>Glyph[] <u>textToGlyphs</u>(double <i>x</i>, double <i>y</i>, string <i>text</i>, Glyph[] <i>glyphBuffer</i> = []);
<br>Glyph[] <u>textToGlyphs</u>(Point!double <i>p1</i>, string <i>text</i>, Glyph[] <i>glyphBuffer</i> = []);
<br><a name="ScaledFont.textToTextGlyph"></a>TextGlyph <u>textToTextGlyph</u>(double <i>x</i>, double <i>y</i>, string <i>text</i>, Glyph[] <i>glyphBuffer</i> = [], TextCluster[] <i>clusterBuffer</i> = []);
<br>TextGlyph <u>textToTextGlyph</u>(Point!double <i>p1</i>, string <i>text</i>, Glyph[] <i>glyphBuffer</i> = [], TextCluster[] <i>clusterBuffer</i> = []);
</big></dt>
<dd>Converts UTF-8 <i>text</i> to an array of glyphs, optionally with
 cluster mapping, that can be used to render later using ScaledFont.
<br><br>
 If <i>glyphBuffer</i> initially points to a non-empty array, that array is
 used as a glyph buffer. If the provided glyph array is too
 short for the conversion, a new glyph array is allocated and returned.
<br><br>

 If <i>clusterBuffer</i> is not empty a cluster mapping will be computed.
 The semantics of how cluster array allocation works is similar to the glyph array.
 That is, if <i>clusterBuffer</i> initially points to a non-empty array,
 that array is used as a cluster buffer.
 If the provided cluster array is too short for the conversion,
 a new cluster array is allocated and returned.
<br><br>

 In the simplest case, glyphs and clusters can be omitted
 or set to an empty array and a suitable array will be allocated.
 In code
<pre class="d_code"><font color=blue>auto</font> glyphs = scaled_font.<u>textToTextGlyph</u>(<i>x</i>, <i>y</i>, <i>text</i>);
cr.showTextGlyphs(glyphs);
</pre>
 If no cluster mapping is needed
<pre class="d_code"><font color=blue>auto</font> glyphs = scaled_font.<u>textToGlyphs</u>(<i>x</i>, <i>y</i>, <i>text</i>);
cr.showGlyphs(glyphs);
</pre>
 If stack-based glyph and cluster arrays are to be used for small arrays
<pre class="d_code">Glyph[40] stack_glyphs;
TextCluster[40] stack_clusters;
<font color=blue>auto</font> glyphs = scaled_font.<u>textToTextGlyph</u>(<i>x</i>, <i>y</i>, <i>text</i>, stack_glyphs, stack_clusters);
cr.showTextGlyphs(glyphs);
</pre>
<br><br>

 The output values can be readily passed to 
 , or related functions, assuming that
 the exact same ScaledFont is used for the operation.

<br><br>
<b>Params:</b><br>
<table><tr><td>double <i>x</i></td>
<td>X position to place first glyph</td></tr>
<tr><td>double <i>y</i></td>
<td>Y position to place first glyph</td></tr>
</table><br>

</dd>
<dt><big><a name="ScaledFont.getFontFace"></a>FontFace <u>getFontFace</u>();
</big></dt>
<dd>Gets the font face that this scaled font uses. This is the
 font face passed to .<br><br>

</dd>
<dt><big><a name="ScaledFont.fontFace"></a>alias <u>fontFace</u> = getFontFace;
</big></dt>
<dd>convenience alias<br><br>

</dd>
<dt><big><a name="ScaledFont.getFontOptions"></a>FontOptions <u>getFontOptions</u>();
</big></dt>
<dd>Returns the font options with which ScaledFont
 was created.<br><br>

</dd>
<dt><big><a name="ScaledFont.fontOptions"></a>alias <u>fontOptions</u> = getFontOptions;
</big></dt>
<dd>convenience alias<br><br>

</dd>
<dt><big><a name="ScaledFont.getFontMatrix"></a>Matrix <u>getFontMatrix</u>();
</big></dt>
<dd>Returns the font matrix with which ScaledFont
 was created.<br><br>

</dd>
<dt><big><a name="ScaledFont.fontMatrix"></a>alias <u>fontMatrix</u> = getFontMatrix;
</big></dt>
<dd>convenience alias<br><br>

</dd>
<dt><big><a name="ScaledFont.getCTM"></a>Matrix <u>getCTM</u>();
</big></dt>
<dd>Returns the CTM with which ScaledFont was created.
 Note that the translation offsets (x0, y0) of the CTM are
 ignored by . So, the matrix this function
 returns always has 0,0 as x0,y0.<br><br>

</dd>
<dt><big><a name="ScaledFont.CTM"></a>alias <u>CTM</u> = getCTM;
</big></dt>
<dd>convenience alias<br><br>

</dd>
<dt><big><a name="ScaledFont.getScaleMatrix"></a>Matrix <u>getScaleMatrix</u>();
</big></dt>
<dd>Returns the scale matrix of ScaledFont.
 The scale matrix is product of the font matrix and the
 ctm associated with the scaled font, and hence is the
 matrix mapping from font space to device space.<br><br>

</dd>
<dt><big><a name="ScaledFont.scaleMatrix"></a>alias <u>scaleMatrix</u> = getScaleMatrix;
</big></dt>
<dd>convenience alias<br><br>

</dd>
<dt><big><a name="ScaledFont.getType"></a>FontType <u>getType</u>();
</big></dt>
<dd>This function returns the C type of a ScaledFont. See 
 for available types.<br><br>

</dd>
<dt><big><a name="ScaledFont.type"></a>alias <u>type</u> = getType;
</big></dt>
<dd>convenience alias<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="FontFace"></a>class <u>FontFace</u>;
</big></dt>
<dd>Base class for font faces
<br><br>
 represents a particular font at a particular weight,
 slant, and other characteristic but no size, transformation, or size.
<br><br>

 Font faces are created using font-backend-specific classes,
 typically of the form , or implicitly
 using the toy text API by way of . The
 resulting face can be accessed using .<br><br>

<dl><dt><big><a name="FontFace._count"></a>@property uint <u>_count</u>();
</big></dt>
<dd>Reference count. For use in child classes<br><br>

</dd>
<dt><big><a name="FontFace._reference"></a>void <u>_reference</u>();
</big></dt>
<dd>Increase reference count. For use in child classes<br><br>

</dd>
<dt><big><a name="FontFace._dereference"></a>void <u>_dereference</u>();
</big></dt>
<dd>Decrease reference count. For use in child classes<br><br>

</dd>
<dt><big><a name="FontFace.nativePointer"></a>T <u>nativePointer</u>;
</big></dt>
<dd>The underlying  handle<br><br>

</dd>
<dt><big><a name="FontFace.debugging"></a>bool <u>debugging</u>;
</big></dt>
<dd>Enable / disable memory management <u>debugging</u> for this
 instance. Only available if both cairoD and the cairoD user
 code were compiled with "debug=RefCounted"
<br><br>
Output is written to stdout, see
 <a href="https://github.com/jpf91/cairoD/wiki/Memory-Management#debugging">https://github.com/jpf91/cairoD/wiki/Memory-Management#debugging</a>
 for more information<br><br>

</dd>
<dt><big><a name="FontFace.dispose"></a>void <u>dispose</u>();
</big></dt>
<dd>Explicitly drecrease the reference count.
<br><br>
See <a href="https://github.com/jpf91/cairoD/wiki/Memory-Management#3-RC-class">https://github.com/jpf91/cairoD/wiki/Memory-Management#3-RC-class</a>
 for more information.<br><br>

</dd>
<dt><big><a name="FontFace.checkError"></a>protected final void <u>checkError</u>();
</big></dt>
<dd>Method for use in subclasses.
 Calls  and throws
 an exception if the status isn't CAIRO_STATUS_SUCCESS<br><br>

</dd>
<dt><big><a name="FontFace.this"></a>this(cairo_font_face_t* <i>ptr</i>);
</big></dt>
<dd>Create a  from a existing .
 FontFace is a garbage collected class. It will call 
 when it gets collected by the GC or when  is called.
<br><br>
<b>Warning:</b><br>
's reference count is not increased by this function!
 Adjust reference count before calling it if necessary
<br><br>

 <font color=red>Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</font><br><br>

</dd>
<dt><big><a name="FontFace.createFromNative"></a>static FontFace <u>createFromNative</u>(cairo_font_face_t* <i>ptr</i>, bool <i>adjRefCount</i> = true);
</big></dt>
<dd>The <u>createFromNative</u> method for the FontFace classes.
 See <a href="https://github.com/jpf91/cairoD/wiki/Memory-Management#createFromNative">https://github.com/jpf91/cairoD/wiki/Memory-Management#createFromNative</a>
 for more information.
<br><br>
<b>Warning:</b><br>
<font color=red>Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</font><br><br>

</dd>
<dt><big><a name="FontFace.getType"></a>FontType <u>getType</u>();
</big></dt>
<dd>This function returns the C type of a FontFace. See 
 for available types.<br><br>

</dd>
<dt><big><a name="FontFace.type"></a>alias <u>type</u> = getType;
</big></dt>
<dd>convenience alias<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="ToyFontFace"></a>class <u>ToyFontFace</u>: <u>cairo.cairo.FontFace</u>;
</big></dt>
<dd>Cairo toy font api's FontFace<br><br>

<dl><dt><big><a name="ToyFontFace.this"></a>this(cairo_font_face_t* <i>ptr</i>);
</big></dt>
<dd>Create a  from a existing .
 ToyFontFace is a garbage collected class. It will call 
 when it gets collected by the GC or when  is called.
<br><br>
<b>Warning:</b><br>
's reference count is not increased by this function!
 Adjust reference count before calling it if necessary
<br><br>

 <font color=red>Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</font><br><br>

</dd>
<dt><big><a name="ToyFontFace.this.2"></a>this(string <i>family</i>, FontSlant <i>slant</i>, FontWeight <i>weight</i>);
</big></dt>
<dd>Creates a font face from a triplet of <i>family</i>, <i>slant</i>, and <i>weight</i>.
 These font faces are used in implementation of the the cairo "toy" font API.
<br><br>
If <i>family</i> is the zero-length string "", the platform-specific
 default <i>family</i> is assumed. The default <i>family</i> then
 can be queried using .
<br><br>

 The  function uses this to create
 font faces. See that function for limitations and
 other details of toy font faces.<br><br>

</dd>
<dt><big><a name="ToyFontFace.getFamily"></a>string <u>getFamily</u>();
</big></dt>
<dd>Gets the familly name of a toy font.<br><br>

</dd>
<dt><big><a name="ToyFontFace.family"></a>alias <u>family</u> = getFamily;
</big></dt>
<dd>convenience alias<br><br>

</dd>
<dt><big><a name="ToyFontFace.getSlant"></a>FontSlant <u>getSlant</u>();
</big></dt>
<dd>Gets the slant a toy font.<br><br>

</dd>
<dt><big><a name="ToyFontFace.slant"></a>alias <u>slant</u> = getSlant;
</big></dt>
<dd>convenience alias<br><br>

</dd>
<dt><big><a name="ToyFontFace.getWeight"></a>FontWeight <u>getWeight</u>();
</big></dt>
<dd>Gets the weight of a toy font.<br><br>

</dd>
<dt><big><a name="ToyFontFace.weight"></a>alias <u>weight</u> = getWeight;
</big></dt>
<dd>convenience alias<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Version"></a>struct <u>Version</u>;
</big></dt>
<dd>Cairo version information<br><br>

<dl><dt><big><a name="Version.major"></a>uint <u>major</u>;
<br><a name="Version.minor"></a>uint <u>minor</u>;
<br><a name="Version.micro"></a>uint <u>micro</u>;
</big></dt>
<dd>Major, Minor and Micro versions<br><br>

</dd>
<dt><big><a name="Version.this"></a>this(ulong <i>encoded</i>);
</big></dt>
<dd>Construct a version object from a <i>encoded</i> version.<br><br>

</dd>
<dt><big><a name="Version.this.2"></a>this(uint <i>major</i>, uint <i>minor</i>, uint <i>micro</i>);
</big></dt>
<dd>Construct a version object from version components.<br><br>

</dd>
<dt><big><a name="Version.cairoVersion"></a>static @property Version <u>cairoVersion</u>();
</big></dt>
<dd>Return the (runtime) version of the used cairo
 library.<br><br>

</dd>
<dt><big><a name="Version.bindingVersion"></a>static @property Version <u>bindingVersion</u>();
</big></dt>
<dd>Returns the (compile time) version of this binding / wrapper.<br><br>

</dd>
<dt><big><a name="Version.encode"></a>ulong <u>encode</u>();
</big></dt>
<dd>Returns the version in encoded form.<br><br>

</dd>
<dt><big><a name="Version.toString"></a>string <u>toString</u>();
</big></dt>
<dd><u>toString</u> implementation<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="ClipRange"></a>struct <u>ClipRange</u>;
</big></dt>
<dd>RandomAccessRange to iterate or index into Clips of a Cairo Region.
 This range keeps a reference to its  object,
 so it can be passed around without thinking about memory management.<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
