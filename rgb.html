<html><head>
        <!-- Generated by Ddoc from ../../../.dub/packages/color-0.0.5/color/std/experimental/color/rgb.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>std.experimental.color.rgb</title>
        </head><body>
        <h1>std.experimental.color.rgb</h1>
This module implements the RGB color type.
<br><br>
<b>Authors:</b><br>
Manu Evans
<br><br>
<b>License:</b><br>

<br><br>
<b>Source:</b><br>
<br><br>

<dl><dt><big><a name="isRGB"></a>enum auto <u>isRGB</u>(T);
</big></dt>
<dd>Detect whether <pre style="display:inline;" class="d_inline_code">T</pre> is an RGB color.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> <font color=blue>assert</font>(<u>isRGB</u>!(RGB!(<font color=red>"bgr"</font>, <font color=blue>ushort</font>)) == <font color=blue>true</font>);
<font color=blue>static</font> <font color=blue>assert</font>(<u>isRGB</u>!LA8 == <font color=blue>true</font>);
<font color=blue>static</font> <font color=blue>assert</font>(<u>isRGB</u>!<font color=blue>int</font> == <font color=blue>false</font>);
</pre>
<br><br>
</dd>
<dt><big><a name="RGB"></a>struct <u>RGB</u>(string components_, ComponentType_, bool linear_ = false, RGBColorSpace colorSpace_ = RGBColorSpace.sRGB) if (isNumeric!ComponentType_);
</big></dt>
<dd>An <u>RGB</u> color, parameterised with components, component type, and color space specification.
<br><br>
<b>Params:</b><br>
<table><tr><td>components_</td>
<td>Components that shall be available. Struct is populated with components in the order specified.<br>
                      Valid components are:<br>
                        "r" = red<br>
                        "g" = green<br>
                        "b" = blue<br>
                        "a" = alpha<br>
                        "l" = luminance<br>
                        "x" = placeholder/padding (no significant value)</td></tr>
<tr><td>ComponentType_</td>
<td>Type for the color channels. May be a basic integer or floating point type.</td></tr>
<tr><td>linear_</td>
<td>Color is stored with linear luminance.</td></tr>
<tr><td>colorSpace_</td>
<td>Color will be within the specified color space.</td></tr>
</table><br>

<dl><dt><big><a name="RGB.this"></a>this(C)(const(C)[] <i>str</i>) if (isSomeChar!C);
</big></dt>
<dd>Construct a color from a string.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> <font color=blue>assert</font>(RGB8(<font color=red>"#8000FF"</font>)  == RGB8(0x80,0x00,0xFF));
<font color=blue>static</font> <font color=blue>assert</font>(RGBA8(<font color=red>"0x908000FF"</font>) == RGBA8(0x80,0x00,0xFF,0x90));
</pre>
<br><br>
</dd>
<dt><big><a name="RGB.ComponentType"></a>alias <u>ComponentType</u> = ComponentType_;
</big></dt>
<dd>Type of the color components.<br><br>

</dd>
<dt><big><a name="RGB.components"></a>enum string <u>components</u>;
</big></dt>
<dd>The color <u>components</u> that were specified.<br><br>

</dd>
<dt><big><a name="RGB.colorSpace"></a>enum RGBColorSpace <u>colorSpace</u>;
</big></dt>
<dd>The colors color space.<br><br>

</dd>
<dt><big><a name="RGB.colorSpaceDesc"></a>enum RGBColorSpaceDesc!F <u>colorSpaceDesc</u>(F = double);
</big></dt>
<dd>The color space descriptor.<br><br>

</dd>
<dt><big><a name="RGB.linear"></a>enum bool <u>linear</u>;
</big></dt>
<dd>If the color is stored linearly (without gamma applied).<br><br>

</dd>
<dt><big><a name="RGB.hasComponent"></a>enum bool <u>hasComponent</u>(char c);
</big></dt>
<dd>Test if a particular component is present.<br><br>

</dd>
<dt><big><a name="RGB.hasAlpha"></a>enum bool <u>hasAlpha</u>;
</big></dt>
<dd>If the color has alpha.<br><br>

</dd>
<dt><big><a name="RGB.tristimulus"></a>const @property auto <u>tristimulus</u>();
</big></dt>
<dd>Return the RGB <u>tristimulus</u> values as a tuple.
        These will always be ordered (R, G, B).
        Any color channels not present will be 0.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=green>// tristimulus returns tuple of R, G, B
</font><font color=blue>static</font> <font color=blue>assert</font>(BGR8(255, 128, 10).<u>tristimulus</u> == tuple(NormalizedInt!<font color=blue>ubyte</font>(255), NormalizedInt!<font color=blue>ubyte</font>(128), NormalizedInt!<font color=blue>ubyte</font>(10)));
</pre>
<br><br>
</dd>
<dt><big><a name="RGB.tristimulusWithAlpha"></a>const @property auto <u>tristimulusWithAlpha</u>();
</big></dt>
<dd>Return the RGB tristimulus values + alpha as a tuple.
        These will always be ordered (R, G, B, A).<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=green>// tristimulusWithAlpha returns tuple of R, G, B, A
</font><font color=blue>static</font> <font color=blue>assert</font>(BGRA8(255, 128, 10, 80).<u>tristimulusWithAlpha</u> == tuple(NormalizedInt!<font color=blue>ubyte</font>(255), NormalizedInt!<font color=blue>ubyte</font>(128), NormalizedInt!<font color=blue>ubyte</font>(10), NormalizedInt!<font color=blue>ubyte</font>(80)));
</pre>
<br><br>
</dd>
<dt><big><a name="RGB.this.2"></a>this(ComponentType <i>r</i>, ComponentType <i>g</i>, ComponentType <i>b</i>, ComponentType <i>a</i> = defaultAlpha!ComponentType);
</big></dt>
<dd>Construct <i>a</i> color from RGB and optional alpha values.<br><br>

</dd>
<dt><big><a name="RGB.this.3"></a>this(ComponentType <i>l</i>, ComponentType <i>a</i> = defaultAlpha!ComponentType);
</big></dt>
<dd>Construct <i>a</i> color from <i>a</i> luminance and optional alpha value.<br><br>

</dd>
<dt><big><a name="RGB.this.4"></a>this(ComponentType.IntType <i>r</i>, ComponentType.IntType <i>g</i>, ComponentType.IntType <i>b</i>, ComponentType.IntType <i>a</i> = defaultAlpha!(ComponentType.IntType));
</big></dt>
<dd>Construct <i>a</i> color from RGB and optional alpha values.<br><br>

</dd>
<dt><big><a name="RGB.this.5"></a>this(ComponentType.IntType <i>l</i>, ComponentType.IntType <i>a</i> = defaultAlpha!(ComponentType.IntType));
</big></dt>
<dd>Construct <i>a</i> color from <i>a</i> luminance and optional alpha value.<br><br>

</dd>
<dt><big><a name="RGB.opCast"></a>const Color <u>opCast</u>(Color)() if (isColor!Color);
</big></dt>
<dd>Cast to other color types<br><br>

</dd>
<dt><big><a name="RGB.opUnary"></a>const typeof(this) <u>opUnary</u>(string op)() if (op == "+" || op == "-" || op == "~" &amp;&amp; is(ComponentType == NormalizedInt!U, U));
</big></dt>
<dd>Unary operators.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> <font color=blue>assert</font>(+UVW8(1,2,3) == UVW8(1,2,3));
<font color=blue>static</font> <font color=blue>assert</font>(-UVW8(1,2,3) == UVW8(-1,-2,-3));

<font color=blue>static</font> <font color=blue>assert</font>(~RGB8(1,2,3) == RGB8(0xFE,0xFD,0xFC));
<font color=blue>static</font> <font color=blue>assert</font>(~UVW8(1,2,3) == UVW8(~1,~2,~3));
</pre>
<br><br>
</dd>
<dt><big><a name="RGB.opBinary"></a>const typeof(this) <u>opBinary</u>(string op)(typeof(this) <i>rh</i>) if (op == "+" || op == "-" || op == "*");
</big></dt>
<dd>Binary operators.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> <font color=blue>assert</font>(RGB8(10,20,30)       + RGB8(4,5,6) == RGB8(14,25,36));
<font color=blue>static</font> <font color=blue>assert</font>(UVW8(10,20,30)       + UVW8(4,5,6) == UVW8(14,25,36));
<font color=blue>static</font> <font color=blue>assert</font>(RGBAf32(10,20,30,40) + RGBAf32(4,5,6,7) == RGBAf32(14,25,36,47));

<font color=blue>static</font> <font color=blue>assert</font>(RGB8(10,20,30)       - RGB8(4,5,6) == RGB8(6,15,24));
<font color=blue>static</font> <font color=blue>assert</font>(UVW8(10,20,30)       - UVW8(4,5,6) == UVW8(6,15,24));
<font color=blue>static</font> <font color=blue>assert</font>(RGBAf32(10,20,30,40) - RGBAf32(4,5,6,7) == RGBAf32(6,15,24,33));

<font color=blue>static</font> <font color=blue>assert</font>(RGB8(10,20,30)       * RGB8(128,128,128) == RGB8(5,10,15));
<font color=blue>static</font> <font color=blue>assert</font>(UVW8(10,20,30)       * UVW8(-64,-64,-64) == UVW8(-5,-10,-15));
<font color=blue>static</font> <font color=blue>assert</font>(RGBAf32(10,20,30,40) * RGBAf32(0,1,2,3) == RGBAf32(0,20,60,120));
</pre>
<br><br>
</dd>
<dt><big><a name="RGB.opBinary.2"></a>const typeof(this) <u>opBinary</u>(string op, S)(S <i>rh</i>) if (isColorScalarType!S &amp;&amp; (op == "*" || op == "/" || op == "%" || op == "^^"));
</big></dt>
<dd>Binary operators.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> <font color=blue>assert</font>(RGB8(10,20,30)       * 2 == RGB8(20,40,60));
<font color=blue>static</font> <font color=blue>assert</font>(UVW8(10,20,30)       * 2 == UVW8(20,40,60));
<font color=blue>static</font> <font color=blue>assert</font>(RGBAf32(10,20,30,40) * 2 == RGBAf32(20,40,60,80));

<font color=blue>static</font> <font color=blue>assert</font>(RGB8(10,20,30)       / 2 == RGB8(5,10,15));
<font color=blue>static</font> <font color=blue>assert</font>(UVW8(-10,-20,-30)    / 2 == UVW8(-5,-10,-15));
<font color=blue>static</font> <font color=blue>assert</font>(RGBAf32(10,20,30,40) / 2 == RGBAf32(5,10,15,20));

<font color=blue>static</font> <font color=blue>assert</font>(RGB8(10,20,30)       * 2.0 == RGB8(20,40,60));
<font color=blue>static</font> <font color=blue>assert</font>(UVW8(10,20,30)       * 2.0 == UVW8(20,40,60));
<font color=blue>static</font> <font color=blue>assert</font>(RGBAf32(10,20,30,40) * 2.0 == RGBAf32(20,40,60,80));
<font color=blue>static</font> <font color=blue>assert</font>(RGB8(10,20,30)       * 0.5 == RGB8(5,10,15));
<font color=blue>static</font> <font color=blue>assert</font>(UVW8(-10,-20,-30)    * 0.5 == UVW8(-5,-10,-15));
<font color=blue>static</font> <font color=blue>assert</font>(RGBAf32(5,10,15,20)  * 0.5 == RGBAf32(2.5,5,7.5,10));

<font color=blue>static</font> <font color=blue>assert</font>(RGB8(10,20,30)       / 2.0 == RGB8(5,10,15));
<font color=blue>static</font> <font color=blue>assert</font>(UVW8(-10,-20,-30)    / 2.0 == UVW8(-5,-10,-15));
<font color=blue>static</font> <font color=blue>assert</font>(RGBAf32(10,20,30,40) / 2.0 == RGBAf32(5,10,15,20));
<font color=blue>static</font> <font color=blue>assert</font>(RGB8(10,20,30)       / 0.5 == RGB8(20,40,60));
<font color=blue>static</font> <font color=blue>assert</font>(UVW8(10,20,30)       / 0.5 == UVW8(20,40,60));
<font color=blue>static</font> <font color=blue>assert</font>(RGBAf32(10,20,30,40) / 0.5 == RGBAf32(20,40,60,80));
</pre>
<br><br>
</dd>
<dt><big><a name="RGB.opOpAssign"></a>ref typeof(this) <u>opOpAssign</u>(string op)(typeof(this) <i>rh</i>) if (op == "+" || op == "-" || op == "*");
</big></dt>
<dd>Binary assignment operators.<br><br>

</dd>
<dt><big><a name="RGB.opOpAssign.2"></a>ref typeof(this) <u>opOpAssign</u>(string op, S)(S <i>rh</i>) if (isColorScalarType!S &amp;&amp; (op == "*" || op == "/" || op == "%" || op == "^^"));
</big></dt>
<dd>Binary assignment operators.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="toLinear"></a>T <u>toLinear</u>(RGBColorSpace src, T)(T <i>v</i>) if (isFloatingPoint!T);
</big></dt>
<dd>Convert a value from gamma compressed space to linear.<br><br>

</dd>
<dt><big><a name="toGamma"></a>T <u>toGamma</u>(RGBColorSpace src, T)(T <i>v</i>) if (isFloatingPoint!T);
</big></dt>
<dd>Convert a value to gamma compressed space.<br><br>

</dd>
<dt><big><a name="toLinear.2"></a>auto <u>toLinear</u>(C)(C <i>color</i>) if (isRGB!C);
</big></dt>
<dd>Convert a <i>color</i> to linear space.<br><br>

</dd>
<dt><big><a name="toGamma.2"></a>auto <u>toGamma</u>(C)(C <i>color</i>) if (isRGB!C);
</big></dt>
<dd>Convert a <i>color</i> to gamma space.<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. Copyright (c) 2015, Manu Evans.
</small>
        </body></html>
