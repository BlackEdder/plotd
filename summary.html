<html><head>
        <!-- Generated by Ddoc from ../../../.dub/packages/dstats-1.0.3/dstats/source/dstats/summary.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>dstats.summary</title>
        </head><body>
        <h1>dstats.summary</h1>
Summary statistics such as mean, median, sum, variance, skewness, kurtosis.
 Except for median and median absolute deviation, which cannot be calculated
 online, all <u>summary</u> statistics have both an input range interface and an
 output range interface.
<br><br>
<b>Notes:</b><br>
The put method on the structs defined in this module returns this by
        ref.  The use case for returning this is to enable these structs
        to be used with std.algorithm.reduce.  The rationale for returning
        by ref is that the return value usually won't be used, and the
        overhead of returning a large struct by value should be avoided.

<br><br>
<font color=red>BUGS:</font><br>
This whole module assumes that input will be doubles or types implicitly
        convertible to double.  No allowances are made for user-defined numeric
        types such as BigInts.  This is necessary for simplicity.  However,
        if you have a function that converts your data to doubles, most of
        these functions work with any input range, so you can simply map
        this function onto your range.

<br><br>
<b>Author:</b><br>
David Simcha<br><br>

<dl><dt><big><a name="median"></a>double <u>median</u>(T)(T <i>data</i>) if (doubleInput!T);
</big></dt>
<dd>Finds <u>median</u> of an input range in O(N) time on average.  In the case of an
 even number of elements, the mean of the two middle elements is returned.
 This is a convenience founction designed specifically for numeric types,
 where the averaging of the two middle elements is desired.  A more general
 selection algorithm that can handle any type with a total ordering, as well
 as selecting any position in the ordering, can be found at
 dstats.sort.quickSelect() and dstats.sort.partitionK().
 Allocates memory, does not reorder input <i>data</i>.<br><br>

</dd>
<dt><big><a name="medianPartition"></a>double <u>medianPartition</u>(T)(T <i>data</i>) if (isRandomAccessRange!T &amp;&amp; is(ElementType!T : double) &amp;&amp; hasSwappableElements!T &amp;&amp; hasLength!T);
</big></dt>
<dd>Median finding as in median(), but will partition input <i>data</i> such that
 elements less than the median will have smaller indices than that of the
 median, and elements larger than the median will have larger indices than
 that of the median. Useful both for its partititioning and to avoid
 memory allocations.  Requires a random access range with swappable
 elements.<br><br>

</dd>
<dt><big><a name="MedianAbsDev"></a>struct <u>MedianAbsDev</u>;
</big></dt>
<dd>Plain old data holder struct for median, median absolute deviation.
 Alias this'd to the median absolute deviation member.<br><br>

</dd>
<dt><big><a name="medianAbsDev"></a>MedianAbsDev <u>medianAbsDev</u>(T)(T <i>data</i>) if (doubleInput!T);
</big></dt>
<dd>Calculates the median absolute deviation of a dataset.  This is the median
 of all absolute differences from the median of the dataset.
<br><br>
<b>Returns:</b><br>
A MedianAbsDev struct that contains the median (since it is
 computed anyhow) and the median absolute deviation.

<br><br>
<b>Notes:</b><br>
No bias correction is used in this implementation, since using
 one would require assumptions about the underlying distribution of the <i>data</i>.<br><br>

</dd>
<dt><big><a name="interquantileRange"></a>double <u>interquantileRange</u>(R)(R <i>data</i>, double <i>quantile</i> = 0.25) if (doubleInput!R);
</big></dt>
<dd>Computes the interquantile range of <i>data</i> at the given <i>quantile</i> value in O(N)
 time complexity.  For example, using a <i>quantile</i> value of either 0.25 or 0.75
 will give the interquartile range.  (This is the default since it is
 apparently the most common interquantile range in common usage.)
 Using a <i>quantile</i> value of 0.2 or 0.8 will give the interquntile range.
<br><br>
If the <i>quantile</i> point falls between two indices, linear interpolation is
 used.
<br><br>

 This function is somewhat more efficient than simply finding the upper and
 lower <i>quantile</i> and subtracting them.

<br><br>
<b>Tip:</b><br>
A <i>quantile</i> of 0 or 1 is handled as a special case and will compute the
       plain old range of the <i>data</i> in a single pass.<br><br>

</dd>
<dt><big><a name="Mean"></a>struct <u>Mean</u>;
</big></dt>
<dd>Output range to calculate the mean online.  Getter for mean costs a branch to
 check for N == 0.  This struct uses O(1) space and does *NOT* store the
 individual elements.
<br><br>
<b>Note:</b><br>
This struct can implicitly convert to the value of the mean.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><u>Mean</u> summ;
summ.put(1);
summ.put(2);
summ.put(3);
summ.put(4);
summ.put(5);
<font color=blue>assert</font>(summ.mean == 3);
</pre>
<br><br>

<dl><dt><big><a name="Mean.put"></a>pure nothrow @safe void <u>put</u>(double <i>element</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Mean.put.2"></a>pure nothrow @safe void <u>put</u>(typeof(this) <i>rhs</i>);
</big></dt>
<dd>Adds the contents of <i>rhs</i> to this instance.
<br><br>
<b>Examples:</b><br>
<pre class="d_code">Mean mean1, mean2, combined;
<font color=blue>foreach</font>(i; 0..5) {
    mean1.<u>put</u>(i);
}

<font color=blue>foreach</font>(i; 5..10) {
    mean2.<u>put</u>(i);
}

mean1.<u>put</u>(mean2);

<font color=blue>foreach</font>(i; 0..10) {
    combined.<u>put</u>(i);
}

<font color=blue>assert</font>(approxEqual(combined.mean, mean1.mean));
</pre>
<br><br>

</dd>
<dt><big><a name="Mean.sum"></a>const pure nothrow @property @safe double <u>sum</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Mean.mean"></a>const pure nothrow @property @safe double <u>mean</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Mean.N"></a>const pure nothrow @property @safe double <u>N</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Mean.toMean"></a>const pure nothrow @property @safe Mean <u>toMean</u>();
</big></dt>
<dd>Simply returns this.  Useful in generic programming contexts.<br><br>

</dd>
<dt><big><a name="Mean.toString"></a>const string <u>toString</u>();
</big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><big><a name="mean"></a>Mean <u>mean</u>(T)(T <i>data</i>) if (doubleIterable!T);
</big></dt>
<dd>Finds the arithmetic <u>mean</u> of any input range whose elements are implicitly
 convertible to double.<br><br>

</dd>
<dt><big><a name="GeometricMean"></a>struct <u>GeometricMean</u>;
</big></dt>
<dd>Output range to calculate the geometric mean online.
 Operates similarly to dstats.summary.Mean<br><br>

<dl><dt><big><a name="GeometricMean.put"></a>pure nothrow @safe void <u>put</u>(double <i>element</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="GeometricMean.put.2"></a>pure nothrow @safe void <u>put</u>(typeof(this) <i>rhs</i>);
</big></dt>
<dd>Combine two GeometricMean's.<br><br>

</dd>
<dt><big><a name="GeometricMean.geoMean"></a>const pure nothrow @property double <u>geoMean</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="GeometricMean.N"></a>const pure nothrow @property double <u>N</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="GeometricMean.toString"></a>const string <u>toString</u>();
</big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><big><a name="geometricMean"></a>double <u>geometricMean</u>(T)(T <i>data</i>) if (doubleIterable!T);
</big></dt>
<dd>Calculates the geometric mean of any input range that has elements implicitly
 convertible to double<br><br>

</dd>
<dt><big><a name="sum"></a>U <u>sum</u>(T, U = Unqual!(ForeachType!T))(T <i>data</i>) if (doubleIterable!T);
</big></dt>
<dd>Finds the <u>sum</u> of an input range whose elements implicitly convert to double.
 User has option of making U a different type than T to prevent overflows
 on large array summing operations.  However, by default, return type is
 T (same as input type).<br><br>

</dd>
<dt><big><a name="MeanSD"></a>struct <u>MeanSD</u>;
</big></dt>
<dd>Output range to compute mean, stdev, variance online.  Getter methods
 for stdev, var cost a few floating point ops.  Getter for mean costs
 a single branch to check for N == 0.  Relatively expensive floating point
 ops, if you only need mean, try Mean.  This struct uses O(1) space and
 does *NOT* store the individual elements.
<br><br>
<b>Note:</b><br>
This struct can implicitly convert to a Mean struct.

<br><br>
<b>References:</b><br>
Computing Higher-Order Moments Online.
<br><br>
<b>http:</b><br>
//people.xiph.org/~tterribe/notes/homs.html

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><u>MeanSD</u> summ;
summ.put(1);
summ.put(2);
summ.put(3);
summ.put(4);
summ.put(5);
<font color=blue>assert</font>(summ.mean == 3);
<font color=blue>assert</font>(summ.stdev == sqrt(2.5));
<font color=blue>assert</font>(summ.var == 2.5);
</pre>
<br><br>

<dl><dt><big><a name="MeanSD.put"></a>pure nothrow @safe void <u>put</u>(double <i>element</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="MeanSD.put.2"></a>pure nothrow @safe void <u>put</u>(typeof(this) <i>rhs</i>);
</big></dt>
<dd>Combine two MeanSD's.<br><br>

</dd>
<dt><big><a name="MeanSD.sum"></a>const pure nothrow @property @safe double <u>sum</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="MeanSD.mean"></a>const pure nothrow @property @safe double <u>mean</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="MeanSD.stdev"></a>const pure nothrow @property @safe double <u>stdev</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="MeanSD.var"></a>const pure nothrow @property @safe double <u>var</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="MeanSD.mse"></a>const pure nothrow @property @safe double <u>mse</u>();
</big></dt>
<dd>Mean squared error.  In other words, a biased estimate of variance.<br><br>

</dd>
<dt><big><a name="MeanSD.N"></a>const pure nothrow @property @safe double <u>N</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="MeanSD.toMean"></a>const pure nothrow @property @safe Mean <u>toMean</u>();
</big></dt>
<dd>Converts this struct to a Mean struct.  Also called when an
 implicit conversion via alias this takes place.<br><br>

</dd>
<dt><big><a name="MeanSD.toMeanSD"></a>const pure nothrow @property @safe MeanSD <u>toMeanSD</u>();
</big></dt>
<dd>Simply returns this.  Useful in generic programming contexts.<br><br>

</dd>
<dt><big><a name="MeanSD.toString"></a>const string <u>toString</u>();
</big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><big><a name="meanStdev"></a>MeanSD <u>meanStdev</u>(T)(T <i>data</i>) if (doubleIterable!T);
</big></dt>
<dd>Puts all elements of <i>data</i> into a MeanSD struct,
 then returns this struct.  This can be faster than doing this manually
 due to ILP optimizations.<br><br>

</dd>
<dt><big><a name="variance"></a>double <u>variance</u>(T)(T <i>data</i>) if (doubleIterable!T);
</big></dt>
<dd>Finds the <u>variance</u> of an input range with members implicitly convertible
 to doubles.<br><br>

</dd>
<dt><big><a name="stdev"></a>double <u>stdev</u>(T)(T <i>data</i>) if (doubleIterable!T);
</big></dt>
<dd>Calculate the standard deviation of an input range with members
 implicitly converitble to double.<br><br>

</dd>
<dt><big><a name="Summary"></a>struct <u>Summary</u>;
</big></dt>
<dd>Output range to compute mean, stdev, variance, skewness, kurtosis, min, and
 max online. Using this struct is relatively expensive, so if you just need
 mean and/or stdev, try MeanSD or Mean. Getter methods for stdev,
 var cost a few floating point ops.  Getter for mean costs a single branch to
 check for N == 0.  Getters for skewness and kurtosis cost a whole bunch of
 floating point ops.  This struct uses O(1) space and does *NOT* store the
 individual elements.
<br><br>
<b>Note:</b><br>
This struct can implicitly convert to a MeanSD.

<br><br>
<b>References:</b><br>
Computing Higher-Order Moments Online.
<br><br>
<b>http:</b><br>
//people.xiph.org/~tterribe/notes/homs.html

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><u>Summary</u> summ;
summ.put(1);
summ.put(2);
summ.put(3);
summ.put(4);
summ.put(5);
<font color=blue>assert</font>(summ.N == 5);
<font color=blue>assert</font>(summ.mean == 3);
<font color=blue>assert</font>(summ.stdev == sqrt(2.5));
<font color=blue>assert</font>(summ.var == 2.5);
<font color=blue>assert</font>(approxEqual(summ.kurtosis, -1.9120));
<font color=blue>assert</font>(summ.min == 1);
<font color=blue>assert</font>(summ.max == 5);
<font color=blue>assert</font>(summ.sum == 15);
</pre>
<br><br>

<dl><dt><big><a name="Summary.put"></a>pure nothrow @safe void <u>put</u>(double <i>element</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Summary.put.2"></a>pure nothrow @safe void <u>put</u>(typeof(this) <i>rhs</i>);
</big></dt>
<dd>Combine two Summary's.<br><br>

</dd>
<dt><big><a name="Summary.sum"></a>const pure nothrow @property @safe double <u>sum</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Summary.mean"></a>const pure nothrow @property @safe double <u>mean</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Summary.stdev"></a>const pure nothrow @property @safe double <u>stdev</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Summary.var"></a>const pure nothrow @property @safe double <u>var</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Summary.mse"></a>const pure nothrow @property @safe double <u>mse</u>();
</big></dt>
<dd>Mean squared error.  In other words, a biased estimate of variance.<br><br>

</dd>
<dt><big><a name="Summary.skewness"></a>const pure nothrow @property @safe double <u>skewness</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Summary.kurtosis"></a>const pure nothrow @property @safe double <u>kurtosis</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Summary.N"></a>const pure nothrow @property @safe double <u>N</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Summary.min"></a>const pure nothrow @property @safe double <u>min</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Summary.max"></a>const pure nothrow @property @safe double <u>max</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Summary.toMeanSD"></a>const pure nothrow @property @safe MeanSD <u>toMeanSD</u>();
</big></dt>
<dd>Converts this struct to a MeanSD.  Called via alias this when an
 implicit conversion is attetmpted.<br><br>

</dd>
<dt><big><a name="Summary.toString"></a>const string <u>toString</u>();
</big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><big><a name="kurtosis"></a>double <u>kurtosis</u>(T)(T <i>data</i>) if (doubleIterable!T);
</big></dt>
<dd>Excess <u>kurtosis</u> relative to normal distribution.  High <u>kurtosis</u> means that
 the variance is due to infrequent, large deviations from the mean.  Low
 <u>kurtosis</u> means that the variance is due to frequent, small deviations from
 the mean.  The normal distribution is defined as having <u>kurtosis</u> of 0.
 Input must be an input range with elements implicitly convertible to double.<br><br>

</dd>
<dt><big><a name="skewness"></a>double <u>skewness</u>(T)(T <i>data</i>) if (doubleIterable!T);
</big></dt>
<dd>Skewness is a measure of symmetry of a distribution.  Positive <u>skewness</u>
 means that the right tail is longer/fatter than the left tail.  Negative
 <u>skewness</u> means the left tail is longer/fatter than the right tail.  Zero
 <u>skewness</u> indicates a symmetrical distribution.  Input must be an input
 range with elements implicitly convertible to double.<br><br>

</dd>
<dt><big><a name="summary"></a>Summary <u>summary</u>(T)(T <i>data</i>) if (doubleIterable!T);
</big></dt>
<dd>Convenience function.  Puts all elements of <i>data</i> into a Summary struct,
 and returns this struct.<br><br>

</dd>
<dt><big><a name="ZScore"></a>struct <u>ZScore</u>(T) if (isForwardRange!T &amp;&amp; is(ElementType!T : double));
</big></dt>
<dd><br><br>
<dl><dt><big><a name="ZScore.front"></a>@property double <u>front</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="ZScore.popFront"></a>void <u>popFront</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="ZScore.empty"></a>@property bool <u>empty</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="ZScore.save"></a>@property typeof(this) <u>save</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="ZScore.opIndex"></a>double <u>opIndex</u>(size_t <i>index</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="ZScore.back"></a>@property double <u>back</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="ZScore.popBack"></a>void <u>popBack</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="ZScore.length"></a>@property size_t <u>length</u>();
</big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><big><a name="zScore"></a>ZScore!T <u>zScore</u>(T)(T <i>range</i>) if (isForwardRange!T &amp;&amp; doubleInput!T);
</big></dt>
<dd>Returns a <i>range</i> with whatever properties T has (forward <i>range</i>, random
 access <i>range</i>, bidirectional <i>range</i>, hasLength, etc.),
 of the z-scores of the underlying
 <i>range</i>.  A z-score of an element in a <i>range</i> is defined as
 (element - mean(<i>range</i>)) / stdev(<i>range</i>).
<br><br>
<b>Notes:</b><br>
If the data contained in the <i>range</i> is a sample of a larger population,
 rather than an entire population, then technically, the results output
 from the ZScore <i>range</i> are T statistics, not Z statistics.  This is because
 the sample mean and standard deviation are only estimates of the population
 parameters.  This does not affect the mechanics of using this <i>range</i>,
 but it does affect the interpretation of its output.
<br><br>

 Accessing elements of this <i>range</i> is fairly expensive, as a
 floating point multiply is involved.  Also, constructing this <i>range</i> is
 costly, as the entire input <i>range</i> has to be iterated over to find the
 mean and standard deviation.<br><br>

</dd>
<dt><big><a name="zScore.2"></a>ZScore!T <u>zScore</u>(T)(T <i>range</i>, double <i>mean</i>, double <i>sd</i>) if (isForwardRange!T &amp;&amp; doubleInput!T);
</big></dt>
<dd>Allows the construction of a ZScore <i>range</i> with precomputed <i>mean</i> and
 stdev.<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
