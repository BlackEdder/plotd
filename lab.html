<html><head>
        <!-- Generated by Ddoc from ../../../.dub/packages/color-0.0.5/color/std/experimental/color/lab.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>std.experimental.color.lab</title>
        </head><body>
        <h1>std.experimental.color.lab</h1>
This module implements CIE Lab and LCh color types.
<br><br>
<b>Authors:</b><br>
Manu Evans
<br><br>
<b>License:</b><br>

<br><br>
<b>Source:</b><br>
<br><br>

<dl><dt><big><a name="isLab"></a>enum auto <u>isLab</u>(T);
</big></dt>
<dd>Detect whether <pre style="display:inline;" class="d_inline_code">T</pre> is a L*a*b* color.<br><br>

</dd>
<dt><big><a name="isLCh"></a>enum auto <u>isLCh</u>(T);
</big></dt>
<dd>Detect whether <pre style="display:inline;" class="d_inline_code">T</pre> is an L*C*h째 color.<br><br>

</dd>
<dt><big><a name="Lab"></a>struct <u>Lab</u>(F = float, alias whitePoint_ = WhitePoint!F.D50) if (isFloatingPoint!F);
</big></dt>
<dd>A CIE L*a*b* color, parameterised for component type and white point.
<br><br>
<u>Lab</u> is a color space that describes all colors visible to the human eye and was created to serve as a device-independent model to be used as a reference.
L* represents the lightness of the color; L* = 0 yields black and L* = 100 indicates diffuse white, specular white may be higher.
a* represents the position between red/magenta and green; negative values indicate green while positive values indicate magenta.
b* represents the position between yellow and blue; negative values indicate blue and positive values indicate yellow.
<br><br>

<u>Lab</u> is often found using default white point D50, but it is also common to use D65 when interacting with sRGB images.<br><br>

<dl><dt><big><a name="Lab.ComponentType"></a>alias <u>ComponentType</u> = F;
</big></dt>
<dd>Type of the color components.<br><br>

</dd>
<dt><big><a name="Lab.whitePoint"></a>enum auto <u>whitePoint</u>;
</big></dt>
<dd>The color components that were specified.<br><br>

</dd>
<dt><big><a name="Lab.L"></a>F <u>L</u>;
</big></dt>
<dd><u>L</u>* (lightness) component.<br><br>

</dd>
<dt><big><a name="Lab.a"></a>F <u>a</u>;
</big></dt>
<dd><u>a</u>* component. Negative values indicate green, positive values indicate magenta.<br><br>

</dd>
<dt><big><a name="Lab.b"></a>F <u>b</u>;
</big></dt>
<dd><u>b</u>* component. Negative values indicate blue, positive values indicate yellow.<br><br>

</dd>
<dt><big><a name="Lab.this"></a>this(F <i>L</i>, F <i>a</i>, F <i>b</i>);
</big></dt>
<dd>Construct <i>a</i> color from <i>L</i>*<i>a</i>*<i>b</i>* values.<br><br>

</dd>
<dt><big><a name="Lab.perceptualDistance"></a>const F <u>perceptualDistance</u>(G)(Lab!G <i>c</i>);
</big></dt>
<dd>Returns the perceptual distance between the specifies colors.<br><br>

</dd>
<dt><big><a name="Lab.opCast"></a>const Color <u>opCast</u>(Color)() if (isColor!Color);
</big></dt>
<dd>Cast to other color types<br><br>

</dd>
<dt><big><a name="Lab.opUnary"></a>const typeof(this) <u>opUnary</u>(string op)() if (op == "+" || op == "-" || op == "~" &amp;&amp; is(ComponentType == NormalizedInt!U, U));
</big></dt>
<dd>Unary operators.<br><br>

</dd>
<dt><big><a name="Lab.opBinary"></a>const typeof(this) <u>opBinary</u>(string op)(typeof(this) <i>rh</i>) if (op == "+" || op == "-" || op == "*");
</big></dt>
<dd>Binary operators.<br><br>

</dd>
<dt><big><a name="Lab.opBinary.2"></a>const typeof(this) <u>opBinary</u>(string op, S)(S <i>rh</i>) if (isColorScalarType!S &amp;&amp; (op == "*" || op == "/" || op == "%" || op == "^^"));
</big></dt>
<dd>Binary operators.<br><br>

</dd>
<dt><big><a name="Lab.opOpAssign"></a>ref typeof(this) <u>opOpAssign</u>(string op)(typeof(this) <i>rh</i>) if (op == "+" || op == "-" || op == "*");
</big></dt>
<dd>Binary assignment operators.<br><br>

</dd>
<dt><big><a name="Lab.opOpAssign.2"></a>ref typeof(this) <u>opOpAssign</u>(string op, S)(S <i>rh</i>) if (isColorScalarType!S &amp;&amp; (op == "*" || op == "/" || op == "%" || op == "^^"));
</big></dt>
<dd>Binary assignment operators.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="LCh"></a>struct <u>LCh</u>(F = float, alias whitePoint_ = WhitePoint!F.D50) if (isFloatingPoint!F);
</big></dt>
<dd>A CIE L*C*h째 color, parameterised for component type and white point.
The <u>LCh</u> color space is a Lab cube color space, where instead of cartesian coordinates a*, b*, the cylindrical coordinates C* (chroma) and h째 (hue angle) are specified. The CIELab lightness L* remains unchanged.<br><br>

<dl><dt><big><a name="LCh.ComponentType"></a>alias <u>ComponentType</u> = F;
</big></dt>
<dd>Type of the color components.<br><br>

</dd>
<dt><big><a name="LCh.whitePoint"></a>enum auto <u>whitePoint</u>;
</big></dt>
<dd>The color components that were specified.<br><br>

</dd>
<dt><big><a name="LCh.L"></a>F <u>L</u>;
</big></dt>
<dd><u>L</u>* (lightness) component.<br><br>

</dd>
<dt><big><a name="LCh.C"></a>F <u>C</u>;
</big></dt>
<dd><u>C</u>* (chroma) component.<br><br>

</dd>
<dt><big><a name="LCh.h"></a>F <u>h</u>;
</big></dt>
<dd><u>h</u>째 (hue) component, in degrees.<br><br>

</dd>
<dt><big><a name="LCh.radians"></a>const @property F <u>radians</u>();
</big></dt>
<dd>Get hue angle in <u>radians</u>.<br><br>

</dd>
<dt><big><a name="LCh.radians.2"></a>@property void <u>radians</u>(F <i>angle</i>);
</big></dt>
<dd>Set hue <i>angle</i> in <u>radians</u>.<br><br>

</dd>
<dt><big><a name="LCh.opCast"></a>const Color <u>opCast</u>(Color)() if (isColor!Color);
</big></dt>
<dd>Cast to other color types<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. Copyright (c) 2015, Manu Evans.
</small>
        </body></html>
