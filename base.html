<html><head>
        <!-- Generated by Ddoc from ../../../.dub/packages/dstats-1.0.3/dstats/source/dstats/base.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>dstats.base</title>
        </head><body>
        <h1>dstats.base</h1>
Relatively low-level primitives on which to build higher-level math/stat
 functionality.  Some are used internally, some are just things that may be
 useful to users of this library.  This module is starting to take on the
 appearance of a small utility library.
<br><br>
<b>Note:</b><br>
In several functions in this module that return arrays, the last
 parameter is an optional buffer for storing the return value.  If this
 parameter is ommitted or the buffer is not large enough, one will be
 allocated on the GC heap.

<br><br>
<b>Author:</b><br>
David Simcha<br><br>

<dl><dt><big><a name="DstatsArgumentException"></a>class <u>DstatsArgumentException</u>: <u>object.Exception</u>;
</big></dt>
<dd>This is the exception that is thrown on invalid arguments to a dstats function.<br><br>

</dd>
<dt><big><a name="doubleInput"></a>enum auto <u>doubleInput</u>(T);
</big></dt>
<dd>Tests whether T is an input range whose elements can be implicitly
converted to doubles.<br><br>

</dd>
<dt><big><a name="doubleIterable"></a>template <u>doubleIterable</u>(T)</big></dt>
<dd>Tests whether T is iterable and has elements of a type implicitly
 convertible to double.<br><br>

</dd>
<dt><big><a name="saveAll"></a>Tuple!T <u>saveAll</u>(T...)(T <i>args</i>);
</big></dt>
<dd>Given a tuple possibly containing forward ranges, returns a tuple where
save() has been called on all forward ranges.<br><br>

</dd>
<dt><big><a name="binCounts"></a>Ret[] <u>binCounts</u>(Ret = uint, T)(T <i>data</i>, uint <i>nbin</i>, Ret[] <i>buf</i> = null) if (isForwardRange!T &amp;&amp; doubleInput!T);
</big></dt>
<dd>Bins <i>data</i> into <i>nbin</i> equal width bins, indexed from
 0 to <i>nbin</i> - 1, with 0 being the smallest bin, etc.
 The values returned are the counts for each bin.
<br><br>
Works with any forward range with elements implicitly convertible to double.<br><br>

</dd>
<dt><big><a name="bin"></a>Ret[] <u>bin</u>(Ret = ubyte, T)(T <i>data</i>, uint <i>nbin</i>, Ret[] <i>buf</i> = null) if (isForwardRange!T &amp;&amp; doubleInput!T &amp;&amp; isIntegral!Ret);
</big></dt>
<dd>Bins <i>data</i> into <i>nbin</i> equal width bins, indexed from
 0 to <i>nbin</i> - 1, with 0 being the smallest <u>bin</u>, etc.
 The values returned are the <u>bin</u> index for each element.
<br><br>
Default return type is ubyte, because in the dstats.infotheory,
 entropy() and related functions specialize on ubytes, and become
 substandially faster.  However, if you're using more than 255 bins,
 you'll have to provide a different return type as a template parameter.<br><br>

</dd>
<dt><big><a name="frqBin"></a>Ret[] <u>frqBin</u>(Ret = ubyte, T)(T <i>data</i>, uint <i>nbin</i>, Ret[] <i>buf</i> = null) if (doubleInput!T &amp;&amp; isForwardRange!T &amp;&amp; hasLength!T &amp;&amp; isIntegral!Ret);
</big></dt>
<dd>Bins <i>data</i> into <i>nbin</i> equal frequency bins, indexed from
 0 to <i>nbin</i> - 1, with 0 being the smallest bin, etc.
 The values returned are the bin index for each element.
<br><br>
Default return type is ubyte, because in the dstats.infotheory,
 entropy() and related functions specialize on ubytes, and become
 substandially faster.  However, if you're using more than 256 bins,
 you'll have to provide a different return type as a template parameter.<br><br>

</dd>
<dt><big><a name="seq"></a>CommonType!(T, U)[] <u>seq</u>(T, U, V = uint)(T <i>start</i>, U <i>end</i>, V <i>increment</i> = 1u);
</big></dt>
<dd>Generates a sequence from [<i>start</i>..<i>end</i>] by <i>increment</i>.  Includes <i>start</i>,
 excludes <i>end</i>.  Does so eagerly as an array.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>auto</font> s = <u>seq</u>(0, 5);
<font color=blue>assert</font>(s == [0, 1, 2, 3, 4]);
</pre>
<br><br>

</dd>
<dt><big><a name="rank"></a>Ret[] <u>rank</u>(alias compFun = "a &lt; b", Ret = double, T)(T <i>input</i>, Ret[] <i>buf</i> = null) if (isInputRange!T &amp;&amp; is(typeof(<i>input</i>.front &lt; <i>input</i>.front)));
</big></dt>
<dd>Given an <i>input</i> array, outputs an array containing the <u>rank</u> from
 [1, <i>input</i>.length] corresponding to each element.  Ties are dealt with by
 averaging.  This function does not reorder the <i>input</i> range.
 Return type is float[] by default, but if you are sure you have no ties,
 ints can be used for efficiency (in which case ties will not be averaged),
 and if you need more precision when averaging ties, you can use double or
 real.
<br><br>
Works with any <i>input</i> range.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>uint</font>[] test = [3, 5, 3, 1, 2];
<font color=blue>assert</font>(<u>rank</u>!(<font color=red>"a &lt; b"</font>, <font color=blue>float</font>)(test) == [3.5f, 5f, 3.5f, 1f, 2f]);
<font color=blue>assert</font>(test == [3U, 5, 3, 1, 2]);
</pre>
<br><br>

</dd>
<dt><big><a name="rankSort"></a>Ret[] <u>rankSort</u>(alias compFun = "a &lt; b", Ret = double, T)(T <i>input</i>, Ret[] <i>buf</i> = null) if (isRandomAccessRange!T &amp;&amp; hasLength!T &amp;&amp; is(typeof(<i>input</i>.front &lt; <i>input</i>.front)));
</big></dt>
<dd>Same as rank(), but also sorts the <i>input</i> range.
 The array returned will still be identical to that returned by rank(), i.e.
 the rank of each element will correspond to the ranks of the elements in the
 <i>input</i> array before sorting.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>uint</font>[] test = [3, 5, 3, 1, 2];
<font color=blue>assert</font>(<u>rankSort</u>(test) == [3.5, 5, 3.5, 1.0, 2.0]);
<font color=blue>assert</font>(test == [1U, 2, 3, 4, 5]);
</pre>
<br><br>

</dd>
<dt><big><a name="frequency"></a>uint[ForeachType!T] <u>frequency</u>(T)(T <i>input</i>) if (isIterable!T);
</big></dt>
<dd>Returns an associative array of counts of every element in <i>input</i>.
 Works w/ any iterable.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>int</font>[] foo = [1,2,3,1,2,4];
<font color=blue>uint</font>[<font color=blue>int</font>] frq = <u>frequency</u>(foo);
<font color=blue>assert</font>(frq.length == 4);
<font color=blue>assert</font>(frq[1] == 2);
<font color=blue>assert</font>(frq[4] == 1);
</pre>
<br><br>

</dd>
<dt><big><a name="byCategory"></a>ElementType!V[][ElementType!C] <u>byCategory</u>(V, C)(V <i>values</i>, C <i>categories</i>) if (isInputRange!V &amp;&amp; isInputRange!C &amp;&amp; !is(ElementType!C == bool));
</big></dt>
<dd>Given a range of <i>values</i> and a range of <i>categories</i>, separates <i>values</i>
 by category.  This function also guarantees that the order within each
 category will be maintained.
<br><br>
<b>Note:</b><br>
While the general convention of this library is to try to avoid
 heap allocations whenever possible so that multithreaded code scales well and
 <b>false</b> pointers aren't an issue, this function allocates like crazy
 because there's basically no other way to implement it.  Don't use it in
 performance-critical multithreaded code.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>uint</font>[] <i>values</i> = [1,2,3,4,5,6,7,8];
<font color=blue>bool</font>[] <i>categories</i> = [<font color=blue>false</font>, <font color=blue>false</font>, <font color=blue>false</font>, <font color=blue>false</font>, <font color=blue>true</font>, <font color=blue>true</font>, <font color=blue>true</font>, <font color=blue>true</font>];
<font color=blue>auto</font> separated = <u>byCategory</u>(<i>values</i>, <i>categories</i>);
<font color=blue>auto</font> tResult = studentsTTest(separated.<i>values</i>);
</pre>
<br><br>

</dd>
<dt><big><a name="byCategory.2"></a>ElementType!V[][2] <u>byCategory</u>(V, C)(V <i>values</i>, C <i>categories</i>) if (isInputRange!V &amp;&amp; isInputRange!C &amp;&amp; is(ElementType!C == bool));
</big></dt>
<dd>Special case implementation for when ElementType!C is boolean.<br><br>

</dd>
<dt><big><a name="auroc"></a>double <u>auroc</u>(R1, R2)(R1 <i>classATs</i>, R2 <i>classBTs</i>) if (isNumeric!(ElementType!R1) &amp;&amp; isNumeric!(ElementType!R2));
</big></dt>
<dd>Finds the area under the ROC curve (a curve with sensitivity on the Y-axis
 and 1 - specificity on the X-axis).  This is a useful metric for
 determining how well a test statistic discriminates between two classes.
 The following assumptions are made in this implementation:
<br><br>
1.  For some cutoff value c and test statistic T, your decision rule is of
     the form "Class A if T &gt; c, Class B if T &lt; c".
<br><br>

 2.  In the case of ties, i.e. if class A and class B both have an identical
     value, linear interpolation is used.  This is because changing the
     value of c infinitesimally will change both sensitivity and specificity
     in these cases.<br><br>

</dd>
<dt><big><a name="sign"></a>pure nothrow T <u>sign</u>(T)(T <i>num</i>) if (is(typeof(<i>num</i> &lt; 0)));
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="logFactorial"></a>double <u>logFactorial</u>(ulong <i>n</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="logNcomb"></a>double <u>logNcomb</u>(ulong <i>n</i>, ulong <i>k</i>);
</big></dt>
<dd>Log of (<i>n</i> choose <i>k</i>).<br><br>

</dd>
<dt><big><a name="Perm"></a>struct <u>Perm</u>(T);
</big></dt>
<dd>A struct that generates all possible permutations of a sequence.
<br><br>
<b>Notes:</b><br>
Permutations are output in undefined order.
<br><br>

The array returned by front is recycled across iterations.  To preserve
it across iterations, wrap this range using map!"a.dup" or
map!"a.idup".

<br><br>
<font color=red>BUGS:</font><br>
Only supports iterating over up to size_t.max permutations.
This means the max permutation length is 12 on 32-bit machines, or 20
on 64-bit.  This was a conscious tradeoff to allow this range to have a
length of type size_t, since iterating over such huge permutation spaces
would be insanely slow anyhow.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>double</font>[][] res;
<font color=blue>auto</font> perm = map!<font color=red>"a.dup"</font>(<u>Perm</u>!(<font color=blue>double</font>)([1.0, 2.0, 3.0][]));
<font color=blue>foreach</font>(p; perm) {
     res ~= p;
}

<font color=blue>auto</font> sorted = sort(res);
<font color=blue>assert</font>(sorted.canFind([1.0, 2.0, 3.0]));
<font color=blue>assert</font>(sorted.canFind([1.0, 3.0, 2.0]));
<font color=blue>assert</font>(sorted.canFind([2.0, 1.0, 3.0]));
<font color=blue>assert</font>(sorted.canFind([2.0, 3.0, 1.0]));
<font color=blue>assert</font>(sorted.canFind([3.0, 1.0, 2.0]));
<font color=blue>assert</font>(sorted.canFind([3.0, 2.0, 1.0]));
<font color=blue>assert</font>(sorted.length == 6);
</pre>
<br><br>

<dl><dt><big><a name="Perm.this"></a>this(U)(U <i>input</i>) if (isForwardRange!U);
</big></dt>
<dd>Generate permutations from an <i>input</i> range.
 Create a duplicate of this sequence
 so that the original sequence is not modified.<br><br>

</dd>
<dt><big><a name="Perm.front"></a>@property const(T)[] <u>front</u>();
</big></dt>
<dd>Returns the current permutation.  The array is const because it is
    recycled across iterations and modifying it would destroy the state of
    the permutation generator.<br><br>

</dd>
<dt><big><a name="Perm.popFront"></a>void <u>popFront</u>();
</big></dt>
<dd>Get the next permutation in the sequence.  This will overwrite the
    contents of the array returned by the last call to front.<br><br>

</dd>
<dt><big><a name="Perm.empty"></a>@property bool <u>empty</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Perm.length"></a>const pure nothrow @property size_t <u>length</u>();
</big></dt>
<dd>The number of permutations left.<br><br>

</dd>
<dt><big><a name="Perm.save"></a>@property typeof(this) <u>save</u>();
</big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><big><a name="perm"></a>auto <u>perm</u>(T...)(T <i>stuff</i>);
</big></dt>
<dd>Create a Perm struct from a range or of a set of bounds.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>auto</font> p = <u>perm</u>([1,2,3]);  <font color=green>// All permutations of [1,2,3].
</font><font color=blue>auto</font> p = <u>perm</u>(5);  <font color=green>// All permutations of [0,1,2,3,4].
</font><font color=blue>auto</font> p = <u>perm</u>(-1, 2); <font color=green>// All permutations of [-1, 0, 1].
</font></pre>
<br><br>

</dd>
<dt><big><a name="Comb"></a>struct <u>Comb</u>(T);
</big></dt>
<dd>Generates every possible combination of r elements of the given sequence, or
array indices from zero to N, depending on which c'tor is called.  Uses
an input range interface.
<br><br>
<b>Note:</b><br>
The buffer that is returned by front is recycled across iterations.
To duplicate it instead, use map!"a.dup" or map!"a.idup".

<br><br>
<font color=red>BUGS:</font><br>
Only supports iterating over up to size_t.max combinations.
This was a conscious tradeoff to allow this range to have a
length of type size_t, since iterating over such huge combination spaces
would be insanely slow anyhow.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>auto</font> comb1 = map!<font color=red>"a.dup"</font>(<u>Comb</u>!(<font color=blue>uint</font>)(5, 2));
<font color=blue>uint</font>[][] vals;
<font color=blue>foreach</font>(c; comb1) {
    vals ~= c;
}
<font color=blue>auto</font> sorted = sort(vals);
<font color=blue>assert</font>(sorted.canFind([0u,1]));
<font color=blue>assert</font>(sorted.canFind([0u,2]));
<font color=blue>assert</font>(sorted.canFind([0u,3]));
<font color=blue>assert</font>(sorted.canFind([0u,4]));
<font color=blue>assert</font>(sorted.canFind([1u,2]));
<font color=blue>assert</font>(sorted.canFind([1u,3]));
<font color=blue>assert</font>(sorted.canFind([1u,4]));
<font color=blue>assert</font>(sorted.canFind([2u,3]));
<font color=blue>assert</font>(sorted.canFind([2u,4]));
<font color=blue>assert</font>(sorted.canFind([3u,4]));
<font color=blue>assert</font>(sorted.length == 10);
</pre>
<br><br>

<dl><dt><big><a name="Comb.this"></a>this(uint <i>n</i>, uint <i>r</i>);
</big></dt>
<dd>Ctor to generate all possible combinations of array indices for a length <i>r</i>
    array.  This is a special-case optimization and is faster than simply
    using the other ctor to generate all length <i>r</i> combinations from
    seq(0, length).
<br><br>
For efficiency, uint is used instead of size_t since, on a 64-bit system,
    generating all possible combinations of an array bigger than uint.max
    wouldn't be feasible anyhow.<br><br>

</dd>
<dt><big><a name="Comb.this.2"></a>this(T[] <i>array</i>, uint <i>r</i>);
</big></dt>
<dd>General ctor.  <i>array</i> is a sequence from which to generate the
 combinations.  <i>r</i> is the length of the combinations to be generated.<br><br>

</dd>
<dt><big><a name="Comb.front"></a>@property const(T)[] <u>front</u>();
</big></dt>
<dd>Gets the current combination.<br><br>

</dd>
<dt><big><a name="Comb.popFront"></a>void <u>popFront</u>();
</big></dt>
<dd>Advances to the next combination.  The array returned by front will be
    overwritten with the new results.<br><br>

</dd>
<dt><big><a name="Comb.empty"></a>const pure nothrow @property bool <u>empty</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Comb.length"></a>const pure nothrow @property size_t <u>length</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Comb.save"></a>@property typeof(this) <u>save</u>();
</big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><big><a name="comb"></a>auto <u>comb</u>(T)(T <i>stuff</i>, uint <i>r</i>);
</big></dt>
<dd>Create a Comb struct from a range or of a set of bounds.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>auto</font> c1 = <u>comb</u>([1,2,3], 2);  <font color=green>// Any two elements from [1,2,3].
</font><font color=blue>auto</font> c2 = <u>comb</u>(5, 3);  <font color=green>// Any three elements from [0,1,2,3,4].
</font></pre>
<br><br>

</dd>
<dt><big><a name="toNumericRange"></a>ToNumericRange!R <u>toNumericRange</u>(R)(R <i>rangeIn</i>) if (isInputRange!R);
</big></dt>
<dd>Converts a range with arbitrary element types (usually strings) to a
 range of reals lazily.  Ignores any elements that could not be successfully
 converted.  Useful for creating an input range that can be used with this
 lib out of a File without having to read the whole file into an array first.
 The advantages to this over just using std.algorithm.map are that it's
 less typing and that it ignores non-convertible elements, such as blank
 lines.
<br><br>
If <i>rangeIn</i> is an inputRange, then the result of this function is an input
 range.  Otherwise, the result is a forward range.

<br><br>
<b>Note:</b><br>
The reason this struct doesn't have length or random access,
 even if this is supported by <i>rangeIn</i>, is because it has to be able to
 filter out non-convertible elements.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=green>// Perform a T-test to see whether the mean of the data being input as text
</font><font color=green>// from stdin is different from zero.  This data might not even fit in memory
</font><font color=green>// if it were read in eagerly.
</font>
<font color=blue>auto</font> myRange = <u>toNumericRange</u>( stdin.byLine() );
TestRes result = studentsTTest(myRange);
writeln(result);
</pre>
<br><br>

</dd>
<dt><big><a name="ToNumericRange"></a>struct <u>ToNumericRange</u>(R) if (isInputRange!R);
</big></dt>
<dd><br><br>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
