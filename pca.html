<html><head>
        <!-- Generated by Ddoc from ../../../.dub/packages/dstats-1.0.3/dstats/source/dstats/pca.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>dstats.pca</title>
        </head><body>
        <h1>dstats.pca</h1>
This module contains a basic implementation of principal component analysis,
based on the NIPALS algorithm.  This is fast when you only need the first
few components (which is usually the case since PCA's main uses are
visualization and dimensionality reduction).  However, convergence slows
drastically after the first few components have been removed and most of
the matrix is just noise.
<br><br>
<b>References:</b><br>
en.wikipedia.org/wiki/Principal_component_analysis#Computing_principal_components_iteratively

<br><br>
<b>Author:</b><br>
David Simcha<br><br>

<dl><dt><big><a name="PrincipalComponent"></a>struct <u>PrincipalComponent</u>;
</big></dt>
<dd>Result holder<br><br>

<dl><dt><big><a name="PrincipalComponent.x"></a>double[] <u>x</u>;
</big></dt>
<dd>The projection of the data onto the first principal component.<br><br>

</dd>
<dt><big><a name="PrincipalComponent.rotation"></a>double[] <u>rotation</u>;
</big></dt>
<dd>The vector representing the first principal component loadings.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="PrinCompOptions"></a>struct <u>PrinCompOptions</u>;
</big></dt>
<dd>Sets options for principal component analysis.  The default options are
also the values in <u>PrinCompOptions</u>.init.<br><br>

<dl><dt><big><a name="PrinCompOptions.zeroMean"></a>bool <u>zeroMean</u>;
</big></dt>
<dd>Center each column to zero mean.  Default value:  <b>true</b>.<br><br>

</dd>
<dt><big><a name="PrinCompOptions.unitVariance"></a>bool <u>unitVariance</u>;
</big></dt>
<dd>Scale each column to unit variance.  Note that, if this option is set to
    <b>true</b>, zeroMean is ignored and the mean of each column is set to zero even
    if zeroMean is <b>false</b>.  Default value:  <b>false</b>.<br><br>

</dd>
<dt><big><a name="PrinCompOptions.destructive"></a>bool <u>destructive</u>;
</big></dt>
<dd>Overwrite input matrix instead of copying.  Ignored if the matrix
    passed in does not have assignable, lvalue elements and centering or
    scaling is enabled.  Default value:  <b>false</b>.<br><br>

</dd>
<dt><big><a name="PrinCompOptions.transpose"></a>bool <u>transpose</u>;
</big></dt>
<dd>Effectively <u>transpose</u> the matrix.  If enabled, treat each column as a
    data points and each row as a dimension.  If disabled, do the opposite.
    Note that, if this is enabled, each row will be scaled and centered,
    not each column.  Default value:  <b>false</b>.<br><br>

</dd>
<dt><big><a name="PrinCompOptions.relError"></a>double <u>relError</u>;
</big></dt>
<dd>Relative error at which to stop the optimization procedure.  Default: 1e-4<br><br>

</dd>
<dt><big><a name="PrinCompOptions.absError"></a>double <u>absError</u>;
</big></dt>
<dd>Absolute error at which to stop the optimization procedure.  Default:  1e-5<br><br>

</dd>
<dt><big><a name="PrinCompOptions.maxIter"></a>uint <u>maxIter</u>;
</big></dt>
<dd>Maximum iterations for the optimization procedure.  After this many
    iterations, the algorithm gives up and calls teh solution "good enough"
    no matter what.  For exploratory analyses, "good enough" solutions
    can be had fast sometimes by making this value small.  Default:  uint.max<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="firstComponent"></a>PrincipalComponent <u>firstComponent</u>(Ror)(Ror <i>data</i>, PrinCompOptions <i>opts</i> = PrinCompOptions.init, PrincipalComponent <i>buf</i> = PrincipalComponent.init);
</big></dt>
<dd>Uses expectation-maximization to compute the first principal component of mat.
Since there are a lot of options, they are controlled by a PrinCompOptions
struct.  (See above.  PrinCompOptions.init contains the default values.)
To have the results returned in a pre-allocated space, pass an explicit value
for <i>buf</i>.<br><br>

</dd>
<dt><big><a name="Transposed"></a>enum <u>Transposed</u>: bool;
</big></dt>
<dd>Used for removeComponent().<br><br>

<dl><dt><big><a name="Transposed.yes"></a><u>yes</u></big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Transposed.no"></a><u>no</u></big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><big><a name="removeComponent"></a>void <u>removeComponent</u>(Ror, R)(Ror <i>data</i>, R <i>rotation</i>, Transposed <i>transposed</i> = Transposed.no);
</big></dt>
<dd>Remove the principal component specified by the given <i>rotation</i> vector from
<i>data</i>.  <i>data</i> must have assignable elements.  Transposed controls whether
<i>rotation</i> is considered a loading for the <i>transposed</i> matrix or the matrix
as-is.<br><br>

</dd>
<dt><big><a name="firstNComponents"></a>PrincipalComponent[] <u>firstNComponents</u>(Ror)(Ror <i>data</i>, uint <i>n</i>, PrinCompOptions <i>opts</i> = PrinCompOptions.init, PrincipalComponent[] <i>buf</i> = null);
</big></dt>
<dd>Computes the first N principal components of the matrix.  More efficient than
calling firstComponent and removeComponent repeatedly because copying and
transposing, if enabled, only happen once.<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
