<html><head>
        <!-- Generated by Ddoc from ../../../.dub/packages/color-0.0.5/color/std/experimental/normint.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>std.experimental.normint</title>
        </head><body>
        <h1>std.experimental.normint</h1>
This module implements support for normalized integers.
<br><br>
<b>Authors:</b><br>
Manu Evans
<br><br>
<b>License:</b><br>

<br><br>
<b>Source:</b><br>
<br><br>

<dl><dt><big><a name="isNormalizedIntegralType"></a>enum auto <u>isNormalizedIntegralType</u>(I);
</big></dt>
<dd>Check if <pre style="display:inline;" class="d_inline_code">I</pre> is a valid NormalizedInt type.
Valid integers are <pre style="display:inline;" class="d_inline_code">(u)byte</pre>, <pre style="display:inline;" class="d_inline_code">(u)short</pre>, <pre style="display:inline;" class="d_inline_code">(u)int</pre>. <pre style="display:inline;" class="d_inline_code">(u)long</pre> is not supported.<br><br>

</dd>
<dt><big><a name="NormalizedInt"></a>struct <u>NormalizedInt</u>(I) if (isNormalizedIntegralType!I);
</big></dt>
<dd>Normalized integers express a fractional range of values within an integer data type.
<br><br>
Unsigned integers map the values <pre style="display:inline;" class="d_inline_code">[0, I.max]</pre> to the fractional values <pre style="display:inline;" class="d_inline_code">[0.0, 1.0]</pre> in equal increments.<br>
Signed integers represent the values <pre style="display:inline;" class="d_inline_code">[-I.max, I.max]</pre> to fractional values <pre style="display:inline;" class="d_inline_code">[-1.0, 1.0]</pre> in equal increments. <pre style="display:inline;" class="d_inline_code">I.min</pre> is outside the nominal integer range and is clamped to represent <pre style="display:inline;" class="d_inline_code">-1.0</pre>.

<br><br>
<b>Params:</b><br>
<table></table><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> x = <u>NormalizedInt</u>!<font color=blue>ubyte</font>(200);
<font color=blue>auto</font> y = <u>NormalizedInt</u>!<font color=blue>ubyte</font>(50);

<font color=blue>auto</font> z = x + y;                      <font color=blue>assert</font>(z == 250);                 <font color=green>// add as expected
</font>z += y;                              <font color=blue>assert</font>(z == 255);                 <font color=green>// overflow saturates
</font>                                     <font color=blue>assert</font>(<font color=blue>cast</font>(<font color=blue>float</font>)z == 1.0);      <font color=green>// maximum value is floating point 1.0
</font>z -= x;                              <font color=blue>assert</font>(z == 55);                  <font color=green>// subtract as expected
</font>z -= x;                              <font color=blue>assert</font>(z == 0);                   <font color=green>// underflow saturates
</font>z = y * 2;                           <font color=blue>assert</font>(z == 100);                 <font color=green>// multiply by integer
</font>z = x * 0.5;                         <font color=blue>assert</font>(z == 100);                 <font color=green>// multiply by float
</font>z *= 3;                              <font color=blue>assert</font>(z == 255);                 <font color=green>// multiply overflow saturates
</font>z *= y;                              <font color=blue>assert</font>(z == 50);                  <font color=green>// multiply is performed in normalized space
</font>z *= y;                              <font color=blue>assert</font>(z == 9);                   <font color=green>// multiplication rounds *down*
</font>z /= 2;                              <font color=blue>assert</font>(z == 4);                   <font color=green>// division works as expected, rounds down
</font>z /= y;                              <font color=blue>assert</font>(z == 20);                  <font color=green>// division is performed in normalized space
</font>z /= y * y;                          <font color=blue>assert</font>(z == 255);                 <font color=green>// division overflow saturates
</font>z = -z;                              <font color=blue>assert</font>(z == 0);                   <font color=green>// unsigned negation saturates at zero
</font>
<font color=blue>auto</font> u = <u>NormalizedInt</u>!<font color=blue>short</font>(-1.0);
<font color=blue>auto</font> v = <u>NormalizedInt</u>!<font color=blue>short</font>(0.5);

<font color=blue>auto</font> w = <font color=blue>cast</font>(<u>NormalizedInt</u>!<font color=blue>short</font>)x; <font color=blue>assert</font>(w == 25700);               <font color=green>// casting to higher precision extends bit-pattern to preserve uniformity
</font>w = -w;                              <font color=blue>assert</font>(w == -25700);              <font color=green>// negation works as expected
</font>w *= 2;                              <font color=blue>assert</font>(w == -32767 &amp;&amp; w == -1.0); <font color=green>// overflow saturates
</font>w *= -0.5;                           <font color=blue>assert</font>(w == 16384 &amp;&amp; w &gt; 0.5);    <font color=green>// 0.5 is not exactly representable (odd number of positive integers)
</font>w = w^^0.0;                          <font color=blue>assert</font>(w == 1.0);                 <font color=green>// pow as expected
</font>
<font color=green>// check floating poing comparisons
</font><font color=blue>static</font> <font color=blue>assert</font>(<u>NormalizedInt</u>!<font color=blue>ubyte</font>(0xFF) == 1.0);
<font color=blue>static</font> <font color=blue>assert</font>(<u>NormalizedInt</u>!<font color=blue>ubyte</font>(0x00) == 0.0);
<font color=blue>static</font> <font color=blue>assert</font>(<u>NormalizedInt</u>!<font color=blue>ubyte</font>(0x80) &gt; 0.5);
<font color=blue>static</font> <font color=blue>assert</font>(<u>NormalizedInt</u>!<font color=blue>ubyte</font>(0x7F) &lt; 0.5);

<font color=blue>static</font> <font color=blue>assert</font>(<u>NormalizedInt</u>!<font color=blue>byte</font>(127) == 1.0);
<font color=blue>static</font> <font color=blue>assert</font>(<u>NormalizedInt</u>!<font color=blue>byte</font>(-127) == -1.0);
<font color=blue>static</font> <font color=blue>assert</font>(<u>NormalizedInt</u>!<font color=blue>byte</font>(-128) == -1.0);
<font color=blue>static</font> <font color=blue>assert</font>(<u>NormalizedInt</u>!<font color=blue>byte</font>(0x00) == 0.0);
<font color=blue>static</font> <font color=blue>assert</font>(<u>NormalizedInt</u>!<font color=blue>byte</font>(0x40) &gt; 0.5);
<font color=blue>static</font> <font color=blue>assert</font>(<u>NormalizedInt</u>!<font color=blue>byte</font>(0x3F) &lt; 0.5);
</pre>
<br><br>
<dl><dt><big><a name="NormalizedInt.IntType"></a>alias <u>IntType</u> = I;
</big></dt>
<dd>Integral storage type.<br><br>

</dd>
<dt><big><a name="NormalizedInt.max"></a>enum auto <u>max</u>;
</big></dt>
<dd>Maximum integral value.<br><br>

</dd>
<dt><big><a name="NormalizedInt.min"></a>enum auto <u>min</u>;
</big></dt>
<dd>Minimum integral value.<br><br>

</dd>
<dt><big><a name="NormalizedInt.max_float"></a>enum auto <u>max_float</u>;
</big></dt>
<dd>Maximum floating point value.<br><br>

</dd>
<dt><big><a name="NormalizedInt.min_float"></a>enum auto <u>min_float</u>;
</big></dt>
<dd>Minimum floating point value.<br><br>

</dd>
<dt><big><a name="NormalizedInt.this"></a>this(I <i>value</i>);
</big></dt>
<dd>Construct a <pre style="display:inline;" class="d_inline_code">NormalizedInt</pre> from an integer representation.<br><br>

</dd>
<dt><big><a name="NormalizedInt.this.2"></a>this(F)(F <i>value</i>) if (isFloatingPoint!F);
</big></dt>
<dd>Construct a <pre style="display:inline;" class="d_inline_code">NormalizedInt</pre> from a floating point representation. The <i>value</i> is clamped to the range <pre style="display:inline;" class="d_inline_code">[min, max]</pre>.<br><br>

</dd>
<dt><big><a name="NormalizedInt.opUnary"></a>const NormalizedInt!I <u>opUnary</u>(string op)();
</big></dt>
<dd>Unary operators.<br><br>

</dd>
<dt><big><a name="NormalizedInt.opBinary"></a>const NormalizedInt!I <u>opBinary</u>(string op)(NormalizedInt!I <i>rh</i>) if (op == "+" || op == "-");
</big></dt>
<dd>Binary operators.<br><br>

</dd>
<dt><big><a name="NormalizedInt.opBinary.2"></a>const NormalizedInt!I <u>opBinary</u>(string op)(NormalizedInt!I <i>rh</i>) if (op == "*" || op == "^^");
</big></dt>
<dd>Binary operators.<br><br>

</dd>
<dt><big><a name="NormalizedInt.opBinary.3"></a>const NormalizedInt!I <u>opBinary</u>(string op)(NormalizedInt!I <i>rh</i>) if (op == "/" || op == "%");
</big></dt>
<dd>Binary operators.<br><br>

</dd>
<dt><big><a name="NormalizedInt.opBinary.4"></a>const NormalizedInt!I <u>opBinary</u>(string op, T)(T <i>rh</i>) if (isNormalizedIntegralType!T &amp;&amp; op == "*");
</big></dt>
<dd>Binary operators.<br><br>

</dd>
<dt><big><a name="NormalizedInt.opBinary.5"></a>const NormalizedInt!I <u>opBinary</u>(string op, T)(T <i>rh</i>) if (isNormalizedIntegralType!T &amp;&amp; (op == "/" || op == "%"));
</big></dt>
<dd>Binary operators.<br><br>

</dd>
<dt><big><a name="NormalizedInt.opBinary.6"></a>const NormalizedInt!I <u>opBinary</u>(string op, F)(F <i>rh</i>) if (isFloatingPoint!F &amp;&amp; (op == "*" || op == "/" || op == "%" || op == "^^"));
</big></dt>
<dd>Binary operators.<br><br>

</dd>
<dt><big><a name="NormalizedInt.opBinary.7"></a>const NormalizedInt!I <u>opBinary</u>(string op)(NormalizedInt!I <i>rh</i>) if (op == "|" || op == "&amp;" || op == "^");
</big></dt>
<dd>Binary operators.<br><br>

</dd>
<dt><big><a name="NormalizedInt.opBinary.8"></a>const NormalizedInt!I <u>opBinary</u>(string op)(int <i>rh</i>) if (op == "|" || op == "&amp;" || op == "^" || op == "&lt;&lt;" || op == "&gt;&gt;" || op == "&gt;&gt;&gt;");
</big></dt>
<dd>Binary operators.<br><br>

</dd>
<dt><big><a name="NormalizedInt.opEquals"></a>const bool <u>opEquals</u>(NormalizedInt!I <i>rh</i>);
</big></dt>
<dd>Equality operators.<br><br>

</dd>
<dt><big><a name="NormalizedInt.opEquals.2"></a>const bool <u>opEquals</u>(T)(T <i>rh</i>) if (isNormalizedIntegralType!T);
</big></dt>
<dd>Integral equality operator.<br>
    If <pre style="display:inline;" class="d_inline_code"><i>rh</i></pre> is outside of the integral range, <pre style="display:inline;" class="d_inline_code"><i>rh</i></pre> will not be clamped and comparison will return <pre style="display:inline;" class="d_inline_code"><b>false</b></pre>.<br><br>

</dd>
<dt><big><a name="NormalizedInt.opEquals.3"></a>const bool <u>opEquals</u>(F)(F <i>rh</i>) if (isFloatingPoint!F);
</big></dt>
<dd>Floating point equality operator.<br>
    If <pre style="display:inline;" class="d_inline_code"><i>rh</i></pre> is outside of the nominal range, <pre style="display:inline;" class="d_inline_code"><i>rh</i></pre> will not be clamped and comparison will return <pre style="display:inline;" class="d_inline_code"><b>false</b></pre>.<br><br>

</dd>
<dt><big><a name="NormalizedInt.opCmp"></a>const int <u>opCmp</u>(NormalizedInt!I <i>rh</i>);
</big></dt>
<dd>Comparison operators.<br><br>

</dd>
<dt><big><a name="NormalizedInt.opCmp.2"></a>const int <u>opCmp</u>(T)(T <i>rh</i>) if (isNormalizedIntegralType!T);
</big></dt>
<dd>Comparison operators.<br><br>

</dd>
<dt><big><a name="NormalizedInt.opCmp.3"></a>const int <u>opCmp</u>(F)(F <i>rh</i>) if (isFloatingPoint!F);
</big></dt>
<dd>Comparison operators.<br><br>

</dd>
<dt><big><a name="NormalizedInt.opOpAssign"></a>ref NormalizedInt!I <u>opOpAssign</u>(string op, T)(T <i>rh</i>) if (is(T == NormalizedInt!I) || isFloatingPoint!T || isNormalizedIntegralType!T);
</big></dt>
<dd>Binary assignment operators.<br><br>

</dd>
<dt><big><a name="NormalizedInt.opCast"></a>const NormInt <u>opCast</u>(NormInt)() if (is(NormInt == NormalizedInt!T, T));
</big></dt>
<dd>Cast between <pre style="display:inline;" class="d_inline_code">NormalizedInt</pre> types.<br><br>

</dd>
<dt><big><a name="NormalizedInt.opCast.2"></a>const F <u>opCast</u>(F)() if (isFloatingPoint!F);
</big></dt>
<dd>Floating point cast operator.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="convertNormInt"></a>To <u>convertNormInt</u>(To, From)(From <i>i</i>) if (isIntegral!From &amp;&amp; isIntegral!To);
</big></dt>
<dd>Convert values between normalized integer types.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=green>// unsigned -&gt; unsigned
</font><font color=blue>static</font> <font color=blue>assert</font>(<u>convertNormInt</u>!<font color=blue>ubyte</font>(<font color=blue>ushort</font>(0x3765)) == 0x37);
<font color=blue>static</font> <font color=blue>assert</font>(<u>convertNormInt</u>!<font color=blue>ushort</font>(<font color=blue>ubyte</font>(0x37)) == 0x3737);
<font color=blue>static</font> <font color=blue>assert</font>(<u>convertNormInt</u>!<font color=blue>uint</font>(<font color=blue>ubyte</font>(0x35)) == 0x35353535);

<font color=green>// signed -&gt; unsigned
</font><font color=blue>static</font> <font color=blue>assert</font>(<u>convertNormInt</u>!<font color=blue>ubyte</font>(<font color=blue>short</font>(-61)) == 0);
<font color=blue>static</font> <font color=blue>assert</font>(<u>convertNormInt</u>!<font color=blue>ubyte</font>(<font color=blue>short</font>(0x3795)) == 0x6F);
<font color=blue>static</font> <font color=blue>assert</font>(<u>convertNormInt</u>!<font color=blue>ushort</font>(<font color=blue>byte</font>(0x37)) == 0x6EDD);
<font color=blue>static</font> <font color=blue>assert</font>(<u>convertNormInt</u>!<font color=blue>uint</font>(<font color=blue>byte</font>(0x35)) == 0x6AD5AB56);

<font color=green>// unsigned -&gt; signed
</font><font color=blue>static</font> <font color=blue>assert</font>(<u>convertNormInt</u>!<font color=blue>byte</font>(<font color=blue>ushort</font>(0x3765)) == 0x1B);
<font color=blue>static</font> <font color=blue>assert</font>(<u>convertNormInt</u>!<font color=blue>short</font>(<font color=blue>ubyte</font>(0x37)) == 0x1B9B);
<font color=blue>static</font> <font color=blue>assert</font>(<u>convertNormInt</u>!<font color=blue>int</font>(<font color=blue>ubyte</font>(0x35)) == 0x1A9A9A9A);

<font color=green>// signed -&gt; signed
</font><font color=blue>static</font> <font color=blue>assert</font>(<u>convertNormInt</u>!<font color=blue>short</font>(<font color=blue>byte</font>(-127)) == -32767);
<font color=blue>static</font> <font color=blue>assert</font>(<u>convertNormInt</u>!<font color=blue>short</font>(<font color=blue>byte</font>(-128)) == -32767);
<font color=blue>static</font> <font color=blue>assert</font>(<u>convertNormInt</u>!<font color=blue>byte</font>(<font color=blue>short</font>(0x3795)) == 0x37);
<font color=blue>static</font> <font color=blue>assert</font>(<u>convertNormInt</u>!<font color=blue>byte</font>(<font color=blue>short</font>(-28672)) == -112);
<font color=blue>static</font> <font color=blue>assert</font>(<u>convertNormInt</u>!<font color=blue>short</font>(<font color=blue>byte</font>(0x37)) == 0x376E);
<font color=blue>static</font> <font color=blue>assert</font>(<u>convertNormInt</u>!<font color=blue>short</font>(<font color=blue>byte</font>(-109)) == -28123);
</pre>
<br><br>
</dd>
<dt><big><a name="floatToNormInt"></a>To <u>floatToNormInt</u>(To, From)(From <i>f</i>) if (isFloatingPoint!From &amp;&amp; isIntegral!To);
</big></dt>
<dd>Convert a float to a normalized integer.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> <font color=blue>assert</font>(<u>floatToNormInt</u>!<font color=blue>ubyte</font>(0.5) == 0x80);
</pre>
<br><br>
</dd>
<dt><big><a name="normIntToFloat"></a>To <u>normIntToFloat</u>(To, From)(From <i>i</i>) if (isIntegral!From &amp;&amp; isFloatingPoint!To);
</big></dt>
<dd>Convert a normalized integer to a float.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> <font color=blue>assert</font>(<u>normIntToFloat</u>!(<font color=blue>double</font>, <font color=blue>ubyte</font>)(0xFF) == 1.0);
</pre>
<br><br>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. Copyright (c) 2015, Manu Evans.
</small>
        </body></html>
