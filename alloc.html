<html><head>
        <!-- Generated by Ddoc from ../../../.dub/packages/dstats-1.0.3/dstats/source/dstats/alloc.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>dstats.alloc</title>
        </head><body>
        <h1>dstats.alloc</h1>
Stuff having to do with memory management.  Mostly a copy of RegionAllocator
for now until it gets into Phobos, as well as some RegionAllocator-specific
data structures.
<br><br>
<b>Author:</b><br>
David Simcha<br><br>

<dl><dt><big><a name="appendDelOld"></a>void <u>appendDelOld</u>(T, U)(ref T[] <i>to</i>, U <i>from</i>) if (Appends!(T, U));
</big></dt>
<dd>Appends <i>to</i> an array, deleting the old array if it has <i>to</i> be realloced.<br><br>

</dd>
<dt><big><a name="HashRange"></a>struct <u>HashRange</u>(K, S, bool vals = false);
</big></dt>
<dd>Forward range struct for iterating over the keys or values of a
 StackHash or StackSet.  The lifetime of this object must not exceed that
 of the underlying StackHash or StackSet.<br><br>

<dl><dt><big><a name="HashRange.popFront"></a>void <u>popFront</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="HashRange.front"></a>@property ref Unqual!K <u>front</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="HashRange.empty"></a>@property bool <u>empty</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="HashRange.length"></a>@property size_t <u>length</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="HashRange.save"></a>@property typeof(this) <u>save</u>();
</big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><big><a name="StackHash"></a>struct <u>StackHash</u>(K, V);
</big></dt>
<dd>A hash table that allocates its memory on RegionAllocator.  Good for building a
 temporary hash tables that will not escape the current scope.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>auto</font> alloc = newRegionAllocator();
<font color=blue>auto</font> ss = <u>StackHash</u>!(<font color=blue>uint</font>)(5, alloc);
<font color=blue>foreach</font>(i; 0..5) {
    ss[i]++;
}
<font color=blue>assert</font>(ss[3] == 1);
</pre>

<br><br>
<b>Warning:</b><br>
 This implementation places removed nodes on an internal free list and
 recycles them, since there is no way to delete RegionAllocator-allocated data
 in a non-LIFO order.  Therefore, you may not retain the address of a
 variable stored in a <u>StackHash</u> after deleting it from the StachHash.
 For example, DO NOT do this:
<pre class="d_code">SomeType* myPtr = &amp;(myStackHash[<font color=red>"foo"</font>]);
myStackHash.remove(<font color=red>"foo"</font>);
*myPtr = someValue;
</pre>
<br><br>

<dl><dt><big><a name="StackHash.this"></a>this(size_t <i>nElem</i>, RegionAllocator <i>alloc</i>);
</big></dt>
<dd>Due to the nature of RegionAllocator, you must specify on object creation
 the approximate number of elements your table will have.  Too large a
 number will waste space and incur poor cache performance.  Too low a
 number will make this struct perform like a linked list.  Generally,
 if you're building a table from some other range, some fraction of the
 size of that range is a good guess.<br><br>

</dd>
<dt><big><a name="StackHash.opIndex"></a>ref V <u>opIndex</u>(K <i>key</i>);
</big></dt>
<dd>Index an element of the range.  If it does not exist, it will be created
 and initialized to V.init.<br><br>

</dd>
<dt><big><a name="StackHash.opIndexAssign"></a>V <u>opIndexAssign</u>(V <i>val</i>, K <i>key</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="StackHash.opIn_r"></a>V* <u>opIn_r</u>(K <i>key</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="StackHash.remove"></a>void <u>remove</u>(K <i>key</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="StackHash.keys"></a>auto <u>keys</u>();
</big></dt>
<dd>Returns a forward range to iterate over the <u>keys</u> of this table.
 The lifetime of this range must not exceed the lifetime of this
 StackHash.<br><br>

</dd>
<dt><big><a name="StackHash.values"></a>auto <u>values</u>();
</big></dt>
<dd>Returns a forward range to iterate over the <u>values</u> of this table.
 The lifetime of this range must not exceed the lifetime of this
 StackHash.<br><br>

</dd>
<dt><big><a name="StackHash.length"></a>const @property size_t <u>length</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="StackHash.get"></a>V <u>get</u>(K <i>key</i>, lazy V <i>defaultValue</i>);
</big></dt>
<dd>Attempt to look up a <i>key</i> and return a default value if the <i>key</i> is not
    present.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="StackSet"></a>struct <u>StackSet</u>(K);
</big></dt>
<dd>A hash set that allocates its memory on RegionAllocator.  Good for building a
 temporary set that will not escape the current scope.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>auto</font> alloc = newRegionAllocator();
<font color=blue>auto</font> ss = <u>StackSet</u>!(<font color=blue>uint</font>)(5, alloc);
<font color=blue>foreach</font>(i; 0..5) {
    ss.insert(i);
}
<font color=blue>assert</font>(3 <font color=blue>in</font> ss);
</pre>
<br><br>

<dl><dt><big><a name="StackSet.this"></a>this(size_t <i>nElem</i>, RegionAllocator <i>alloc</i>);
</big></dt>
<dd>Due to the nature of RegionAllocator, you must specify on object creation
 the approximate number of elements your set will have.  Too large a
 number will waste space and incur poor cache performance.  Too low a
 number will make this struct perform like a linked list.  Generally,
 if you're building a set from some other range, some fraction of the
 size of that range is a good guess.<br><br>

</dd>
<dt><big><a name="StackSet.insert"></a>void <u>insert</u>(K <i>key</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="StackSet.elems"></a>auto <u>elems</u>();
</big></dt>
<dd>Returns a forward range of the elements of this struct.  The range's
 lifetime must not exceed the lifetime of this object.<br><br>

</dd>
<dt><big><a name="StackSet.opIn_r"></a>bool <u>opIn_r</u>(K <i>key</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="StackSet.remove"></a>void <u>remove</u>(K <i>key</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="StackSet.length"></a>@property size_t <u>length</u>();
</big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><big><a name="StackTree"></a>struct <u>StackTree</u>(T, alias key = "a", alias compFun = "a &lt; b");
</big></dt>
<dd>An AVL tree implementation on top of RegionAllocator.  If elements are removed,
 they are stored on an internal free list and recycled when new elements
 are added to the tree.
<br><br>
Template paramters:
<br><br>

 T = The type to be stored in the tree.
<br><br>

 key = Function to access the key that what you're storing is to be compared
       on.
<br><br>

 compFun = The function for comparing keys.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>struct</font> StringNum {
    string someString;
    <font color=blue>uint</font> num;
}

<font color=green>// Create a StackTree of StringNums, sorted in descending order, using
</font><font color=green>// someString for comparison.
</font><font color=blue>auto</font> alloc = newRegionAllocator();
<font color=blue>auto</font> myTree = <u>StackTree</u>!(StringNum, <font color=red>"a.someString"</font>, <font color=red>"a &gt; b"</font>)(alloc);

<font color=green>// Add some elements.
</font>myTree.insert( StringNum(<font color=red>"foo"</font>, 1));
myTree.insert( StringNum(<font color=red>"bar"</font>, 2));
myTree.insert( StringNum(<font color=red>"foo"</font>, 3));

<font color=blue>assert</font>(myTree.find(<font color=red>"foo"</font>) == StringNum(<font color=red>"foo"</font>, 3));
<font color=blue>assert</font>(myTree.find(<font color=red>"bar"</font>) == StringNum(<font color=red>"bar"</font>, 2));
</pre>

<br><br>
<b>Note:</b><br>
This tree supports a compile-time interface similar to StackSet
 and can be used as a finite set implementation.

<br><br>
<b>Warning:</b><br>
 This implementation places removed nodes on an internal free list and
 recycles them, since there is no way to delete RegionAllocator-allocated data
 in a non-LIFO order.  Therefore, you may not retain the address of a
 variable stored in a <u>StackTree</u> after deleting it from the <u>StackTree</u>.
 For example, DO NOT do this:
<pre class="d_code">SomeType* myPtr = <font color=red>"foo"</font> <font color=blue>in</font> myTree;
myTree.remove(<font color=red>"foo"</font>);
*myPtr = someValue;
</pre>
<br><br>

<dl><dt><big><a name="StackTree.this"></a>this(RegionAllocator <i>alloc</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="StackTree.insert"></a>void <u>insert</u>(T <i>toInsert</i>);
</big></dt>
<dd>Insert an element.<br><br>

</dd>
<dt><big><a name="StackTree.remove"></a>void <u>remove</u>(U)(U <i>whatToRemove</i>);
</big></dt>
<dd>Remove an element from this tree.  The type of U is expected to be the
 type of the key that this tree is sorted on.<br><br>

</dd>
<dt><big><a name="StackTree.find"></a>T <u>find</u>(U)(U <i>whatToFind</i>);
</big></dt>
<dd>Find an element and return it.  Throw an exception if it is not
 present.  U is expected to be the type of the key that this tree is
 sorted on.<br><br>

</dd>
<dt><big><a name="StackTree.opIn_r"></a>T* <u>opIn_r</u>(U)(U <i>whatToFind</i>);
</big></dt>
<dd>Find an element and return a pointer to it, or <b>null</b> if not present.<br><br>

</dd>
<dt><big><a name="StackTree.opApply"></a>int <u>opApply</u>(int delegate(ref T) <i>dg</i>);
</big></dt>
<dd>Iterate over the elements of this tree in sorted order.<br><br>

</dd>
<dt><big><a name="StackTree.length"></a>const pure nothrow @property size_t <u>length</u>();
</big></dt>
<dd>Number of elements in the tree.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="TreeAaIter"></a>struct <u>TreeAaIter</u>(T, alias mapFun);
</big></dt>
<dd>Struct that iterates over keys or values of a StackTreeAA.
<br><br>
<font color=red>BUGS:</font><br>
Uses opApply instead of the more flexible ranges, because I
 haven't figured out how to iterate efficiently and in sorted order over a
 tree without control of the stack.<br><br>

<dl><dt><big><a name="TreeAaIter.opApply"></a>int <u>opApply</u>(int delegate(ref IterType) <i>dg</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="TreeAaIter.length"></a>const pure nothrow @property size_t <u>length</u>();
</big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><big><a name="StackTreeAA"></a>struct <u>StackTreeAA</u>(K, V);
</big></dt>
<dd>An associative array implementation based on StackTree.  Lookups and
 insertions are O(log N).  This is significantly slower in both theory and
 practice than StackHash, but you may want to use it if:
<br><br>
1.  You don't know the approximate size of the table you will be creating
     in advance.  Unlike StackHash, this AA implementation does not need
     to pre-allocate anything.
<br><br>

 2.  You care more about worst-case performance than average-case
     performance.
<br><br>

 3.  You have a good comparison function for your type, but not a good hash
     function.<br><br>

<dl><dt><big><a name="StackTreeAA.this"></a>this(RegionAllocator <i>alloc</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="StackTreeAA.opIndex"></a>ref V <u>opIndex</u>(K <i>key</i>);
</big></dt>
<dd>Looks up <i>key</i> in the table, returns it by reference.  If it does not
 exist, it will be created and initialized to V.init.  This is handy,
 for example, when counting things with integer types.<br><br>

</dd>
<dt><big><a name="StackTreeAA.opIndexAssign"></a>V <u>opIndexAssign</u>(V <i>val</i>, K <i>key</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="StackTreeAA.opIn_r"></a>V* <u>opIn_r</u>(K <i>key</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="StackTreeAA.remove"></a>void <u>remove</u>(K <i>key</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="StackTreeAA.length"></a>const pure nothrow @property size_t <u>length</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="StackTreeAA.keys"></a>@property TreeAaIter!(typeof(tree), "a.key") <u>keys</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="StackTreeAA.values"></a>@property TreeAaIter!(typeof(tree), getVal) <u>values</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="StackTreeAA.opApply"></a>int <u>opApply</u>(int delegate(ref Unqual!K, ref Unqual!V) <i>dg</i>);
</big></dt>
<dd>Iterate over both the keys and values of this associative array.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="RegionAllocatorException"></a>class <u>RegionAllocatorException</u>: <u>object.Exception</u>;
</big></dt>
<dd>The exception that is thrown on invalid use of  and
.  This exception is not thrown on out of memory.
An  is thrown instead.<br><br>

</dd>
<dt><big><a name="GCScan"></a>enum <u>GCScan</u>: bool;
</big></dt>
<dd>This flag determines whether a given  is scanned for
pointers by the garbage collector (GC).  If yes, the entire stack is scanned,
not just the part currently in use, since there is currently no efficient way to
modify the bounds of a GC region.  The stack is scanned conservatively, meaning
that any bit pattern that would point to GC-allocated memory if interpreted as
a pointer is considered to be a pointer.  This can result in GC-allocated
memory being retained when it should be freed.  Due to these caveats,
it is recommended that any stack scanned by the GC be small and/or short-lived.<br><br>

<dl><dt><big><a name="GCScan.no"></a><u>no</u></big></dt>
<dd><br><br>
</dd>
<dt><big><a name="GCScan.yes"></a><u>yes</u></big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><big><a name="RegionAllocatorStack"></a>struct <u>RegionAllocatorStack</u>;
</big></dt>
<dd>This object represents a segmented stack.  Memory can be allocated from this
stack using a  object.  Multiple
 objects may be created per
 but each  uses a single
.
<br><br>
For most use cases it's convenient to use the default thread-local
instance of , which is lazily instantiated on
the first call to the global function
.  Occasionally it may be useful
to have multiple independent stacks in one thread, in which case a
 can be created manually.
<br><br>

 is reference counted and has reference semantics.
When the last copy of a given instance goes out of scope, the memory
held by the  instance is released back to the
heap.  This cannot happen before memory allocated to a 
instance is released back to the stack, because a 
holds a copy of the  instance it uses.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>import</font> std.regionallocator;

<font color=blue>void</font> main() {
    fun1();
}

<font color=blue>void</font> fun1() {
    <font color=blue>auto</font> stack = <u>RegionAllocatorStack</u>(1_048_576, GCScan.no);
    fun2(stack);

    <font color=green>// At the end of fun1, the last copy of the RegionAllocatorStack
</font>    <font color=green>// instance pointed to by stack goes out of scope.  The memory
</font>    <font color=green>// held by stack is released back to the heap.
</font>}

<font color=blue>void</font> fun2(<u>RegionAllocatorStack</u> stack) {
    <font color=blue>auto</font> alloc = stack.newRegionAllocator();
    <font color=blue>auto</font> arr = alloc.newArray!(<font color=blue>double</font>[])(1_024);

    <font color=green>// At the end of fun2, the last copy of the RegionAllocator instance
</font>    <font color=green>// pointed to by alloc goes out of scope.  The memory used by arr
</font>    <font color=green>// is released back to stack.
</font>}
</pre>
<br><br>

<dl><dt><big><a name="RegionAllocatorStack.this"></a>this(size_t <i>segmentSize</i>, GCScan <i>shouldScan</i>);
</big></dt>
<dd>Create a new  with a given segment size in bytes.<br><br>

</dd>
<dt><big><a name="RegionAllocatorStack.newRegionAllocator"></a>RegionAllocator <u>newRegionAllocator</u>();
</big></dt>
<dd>Creates a new  region using this stack.<br><br>

</dd>
<dt><big><a name="RegionAllocatorStack.gcScanned"></a>const pure nothrow @property @safe bool <u>gcScanned</u>();
</big></dt>
<dd>Whether this stack is scanned by the garbage collector.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="threadLocalSegmentSize"></a>nothrow @property @safe size_t <u>threadLocalSegmentSize</u>();
<br>@property @safe size_t <u>threadLocalSegmentSize</u>(size_t <i>newSize</i>);
</big></dt>
<dd>These properties get and set the segment size of the default thread-local
 instance.  The default size is 4 megabytes.
The setter is only effective before the global function
 has been called for the first time in the current
thread.  Attempts to set this property after the first call to this
function from the current thread throw a .<br><br>

</dd>
<dt><big><a name="scanThreadLocalStack"></a>nothrow @property @safe bool <u>scanThreadLocalStack</u>();
<br>@property @safe bool <u>scanThreadLocalStack</u>(bool <i>shouldScan</i>);
</big></dt>
<dd>These properties determine whether the default thread-local
 instance is scanned by the garbage collector.
The default is no.  In most cases, scanning a stack this long-lived is not
recommended, as it will cause too many <b>false</b> pointers.  (See  for details.)
<br><br>
The setter is only effective before the global function
 has been called for the first time in the current
thread.  Attempts to set this property after the first call to this
function from the current thread throw a .<br><br>

</dd>
<dt><big><a name="RegionAllocator"></a>struct <u>RegionAllocator</u>;
</big></dt>
<dd>This struct provides an interface to the  functionality
and enforces scoped deletion.  A new instance using the thread-local
 instance is created using the global
 function.  A new instance using
an explicitly created  is created using
.
<br><br>
Each instance has reference semantics in that any copy will allocate from the
same memory.  When the last copy of an instance goes out of scope, all memory
allocated via that instance is freed.  Only the most recently created
still-existing  using a given 
may be used to allocate and free memory at any given time.  Deviations
from this model result in a  being thrown.
<br><br>

An uninitialized  (for example )
has semantics similar to a <b>null</b> pointer.  It may be assigned to or passed to
a function.  However, any attempt to call a method will result in a
 being thrown.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>void</font> foo() {
    <font color=blue>auto</font> alloc = newRegionAllocator();
    <font color=blue>auto</font> ptr1 = bar(alloc);
    <font color=blue>auto</font> ptr2 = alloc.allocate(42);

    <font color=green>// The last copy of the RegionAllocator object used to allocate ptr1
</font>    <font color=green>// and ptr2 is going out of scope here.  The memory pointed to by
</font>    <font color=green>// both ptr1 and ptr2 will be freed.
</font>}

<font color=blue>void</font>* bar(<u>RegionAllocator</u> alloc) {
    <font color=blue>auto</font> ret = alloc.allocate(42);

    <font color=blue>auto</font> alloc2 = newRegionAllocator();
    <font color=blue>auto</font> ptr3 = alloc2.allocate(42);

    <font color=green>// ptr3 was allocated using alloc2, which is going out of scope.
</font>    <font color=green>// Its memory will therefore be freed.  ret was allocated using alloc.
</font>    <font color=green>// A copy of this RegionAllocator is still alive in foo() after
</font>    <font color=green>// bar() executes.  Therefore, ret will not be freed on returning and
</font>    <font color=green>// is still valid after bar() returns.
</font>
    <font color=blue>return</font> ret;
}

<font color=blue>void</font>* thisIsSafe() {
    <font color=green>// This is safe because the two RegionAllocator objects being used
</font>    <font color=green>// are using two different RegionAllocatorStack objects.
</font>    <font color=blue>auto</font> alloc = newRegionAllocator();
    <font color=blue>auto</font> ptr1 = alloc.allocate(42);

    <font color=blue>auto</font> stack = RegionAllocatorStack(1_048_576, GCScan.no);
    <font color=blue>auto</font> alloc2 = stack.newRegionAllocator();

    <font color=blue>auto</font> ptr2 = alloc2.allocate(42);
    <font color=blue>auto</font> ptr3 = alloc.allocate(42);
}

<font color=blue>void</font>* dontDoThis() {
    <font color=blue>auto</font> alloc = newRegionAllocator();
    <font color=blue>auto</font> ptr1 = alloc.allocate(42);
    <font color=blue>auto</font> alloc2 = newRegionAllocator();

    <font color=green>// Error:  Allocating from a RegionAllocator instance other than the
</font>    <font color=green>// most recently created one that's still alive from a given stack.
</font>    <font color=blue>auto</font> ptr = alloc.allocate(42);
}

<font color=blue>void</font> uninitialized() {
    <u>RegionAllocator</u> alloc;
    <font color=blue>auto</font> ptr = alloc.allocate(42);  <font color=green>// Error:  alloc is not initialized.
</font>    <font color=blue>auto</font> alloc2 = alloc;  <font color=green>// Ok.  Both alloc, alloc2 are uninitialized.
</font>
    alloc2 = newRegionAllocator();
    <font color=blue>auto</font> ptr2 = alloc2.allocate(42);  <font color=green>// Ok.
</font>    <font color=blue>auto</font> ptr3 = alloc.allocate(42);  <font color=green>// Error:  alloc is still uninitialized.
</font>
    alloc = alloc2;
    <font color=blue>auto</font> ptr4 = alloc.allocate(42);  <font color=green>// Ok.
</font>}
</pre>

<br><br>
<b>Note:</b><br>
Allocations larger than  are handled as a special
case and fall back to allocating directly from the C heap.  These large
allocations are freed as if they were allocated on a 
when  or  is called or the last copy of a
 instance goes out of scope.  However, due to the extra
bookkeeping required, destroying a region (as happens when the last copy of
a  instance goes out of scope) will require time linear
instead of constant in the number of allocations for regions where these
large allocations are present.<br><br>

<dl><dt><big><a name="RegionAllocator.allocate"></a>void* <u>allocate</u>(size_t <i>nBytes</i>);
</big></dt>
<dd>Allocates  bytes on the  used by this
     instance.  The last block allocated from this
     instance can be freed by calling
     or  or will be
    automatically freed when the last copy of this 
    instance goes out of scope.
<br><br>
Allocation requests larger than  are
    allocated directly on the C heap, are scanned by the GC iff
    the  instance that this object uses is scanned by
    the GC, and are freed according to the same rules as described above.<br><br>

</dd>
<dt><big><a name="RegionAllocator.freeLast"></a>void <u>freeLast</u>();
</big></dt>
<dd>Frees the last block of memory allocated by the current
    .  Throws a  if
    this  is not the most recently created still-existing
     using its  instance.<br><br>

</dd>
<dt><big><a name="RegionAllocator.free"></a>void <u>free</u>(void* <i>ptr</i>);
</big></dt>
<dd>Checks that  is a pointer to the block that would be freed by
     then calls .  Throws a
     if the pointer does not point to the
    block that would be freed by .<br><br>

</dd>
<dt><big><a name="RegionAllocator.resize"></a>bool <u>resize</u>(const(void)* <i>ptr</i>, size_t <i>newSize</i>);
</big></dt>
<dd>Attempts to <u>resize</u> a previously allocated block of memory in place.
    This is possible only if  points to the beginning of the last
    block allocated by this  instance and, in the
    case where  is greater than the old size, there is
    additional space in the segment that  was allocated from.
    Additionally, blocks larger than this 's segment size
    cannot be grown or shrunk.
<br><br>
<b>Returns:</b><br>
True if the block was successfully resized, <b>false</b> otherwise.<br><br>

</dd>
<dt><big><a name="RegionAllocator.gcScanned"></a>const pure nothrow @property @safe bool <u>gcScanned</u>();
</big></dt>
<dd>Returns whether the  used by this
     instance is scanned by the garbage collector.<br><br>

</dd>
<dt><big><a name="RegionAllocator.newArray"></a>auto <u>newArray</u>(T, I...)(I <i>sizes</i>) if (allSatisfy!(isIntegral, I));
</big></dt>
<dd>Allocates an array of type .   may be a multidimensional
    array.  In this case <i>sizes</i> may be specified for any number of dimensions
    from 1 to the number in .
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>auto</font> alloc = newRegionAllocator();
<font color=blue>double</font>[] arr = alloc.<u>newArray</u>!(<font color=blue>double</font>[])(100);
<font color=blue>assert</font>(arr.length == 100);

<font color=blue>double</font>[][] matrix = alloc.<u>newArray</u>!(<font color=blue>double</font>[][])(42, 31);
<font color=blue>assert</font>(matrix.length == 42);
<font color=blue>assert</font>(matrix[0].length == 31);
</pre>
<br><br>

</dd>
<dt><big><a name="RegionAllocator.uninitializedArray"></a>auto <u>uninitializedArray</u>(T, I...)(I <i>sizes</i>) if (allSatisfy!(isIntegral, I));
</big></dt>
<dd>Same as , except skips initialization of elements for
    performance reasons.<br><br>

</dd>
<dt><big><a name="RegionAllocator.alignBytes"></a>static size_t <u>alignBytes</u>(size_t <i>nBytes</i>);
</big></dt>
<dd>Returns the number of bytes to which an allocation of size <i>nBytes</i> is
    guaranteed to be aligned.<br><br>

</dd>
<dt><big><a name="RegionAllocator.allocSize"></a>static pure nothrow size_t <u>allocSize</u>(size_t <i>nBytes</i>);
</big></dt>
<dd>Returns the number of bytes used to satisfy an allocation request
    of .  Will return a value greater than or equal to
     to account for alignment overhead.<br><br>

</dd>
<dt><big><a name="RegionAllocator.isAutomatic"></a>enum bool <u>isAutomatic</u>;
</big></dt>
<dd>False because memory allocated by this allocator is not automatically
    reclaimed by the garbage collector.<br><br>

</dd>
<dt><big><a name="RegionAllocator.isScoped"></a>enum bool <u>isScoped</u>;
</big></dt>
<dd>True because, when the last last copy of a  instance
    goes out of scope, the memory it references is automatically freed.<br><br>

</dd>
<dt><big><a name="RegionAllocator.freeIsChecked"></a>enum bool <u>freeIsChecked</u>;
</big></dt>
<dd>True because if memory is freed via  instead of 
    then the pointer is checked for validity.<br><br>

</dd>
<dt><big><a name="RegionAllocator.segmentSize"></a>@property size_t <u>segmentSize</u>();
</big></dt>
<dd>Returns the segment size of the  used by this
    .<br><br>

</dd>
<dt><big><a name="RegionAllocator.segmentSlack"></a>@property size_t <u>segmentSlack</u>();
</big></dt>
<dd>Returns the maximum number of bytes that may be allocated in the
    current segment.<br><br>

</dd>
<dt><big><a name="RegionAllocator.array"></a>Unqual!(ElementType!R)[] <u>array</u>(R)(R <i>range</i>) if (isInputRange!R);
</big></dt>
<dd>Copies  to an <u>array</u>.  The <u>array</u> will be located on the
     stack if any of the following conditions apply:
<br><br>
1.   is <b>false</b>.
<br><br>

    2.   is a builtin <u>array</u>.  In this case  maintains pointers
        to all elements at least until  returns, preventing the
        elements from being freed by the garbage collector.  A similar
        assumption cannot be made for ranges other than builtin arrays.
<br><br>

    3.  The  instance used by this
         is scanned by the garbage collector.
<br><br>

    If none of these conditions is met, the <u>array</u> is returned on the C heap
    and  is called.  In either case, ,
    , or the last copy of this 
    instance going out of scope will free the <u>array</u> as if it had been
    allocated on the  stack.

<br><br>
<b>Rationale:</b><br>
The most common reason to call  on a builtin <u>array</u> is
                to modify its contents inside a function without affecting the
                caller's view.  In this case  is not modified and
                prevents the elements from being freed by the garbage
                collector.  Furthermore, if the copy returned does need
                to be scanned, the client can call  before
                modifying the original <u>array</u>.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>auto</font> alloc = newRegionAllocator();
<font color=blue>auto</font> arr = alloc.<u>array</u>(iota(5));
<font color=blue>assert</font>(arr == [0, 1, 2, 3, 4]);
</pre>
<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="newRegionAllocator"></a>RegionAllocator <u>newRegionAllocator</u>();
</big></dt>
<dd>Returns a new  that uses the default thread-local
 instance.<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
