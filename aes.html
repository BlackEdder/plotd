<html><head>
        <!-- Generated by Ddoc from ../../../.dub/packages/ggplotd-1.1.0/ggplotd/source/ggplotd/aes.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>ggplotd.aes</title>
        </head><body>
        <h1>ggplotd.aes</h1>
<br><br>
<dl><dt><big><a name="Pixel"></a>struct <u>Pixel</u>;
</big></dt>
<dd>Number of pixels
<br><br>
Mainly used to differentiate between drawing in plot coordinates or in pixel based coordinates.<br><br>

<dl><dt><big><a name="Pixel.this"></a>this(int <i>val</i>);
</big></dt>
<dd>Number of pixels in int<br><br>

</dd>
<dt><big><a name="Pixel.this.2"></a>this(Pixel <i>val</i>);
</big></dt>
<dd>Copy constructor<br><br>

</dd>
<dt><big><a name="Pixel.value"></a>int <u>value</u>;
</big></dt>
<dd>Number of pixels<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="aes"></a>alias <u>aes</u> = std.typecons.tuple(Names...);
</big></dt>
<dd>Map data fields to "aesthetic" fields understood by the ggplotd geom functions
<br><br>
The most commonly used aesthetic fields in ggplotd are "x" and "y". Which further data
    fields are used/required depends on the geom function being called.
<br><br>

    Other common fields:
    <ul>        <li>"colour": Identifier for the colour. In general data points with different colour ids get different colours. This can be almost any type. You can also specify the colour by name or cairo.Color type if you want to specify an exact colour (any type that isNumeric, cairo.Color.RGB(A), or can be converted to string)</li>
        <li>"size": Gives the relative size of points/lineWidth etc.</li>
        <li>"label": Text labels (string)</li>
        <li>"angle": Angle of printed labels in radians (double)</li>
        <li>"alpha": Alpha value of the drawn object (double)</li>
        <li>"mask": Mask the area outside the axes. Prevents you from drawing outside of the area (bool)</li>
        <li>"fill": Whether to fill the object/holds the alpha value to fill with (double).</li></ul>
<br><br>

    In practice <u>aes</u> is an alias for std.typecons.tuple.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>struct</font> Diamond
{
    string clarity = <font color=red>"SI2"</font>;
    <font color=blue>double</font> carat = 0.23;
    <font color=blue>double</font> price = 326;
}

Diamond diamond;

<font color=blue>auto</font> mapped = <u>aes</u>!(<font color=red>"colour"</font>, <font color=red>"x"</font>, <font color=red>"y"</font>)(diamond.clarity, diamond.carat, diamond.price);
<font color=blue>assert</font>(mapped.colour == <font color=red>"SI2"</font>);
<font color=blue>assert</font>(mapped.x == 0.23);
<font color=blue>assert</font>(mapped.y == 326);
</pre>

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>import</font> std.typecons : Tuple;
<font color=green>// aes returns a named tuple
</font><font color=blue>assert</font>(<u>aes</u>!(<font color=red>"x"</font>, <font color=red>"y"</font>)(1.0, 2.0) == Tuple!(<font color=blue>double</font>, <font color=red>"x"</font>, <font color=blue>double</font>, <font color=red>"y"</font>)(1.0, 2.0));
</pre>
<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> a = <u>aes</u>!(<font color=blue>int</font>, <font color=red>"y"</font>, <font color=blue>int</font>, <font color=red>"x"</font>)(1, 2);
assertEqual( a.y, 1 );
assertEqual( a.x, 2 );

<font color=blue>auto</font> a1 = <u>aes</u>!(<font color=red>"y"</font>, <font color=red>"x"</font>)(1, 2);
assertEqual( a1.y, 1 );
assertEqual( a1.x, 2 );

<font color=blue>auto</font> a2 = <u>aes</u>!(<font color=red>"y"</font>)(1);
assertEqual( a2.y, 1 );


<font color=blue>import</font> std.range : zip;
<font color=blue>import</font> std.algorithm : map;
<font color=blue>auto</font> xs = [0,1];
<font color=blue>auto</font> ys = [2,3];
<font color=blue>auto</font> points = xs.zip(ys).map!((t) =&gt; <u>aes</u>!(<font color=red>"x"</font>, <font color=red>"y"</font>)(t[0], t[1]));
assertEqual(points.front.x, 0);
assertEqual(points.front.y, 2);
points.popFront;
assertEqual(points.front.x, 1);
assertEqual(points.front.y, 3);
</pre>
<br><br>
</dd>
<dt><big><a name="DefaultValues"></a>static Tuple!(string, "label", string, "colour", double, "size", double, "angle", double, "alpha", bool, "mask", double, "fill") <u>DefaultValues</u>;
</big></dt>
<dd>Default values for most settings<br><br>

</dd>
<dt><big><a name="Aes"></a>struct <u>Aes</u>(Specs...);
</big></dt>
<dd><u>Aes</u> is used to store and access data for plotting
<br><br>
<u>Aes</u> is an InputRange, with named Tuples as the ElementType. The names
    refer to certain fields, such as x, y, colour etc.
<br><br>

    The fields commonly used are data fields, such as "x" and "y". Which data
    fields are required depends on the geom function being called.
<br><br>

    Other common fields:
    <ul>        <li>"label": Text labels (string)</li>
        <li>"colour": Identifier for the colour. In general data points with different colour ids get different colours. This can be almost any type. You can also specify the colour by name or cairo.Color type if you want to specify an exact colour (any type that isNumeric, cairo.Color.RGB(A), or can be converted to string)</li>
        <li>"size": Gives the relative size of points/lineWidth etc.</li>
        <li>"angle": Angle of printed labels in radians (double)</li>
        <li>"alpha": Alpha value of the drawn object (double)</li>
        <li>"mask": Mask the area outside the axes. Prevents you from drawing outside of the area (bool)</li>
        <li>"fill": Whether to fill the object/holds the alpha value to fill with (double).</li></ul><br><br>
<b>Examples:</b><br>
Basic <u>Aes</u> usage
<pre class="d_code">
<font color=blue>auto</font> aes = <u>Aes</u>!(<font color=blue>double</font>[], <font color=red>"x"</font>, <font color=blue>double</font>[], <font color=red>"y"</font>, string[], <font color=red>"colour"</font>)([0.0, 1],
    [2, 1.0], [<font color=red>"white"</font>, <font color=red>"white2"</font>]);

aes.popFront;
assertEqual(aes.front.y, 1);
assertEqual(aes.front.colour, <font color=red>"white2"</font>);

<font color=blue>auto</font> aes2 = <u>Aes</u>!(<font color=blue>double</font>[], <font color=red>"x"</font>, <font color=blue>double</font>[], <font color=red>"y"</font>)([0.0, 1], [2.0, 1]);
assertEqual(aes2.front.y, 2);

<font color=blue>import</font> std.range : repeat;

<font color=blue>auto</font> xs = repeat(0);
<font color=blue>auto</font> aes3 = <u>Aes</u>!(<font color=blue>typeof</font>(xs), <font color=red>"x"</font>, <font color=blue>double</font>[], <font color=red>"y"</font>)(xs, [2.0, 1]);

assertEqual(aes3.front.x, 0);
aes3.popFront;
aes3.popFront;
assertEqual(aes3.empty, <font color=blue>true</font>);
</pre>
<br><br>
</dd>
<dt><big><a name="group"></a>template <u>group</u>(Specs...)</big></dt>
<dd>Groups data by colour label etc.
<br><br>
Will also add DefaultValues for label etc to the data. It is also possible to specify exactly what to <u>group</u> by on as a template parameter. See example.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>import</font> std.range : walkLength;
<font color=blue>auto</font> aes = Aes!(<font color=blue>double</font>[], <font color=red>"x"</font>, string[], <font color=red>"colour"</font>, <font color=blue>double</font>[], <font color=red>"alpha"</font>)
    ([0.0,1,2,3], [<font color=red>"a"</font>,<font color=red>"a"</font>,<font color=red>"b"</font>,<font color=red>"b"</font>], [0.0,1,0,1]);

assertEqual(<u>group</u>!(<font color=red>"colour"</font>,<font color=red>"alpha"</font>)(aes).walkLength,4);
assertEqual(<u>group</u>!(<font color=red>"alpha"</font>)(aes).walkLength,2);

<font color=green>// Ignores field that does not exist
</font>assertEqual(<u>group</u>!(<font color=red>"alpha"</font>,<font color=red>"abcdef"</font>)(aes).walkLength,2);

<font color=green>// Should return one group holding them all
</font>assertEqual(<u>group</u>!(<font color=red>"abcdef"</font>)(aes)[0].walkLength,4);

assertEqual(<u>group</u>(aes).walkLength,4);
</pre>
<br><br><b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> aes = Aes!(<font color=blue>double</font>[], <font color=red>"x"</font>, <font color=blue>double</font>[], <font color=red>"y"</font>, string[], <font color=red>"colour"</font>)([1.0,
    2.0, 1.1], [3.0, 1.5, 1.1], [<font color=red>"a"</font>, <font color=red>"b"</font>, <font color=red>"a"</font>]);

<font color=blue>import</font> std.range : walkLength, front, popFront;

<font color=blue>auto</font> grouped = aes.<u>group</u>;
assertEqual(grouped.walkLength, 2);
size_t totalLength = grouped.front.walkLength;
assertGreaterThan(totalLength, 0);
assertLessThan(totalLength, 3);
grouped.popFront;
assertEqual(totalLength + grouped.front.walkLength, 3);
</pre>
<br><br>
</dd>
<dt><big><a name="DataID"></a>struct <u>DataID</u>;
</big></dt>
<dd><u>DataID</u> is used to refer represent any type as a usable type<br><br>

<dl><dt><big><a name="DataID.this"></a>this(double <i>value</i>, string <i>id</i>);
</big></dt>
<dd>Create DataID with given <i>value</i> and <i>id</i><br><br>

</dd>
<dt><big><a name="DataID.to"></a>const T <u>to</u>(T)();
</big></dt>
<dd>Overloading <u>to</u> for the DataID<br><br>

</dd>
<dt><big><a name="DataID.state"></a>Tuple!(double, string) <u>state</u>;
</big></dt>
<dd>Tuple holding the value and id<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="merge"></a>auto <u>merge</u>(T, U)(T <i>base</i>, U <i>other</i>);
</big></dt>
<dd>Merge two types by their members.
<br><br>
If it has similar named members, then it uses the second one.
<br><br>

returns a named Tuple (or Aes) with all the members and their values.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>struct</font> Point { <font color=blue>double</font> x; <font color=blue>double</font> y; string label = <font color=red>"Point"</font>; }
<font color=blue>auto</font> pnt = Point( 1.0, 2.0 );

<font color=blue>auto</font> merged = DefaultValues.<u>merge</u>( pnt );
assertEqual( merged.x, 1.0 );
assertEqual( merged.y, 2.0 );
assertEqual( merged.colour, <font color=red>"black"</font> );
assertEqual( merged.label, <font color=red>"Point"</font> );
</pre>
<br><br>
</dd>
<dt><big><a name="mergeRange"></a>deprecated alias <u>mergeRange</u> = ggplotd.range.<u>mergeRange</u>(R1, R2)(R1 r1, R2 r2) if (isInputRange!R1 || isInputRange!R2);
</big></dt>
<dd><font color=red>Deprecated:</font><br>
Moved to ggplotd.range;<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
