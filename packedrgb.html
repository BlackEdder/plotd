<html><head>
        <!-- Generated by Ddoc from ../../../.dub/packages/color-0.0.5/color/std/experimental/color/packedrgb.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>std.experimental.color.packedrgb</title>
        </head><body>
        <h1>std.experimental.color.packedrgb</h1>
This module implements the packed RGB color type.
<br><br>
<b>Authors:</b><br>
Manu Evans
<br><br>
<b>License:</b><br>

<br><br>
<b>Source:</b><br>
<br><br>

<dl><dt><big><a name="isPackedRGB"></a>enum auto <u>isPackedRGB</u>(T);
</big></dt>
<dd>Detect whether <pre style="display:inline;" class="d_inline_code">T</pre> is a packed RGB color.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> <font color=blue>assert</font>(<u>isPackedRGB</u>!(PackedRGB!(<font color=red>"rgb_5_6_5"</font>, <font color=blue>ubyte</font>)) == <font color=blue>true</font>);
<font color=blue>static</font> <font color=blue>assert</font>(<u>isPackedRGB</u>!(PackedRGB!(<font color=red>"rgba_s10_s10_s10_u2"</font>, <font color=blue>short</font>)) == <font color=blue>true</font>);
<font color=blue>static</font> <font color=blue>assert</font>(<u>isPackedRGB</u>!(PackedRGB!(<font color=red>"rg_f16_f16"</font>, <font color=blue>float</font>)) == <font color=blue>true</font>);
<font color=blue>static</font> <font color=blue>assert</font>(<u>isPackedRGB</u>!(PackedRGB!(<font color=red>"rgb_f11_f11_f10"</font>, <font color=blue>float</font>)) == <font color=blue>true</font>);
<font color=blue>static</font> <font color=blue>assert</font>(<u>isPackedRGB</u>!(PackedRGB!(<font color=red>"rgb_9_9_9_e5"</font>, <font color=blue>float</font>)) == <font color=blue>true</font>);
<font color=blue>static</font> <font color=blue>assert</font>(<u>isPackedRGB</u>!(PackedRGB!(<font color=red>"rgb_f10_s4_u2"</font>, <font color=blue>float</font>)) == <font color=blue>true</font>);
<font color=blue>static</font> <font color=blue>assert</font>(<u>isPackedRGB</u>!<font color=blue>int</font> == <font color=blue>false</font>);
</pre>
<br><br>
</dd>
<dt><big><a name="ComponentInfo"></a>struct <u>ComponentInfo</u>;
</big></dt>
<dd>Component info struct.<br><br>

<dl><dt><big><a name="ComponentInfo.ComponentType"></a>enum <u>ComponentType</u>: ubyte;
</big></dt>
<dd>Type of the component.<br><br>

<dl><dt><big><a name="ComponentInfo.ComponentType.Unsigned"></a><u>Unsigned</u></big></dt>
<dd>Component is unsigned normalized integer.<br><br>

</dd>
<dt><big><a name="ComponentInfo.ComponentType.Signed"></a><u>Signed</u></big></dt>
<dd>Component is signed normalized integer.<br><br>

</dd>
<dt><big><a name="ComponentInfo.ComponentType.Float"></a><u>Float</u></big></dt>
<dd>Component is floating point. Floats with less than 16 bits precision are unsigned.<br><br>

</dd>
<dt><big><a name="ComponentInfo.ComponentType.Mantissa"></a><u>Mantissa</u></big></dt>
<dd>Component is floating point mantissa only.<br><br>

</dd>
<dt><big><a name="ComponentInfo.ComponentType.Exponent"></a><u>Exponent</u></big></dt>
<dd>Component is floating point exponent only.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="ComponentInfo.offset"></a>ubyte <u>offset</u>;
</big></dt>
<dd>First bit, starting from bit 0 (LSB).<br><br>

</dd>
<dt><big><a name="ComponentInfo.bits"></a>ubyte <u>bits</u>;
</big></dt>
<dd>Number of <u>bits</u>.<br><br>

</dd>
<dt><big><a name="ComponentInfo.type"></a>ComponentType <u>type</u>;
</big></dt>
<dd>Component <u>type</u>.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Buffer"></a>struct <u>Buffer</u>(size_t N);
</big></dt>
<dd><u>Buffer</u> used for bit-packing.<br><br>

<dl><dt><big><a name="Buffer.bits"></a>const @property uint <u>bits</u>(size_t Offset, size_t Bits)();
</big></dt>
<dd>Read <u>bits</u> from the buffer.<br><br>

</dd>
<dt><big><a name="Buffer.bits.2"></a>@property void <u>bits</u>(size_t Offset, size_t Bits)(uint <i>value</i>);
</big></dt>
<dd>Write <u>bits</u> to the buffer.<br><br>

</dd>
<dt><big><a name="Buffer.ElementWidth"></a>enum auto <u>ElementWidth</u>;
</big></dt>
<dd>Element width for multi-element buffers.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="PackedRGB"></a>struct <u>PackedRGB</u>(string format_, ComponentType_, RGBColorSpace colorSpace_ = RGBColorSpace.sRGB) if (isNumeric!ComponentType_);
</big></dt>
<dd>A packed RGB color, parameterised with format, unpacked component type, and color space specification.
<br><br>
<b>Params:</b><br>
<table><tr><td>format_</td>
<td>Format of the packed color.<br>
                  Format shall be arranged for instance: "rgba_10_10_10_2" for 10 bits each RGB, and 2 bits alpha, starting from the least significant bit.<br>
                  Formats may specify packed floats: "rgba_f16_f16_f16_f16" for an RGBA half-precision float color.<br>
                  Low-precision floats are supported: "rgb_f11_f11_f10" for an RGB partial-precision floating point format. Floats with less than 16 bits always have a 5 bit exponent, and no sign bit.<br>
                  Formats may specify a shared exponent: "rgb_9_9_9_e5" for 9 mantissa bits each RGB, and a 5 bit shared exponent.<br>
                  Formats may specify the signed-ness for integer components: "rgb_s5_s5_s5_u1" for 5 bit signed RGB, and a 1 bit unsigned alpha. The 'u' is optional, default is assumed to be unsigned.<br>
                  Formats may contain a combination of the color channels r, g, b, l, a, x, in any order. Color channels l, and r, g, b are mutually exclusive, and may not appear together in the same color.</td></tr>
<tr><td>ComponentType_</td>
<td>Type for the unpacked color channels. May be a basic integer or floating point type.</td></tr>
<tr><td>colorSpace_</td>
<td>Color will be within the specified color space.</td></tr>
</table><br>

<dl><dt><big><a name="PackedRGB.UnpackedColor"></a>alias <u>UnpackedColor</u> = RGB!(components, ComponentType_, false, colorSpace_);
</big></dt>
<dd>The unpacked color type.<br><br>

</dd>
<dt><big><a name="PackedRGB.format"></a>enum auto <u>format</u>;
</big></dt>
<dd>The packed color <u>format</u>.<br><br>

</dd>
<dt><big><a name="PackedRGB.components"></a>enum string <u>components</u>;
</big></dt>
<dd>The color <u>components</u> that were specified.<br><br>

</dd>
<dt><big><a name="PackedRGB.componentInfo"></a>enum ComponentInfo[components.length] <u>componentInfo</u>;
</big></dt>
<dd>Bit assignments for each component.<br><br>

</dd>
<dt><big><a name="PackedRGB.sharedExponent"></a>enum ComponentInfo <u>sharedExponent</u>;
</big></dt>
<dd>Shared exponent bits.<br><br>

</dd>
<dt><big><a name="PackedRGB.hasSharedExponent"></a>enum bool <u>hasSharedExponent</u>;
</big></dt>
<dd>If the format has a shared exponent.<br><br>

</dd>
<dt><big><a name="PackedRGB.colorSpace"></a>enum RGBColorSpace <u>colorSpace</u>;
</big></dt>
<dd>The colors color space.<br><br>

</dd>
<dt><big><a name="PackedRGB.colorSpaceDesc"></a>enum RGBColorSpaceDesc!F <u>colorSpaceDesc</u>(F = double);
</big></dt>
<dd>The color space descriptor.<br><br>

</dd>
<dt><big><a name="PackedRGB.BitsPerElement"></a>enum auto <u>BitsPerElement</u>;
</big></dt>
<dd>Number of bits per element.<br><br>

</dd>
<dt><big><a name="PackedRGB.data"></a>Buffer!(BitsPerElement / 8) <u>data</u>;
</big></dt>
<dd>The raw packed <u>data</u>.<br><br>

</dd>
<dt><big><a name="PackedRGB.hasComponent"></a>enum bool <u>hasComponent</u>(char c);
</big></dt>
<dd>Test if a particular component is present.<br><br>

</dd>
<dt><big><a name="PackedRGB.hasAlpha"></a>enum bool <u>hasAlpha</u>;
</big></dt>
<dd>If the color has alpha.<br><br>

</dd>
<dt><big><a name="PackedRGB.unpacked"></a>@property ParentColor <u>unpacked</u>();
</big></dt>
<dd>The <u>unpacked</u> color.<br><br>

</dd>
<dt><big><a name="PackedRGB.this"></a>this(UnpackedColor <i>color</i>);
</big></dt>
<dd>Construct a <i>color</i> from RGB and optional alpha values.<br><br>

</dd>
<dt><big><a name="PackedRGB.opCast"></a>const Color <u>opCast</u>(Color)() if (isColor!Color);
</big></dt>
<dd>Cast to other color types<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. Copyright (c) 2015, Manu Evans.
</small>
        </body></html>
