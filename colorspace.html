<html><head>
        <!-- Generated by Ddoc from ../../../.dub/packages/color-0.0.5/color/std/experimental/color/colorspace.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>std.experimental.color.colorspace</title>
        </head><body>
        <h1>std.experimental.color.colorspace</h1>
This module defines and operates on standard color spaces.
<br><br>
<b>Authors:</b><br>
Manu Evans
<br><br>
<b>License:</b><br>

<br><br>
<b>Source:</b><br>
<br><br>

<dl><dt><big><a name="WhitePoint"></a>template <u>WhitePoint</u>(F) if (isFloatingPoint!F)</big></dt>
<dd>White points of standard illuminants.<br><br>

<dl><dt><big><a name="WhitePoint.WhitePoint"></a>enum <u>WhitePoint</u>;
</big></dt>
<dd><br><br>
<dl><dt><big><a name="WhitePoint.WhitePoint.A"></a><u>A</u></big></dt>
<dd>Incandescent / Tungsten<br><br>

</dd>
<dt><big><a name="WhitePoint.WhitePoint.B"></a><u>B</u></big></dt>
<dd>[obsolete] Direct sunlight at noon<br><br>

</dd>
<dt><big><a name="WhitePoint.WhitePoint.C"></a><u>C</u></big></dt>
<dd>[obsolete] Average / North sky Daylight<br><br>

</dd>
<dt><big><a name="WhitePoint.WhitePoint.D50"></a><u>D50</u></big></dt>
<dd>Horizon Light, ICC profile PCS (Profile connection space)<br><br>

</dd>
<dt><big><a name="WhitePoint.WhitePoint.D55"></a><u>D55</u></big></dt>
<dd>Mid-morning / Mid-afternoon Daylight<br><br>

</dd>
<dt><big><a name="WhitePoint.WhitePoint.D65"></a><u>D65</u></big></dt>
<dd>Noon Daylight: Television, sRGB color space<br><br>

</dd>
<dt><big><a name="WhitePoint.WhitePoint.D75"></a><u>D75</u></big></dt>
<dd>North sky Daylight<br><br>

</dd>
<dt><big><a name="WhitePoint.WhitePoint.D93"></a><u>D93</u></big></dt>
<dd>Used by Japanese NTSC<br><br>

</dd>
<dt><big><a name="WhitePoint.WhitePoint.E"></a><u>E</u></big></dt>
<dd>Equal energy<br><br>

</dd>
<dt><big><a name="WhitePoint.WhitePoint.F1"></a><u>F1</u></big></dt>
<dd>Daylight Fluorescent<br><br>

</dd>
<dt><big><a name="WhitePoint.WhitePoint.F2"></a><u>F2</u></big></dt>
<dd>Cool White Fluorescent<br><br>

</dd>
<dt><big><a name="WhitePoint.WhitePoint.F3"></a><u>F3</u></big></dt>
<dd>White Fluorescent<br><br>

</dd>
<dt><big><a name="WhitePoint.WhitePoint.F4"></a><u>F4</u></big></dt>
<dd>Warm White Fluorescent<br><br>

</dd>
<dt><big><a name="WhitePoint.WhitePoint.F5"></a><u>F5</u></big></dt>
<dd>Daylight Fluorescent<br><br>

</dd>
<dt><big><a name="WhitePoint.WhitePoint.F6"></a><u>F6</u></big></dt>
<dd>Lite White Fluorescent<br><br>

</dd>
<dt><big><a name="WhitePoint.WhitePoint.F7"></a><u>F7</u></big></dt>
<dd>D65 simulator, Daylight simulator<br><br>

</dd>
<dt><big><a name="WhitePoint.WhitePoint.F8"></a><u>F8</u></big></dt>
<dd>D50 simulator, Sylvania F40 Design 50<br><br>

</dd>
<dt><big><a name="WhitePoint.WhitePoint.F9"></a><u>F9</u></big></dt>
<dd>Cool White Deluxe Fluorescent<br><br>

</dd>
<dt><big><a name="WhitePoint.WhitePoint.F10"></a><u>F10</u></big></dt>
<dd>Philips TL85, Ultralume 50<br><br>

</dd>
<dt><big><a name="WhitePoint.WhitePoint.F11"></a><u>F11</u></big></dt>
<dd>Philips TL84, Ultralume 40<br><br>

</dd>
<dt><big><a name="WhitePoint.WhitePoint.F12"></a><u>F12</u></big></dt>
<dd>Philips TL83, Ultralume 30<br><br>

</dd>
<dt><big><a name="WhitePoint.WhitePoint.DCI"></a><u>DCI</u></big></dt>
<dd><u>DCI</u>-P3 digital cinema projector<br><br>

</dd>
</dl>
</dd>
</dl>
</dd>
<dt><big><a name="RGBColorSpace"></a>enum <u>RGBColorSpace</u>: int;
</big></dt>
<dd>Enum of common RGB color spaces.<br><br>

<dl><dt><big><a name="RGBColorSpace.sRGB"></a><u>sRGB</u></big></dt>
<dd><u>sRGB</u><br><br>

</dd>
<dt><big><a name="RGBColorSpace.sRGB_Gamma2_2"></a><u>sRGB_Gamma2_2</u></big></dt>
<dd>sRGB approximation using gamma 2.2<br><br>

</dd>
<dt><big><a name="RGBColorSpace.Colorimetry"></a><u>Colorimetry</u></big></dt>
<dd>NTSC <u>Colorimetry</u> (1953)<br><br>

</dd>
<dt><big><a name="RGBColorSpace.SMPTE_C"></a><u>SMPTE_C</u></big></dt>
<dd>NTSC SMPTE/C (1987) (ITU-R BT.601)<br><br>

</dd>
<dt><big><a name="RGBColorSpace.NTSC_J"></a><u>NTSC_J</u></big></dt>
<dd>Japanese NTSC (1987) (ITU-R BT.601)<br><br>

</dd>
<dt><big><a name="RGBColorSpace.PAL_SECAM"></a><u>PAL_SECAM</u></big></dt>
<dd>PAL/SECAM (ITU-R BT.601)<br><br>

</dd>
<dt><big><a name="RGBColorSpace.HDTV"></a><u>HDTV</u></big></dt>
<dd><u>HDTV</u> (ITU-R BT.709)<br><br>

</dd>
<dt><big><a name="RGBColorSpace.UHDTV"></a><u>UHDTV</u></big></dt>
<dd><u>UHDTV</u> (ITU-R BT.2020)<br><br>

</dd>
<dt><big><a name="RGBColorSpace.AdobeRGB"></a><u>AdobeRGB</u></big></dt>
<dd>Adobe RGB<br><br>

</dd>
<dt><big><a name="RGBColorSpace.WideGamutRGB"></a><u>WideGamutRGB</u></big></dt>
<dd>Wide Gamut RGB<br><br>

</dd>
<dt><big><a name="RGBColorSpace.AppleRGB"></a><u>AppleRGB</u></big></dt>
<dd>Apple RGB<br><br>

</dd>
<dt><big><a name="RGBColorSpace.ProPhoto"></a><u>ProPhoto</u></big></dt>
<dd><u>ProPhoto</u><br><br>

</dd>
<dt><big><a name="RGBColorSpace.CIERGB"></a><u>CIERGB</u></big></dt>
<dd>CIE RGB<br><br>

</dd>
<dt><big><a name="RGBColorSpace.BestRGB"></a><u>BestRGB</u></big></dt>
<dd>Best RGB<br><br>

</dd>
<dt><big><a name="RGBColorSpace.BetaRGB"></a><u>BetaRGB</u></big></dt>
<dd>Beta RGB<br><br>

</dd>
<dt><big><a name="RGBColorSpace.BruceRGB"></a><u>BruceRGB</u></big></dt>
<dd>Bruce RGB<br><br>

</dd>
<dt><big><a name="RGBColorSpace.ColorMatchRGB"></a><u>ColorMatchRGB</u></big></dt>
<dd>Color Match RGB<br><br>

</dd>
<dt><big><a name="RGBColorSpace.DonRGB4"></a><u>DonRGB4</u></big></dt>
<dd>DonRGB 4<br><br>

</dd>
<dt><big><a name="RGBColorSpace.EktaSpacePS5"></a><u>EktaSpacePS5</u></big></dt>
<dd>Ekta Space PS5<br><br>

</dd>
<dt><big><a name="RGBColorSpace.DCI_P3_Theater"></a><u>DCI_P3_Theater</u></big></dt>
<dd>DCI-P3 Theater<br><br>

</dd>
<dt><big><a name="RGBColorSpace.DCI_P3_D65"></a><u>DCI_P3_D65</u></big></dt>
<dd>DCI-P3 D65<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="ChromaticAdaptationMethod"></a>enum <u>ChromaticAdaptationMethod</u>: int;
</big></dt>
<dd>Chromatic adaptation method.<br><br>

<dl><dt><big><a name="ChromaticAdaptationMethod.XYZ"></a><u>XYZ</u></big></dt>
<dd>Direct method, no correction for cone response.<br><br>

</dd>
<dt><big><a name="ChromaticAdaptationMethod.Bradford"></a><u>Bradford</u></big></dt>
<dd><u>Bradford</u> method. Considered by most experts to be the best.<br><br>

</dd>
<dt><big><a name="ChromaticAdaptationMethod.VonKries"></a><u>VonKries</u></big></dt>
<dd>Von Kries method.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="RGBColorSpaceDesc"></a>struct <u>RGBColorSpaceDesc</u>(F) if (isFloatingPoint!F);
</big></dt>
<dd>Parameters that define an RGB color space.<br>
<pre style="display:inline;" class="d_inline_code">F</pre> is the float type that should be used for the colors and gamma functions.<br><br>

<dl><dt><big><a name="RGBColorSpaceDesc.GammaFunc"></a>alias <u>GammaFunc</u> = F function(F v) pure nothrow @nogc @safe;
</big></dt>
<dd>Gamma conversion function type.<br><br>

</dd>
<dt><big><a name="RGBColorSpaceDesc.name"></a>string <u>name</u>;
</big></dt>
<dd>Color space <u>name</u>.<br><br>

</dd>
<dt><big><a name="RGBColorSpaceDesc.toGamma"></a>GammaFunc <u>toGamma</u>;
</big></dt>
<dd>Function that converts a linear luminance to gamme space.<br><br>

</dd>
<dt><big><a name="RGBColorSpaceDesc.toLinear"></a>GammaFunc <u>toLinear</u>;
</big></dt>
<dd>Function that converts a gamma luminance to linear space.<br><br>

</dd>
<dt><big><a name="RGBColorSpaceDesc.white"></a>xyY!F <u>white</u>;
</big></dt>
<dd>White point.<br><br>

</dd>
<dt><big><a name="RGBColorSpaceDesc.red"></a>xyY!F <u>red</u>;
</big></dt>
<dd>Red point.<br><br>

</dd>
<dt><big><a name="RGBColorSpaceDesc.green"></a>xyY!F <u>green</u>;
</big></dt>
<dd>Green point.<br><br>

</dd>
<dt><big><a name="RGBColorSpaceDesc.blue"></a>xyY!F <u>blue</u>;
</big></dt>
<dd>Blue point.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="rgbColorSpaceDef"></a>RGBColorSpaceDesc!F <u>rgbColorSpaceDef</u>(F = double)(RGBColorSpace <i>colorSpace</i>) if (isFloatingPoint!F);
</big></dt>
<dd>Color space descriptor for the specified color space.<br><br>

</dd>
<dt><big><a name="rgbToXyzMatrix"></a>F[3][3] <u>rgbToXyzMatrix</u>(F = double)(RGBColorSpaceDesc!F <i>cs</i>) if (isFloatingPoint!F);
</big></dt>
<dd>RGB to XYZ color space transformation matrix.<br>
<pre style="display:inline;" class="d_inline_code"><i>cs</i></pre> describes the source RGB color space.<br><br>

</dd>
<dt><big><a name="xyzToRgbMatrix"></a>F[3][3] <u>xyzToRgbMatrix</u>(F = double)(RGBColorSpaceDesc!F <i>cs</i>) if (isFloatingPoint!F);
</big></dt>
<dd>XYZ to RGB color space transformation matrix.<br>
<pre style="display:inline;" class="d_inline_code"><i>cs</i></pre> describes the target RGB color space.<br><br>

</dd>
<dt><big><a name="chromaticAdaptationMatrix"></a>F[3][3] <u>chromaticAdaptationMatrix</u>(ChromaticAdaptationMethod method = ChromaticAdaptationMethod.Bradford, F = double)(xyY!F <i>srcWhite</i>, xyY!F <i>destWhite</i>) if (isFloatingPoint!F);
</big></dt>
<dd>Generate a chromatic adaptation matrix from <pre style="display:inline;" class="d_inline_code"><i>srcWhite</i></pre> to <pre style="display:inline;" class="d_inline_code"><i>destWhite</i></pre>.<br><br>

</dd>
<dt><big><a name="linearToHybridGamma"></a>T <u>linearToHybridGamma</u>(double a, double b, double s, double e, T)(T <i>v</i>) if (isFloatingPoint!T);
</big></dt>
<dd>Linear to hybrid linear-gamma ramp function.  The function and parameters are detailed in the example below.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=green>// sRGB parameters
</font><font color=blue>enum</font> a = 1.055;
<font color=blue>enum</font> b = 0.0031308;
<font color=blue>enum</font> s = 12.92;
<font color=blue>enum</font> e = 1/2.4;

<font color=blue>double</font> <i>v</i> = 0.5;

<font color=green>// the gamma function
</font><font color=blue>if</font> (<i>v</i> &lt;= b)
    <i>v</i> = <i>v</i>*s;
<font color=blue>else</font>
    <i>v</i> = a*<i>v</i>^^e - (a - 1);

<font color=blue>assert</font>(abs(<i>v</i> - <u>linearToHybridGamma</u>!(a, b, s, e)(0.5)) &lt; <font color=blue>double</font>.epsilon);
</pre>
<br><br>
</dd>
<dt><big><a name="hybridGammaToLinear"></a>T <u>hybridGammaToLinear</u>(double a, double b, double s, double e, T)(T <i>v</i>) if (isFloatingPoint!T);
</big></dt>
<dd>Hybrid linear-gamma to linear function. The function and parameters are detailed in the example below.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=green>// sRGB parameters
</font><font color=blue>enum</font> a = 1.055;
<font color=blue>enum</font> b = 0.0031308;
<font color=blue>enum</font> s = 12.92;
<font color=blue>enum</font> e = 2.4;

<font color=blue>double</font> <i>v</i> = 0.5;

<font color=green>// the gamma function
</font><font color=blue>if</font> (<i>v</i> &lt;= b*s)
    <i>v</i> = <i>v</i>/s;
<font color=blue>else</font>
    <i>v</i> = ((<i>v</i> + (a - 1)) / a)^^e;

<font color=blue>assert</font>(abs(<i>v</i> - <u>hybridGammaToLinear</u>!(a, b, s, e)(0.5)) &lt; <font color=blue>double</font>.epsilon);
</pre>
<br><br>
</dd>
<dt><big><a name="linearTosRGB"></a>template <u>linearTosRGB</u>(F)</big></dt>
<dd>Linear to sRGB ramp function.<br><br>

</dd>
<dt><big><a name="sRGBToLinear"></a>template <u>sRGBToLinear</u>(F)</big></dt>
<dd>sRGB to linear function.<br><br>

</dd>
<dt><big><a name="linearToRec601"></a>template <u>linearToRec601</u>(F)</big></dt>
<dd>Linear to Rec.601 ramp function.<br><br>

</dd>
<dt><big><a name="rec601ToLinear"></a>template <u>rec601ToLinear</u>(F)</big></dt>
<dd>Rec.601 to linear function.<br><br>

</dd>
<dt><big><a name="linearToRec2020"></a>template <u>linearToRec2020</u>(F)</big></dt>
<dd>Linear to Rec.2020 ramp function.<br><br>

</dd>
<dt><big><a name="rec2020ToLinear"></a>template <u>rec2020ToLinear</u>(F)</big></dt>
<dd>Rec.2020 to linear function.<br><br>

</dd>
<dt><big><a name="linearToGamma"></a>T <u>linearToGamma</u>(double gamma, T)(T <i>v</i>) if (isFloatingPoint!T);
</big></dt>
<dd>Linear to gamma space function.<br><br>

</dd>
<dt><big><a name="linearToGamma.2"></a>T <u>linearToGamma</u>(T)(T <i>v</i>, T <i>gamma</i>) if (isFloatingPoint!T);
</big></dt>
<dd>Linear to <i>gamma</i> space function.<br><br>

</dd>
<dt><big><a name="gammaToLinear"></a>T <u>gammaToLinear</u>(double gamma, T)(T <i>v</i>) if (isFloatingPoint!T);
</big></dt>
<dd>Gamma to linear function.<br><br>

</dd>
<dt><big><a name="gammaToLinear.2"></a>T <u>gammaToLinear</u>(T)(T <i>v</i>, T <i>gamma</i>) if (isFloatingPoint!T);
</big></dt>
<dd>Gamma to linear function.<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. Copyright (c) 2016, Manu Evans.
</small>
        </body></html>
